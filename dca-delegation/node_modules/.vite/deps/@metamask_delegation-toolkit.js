import {
  createBundlerClient,
  entryPoint07Abi,
  toPackedUserOperation,
  toSmartAccount
} from "./chunk-A625BFG4.js";
import "./chunk-EGRHWZRV.js";
import "./chunk-465KZFV4.js";
import {
  Field,
  createCurve,
  createHasher,
  mapToCurveSimpleSWU,
  sha256
} from "./chunk-YJI2MJFR.js";
import {
  ANY_BENEFICIARY,
  BalanceChangeType,
  DelegationManager_exports,
  EIP7702StatelessDeleGator_exports,
  ExecutionMode,
  HybridDeleGator_exports,
  MultiSigDeleGator_exports,
  ROOT_AUTHORITY,
  SIGNABLE_DELEGATION_TYPED_DATA,
  __export,
  contracts_exports,
  createCaveat,
  createDelegation,
  createExecution,
  createOpenDelegation,
  encode14,
  encode15,
  encode16,
  encode2,
  encode7,
  encodeExecutionCalldatas,
  encodePermissionContexts,
  encodeProxyCreationCode,
  getDelegationHashOffchain,
  prepareSignDelegationTypedData,
  read7,
  read_exports,
  read_exports2,
  read_exports3,
  read_exports4,
  read_exports5,
  signDelegation,
  toDelegationStruct
} from "./chunk-FUZ3ADWD.js";
import "./chunk-NKJKJAPU.js";
import "./chunk-5ODHDNB7.js";
import {
  signTypedData
} from "./chunk-ZCTDCF4T.js";
import "./chunk-L7F5A3MB.js";
import "./chunk-YH7NYZ27.js";
import "./chunk-4PF4RIN3.js";
import {
  encodePacked,
  getCode,
  getContractAddress
} from "./chunk-YUO6VYPB.js";
import {
  encodeFunctionData,
  isAddressEqual,
  parseAbiParameters
} from "./chunk-HUJM7M2K.js";
import "./chunk-RNQTYLB3.js";
import "./chunk-YK4YHBWF.js";
import {
  BaseError,
  concat,
  encodeAbiParameters,
  keccak256,
  pad,
  parseAccount
} from "./chunk-RIFGJDZJ.js";
import "./chunk-LT7VOR7H.js";
import "./chunk-QWDIAZ2G.js";
import "./chunk-YV3ZOOIK.js";
import "./chunk-MZBWV6HK.js";
import {
  bytesToHex,
  hexToBytes
} from "./chunk-T3DYZER6.js";
import "./chunk-MMN2DTB3.js";

// node_modules/@metamask/delegation-toolkit/dist/chunk-IVSH2AQS.mjs
var SIGNABLE_USER_OP_TYPED_DATA = {
  PackedUserOperation: [
    { name: "sender", type: "address" },
    { name: "nonce", type: "uint256" },
    { name: "initCode", type: "bytes" },
    { name: "callData", type: "bytes" },
    { name: "accountGasLimits", type: "bytes32" },
    { name: "preVerificationGas", type: "uint256" },
    { name: "gasFees", type: "bytes32" },
    { name: "paymasterAndData", type: "bytes" },
    { name: "entryPoint", type: "address" }
  ]
};
var prepareSignUserOperationTypedData = ({
  userOperation,
  entryPoint,
  chainId,
  name,
  address,
  version = "1"
}) => {
  const packedUserOp = toPackedUserOperation({
    ...userOperation,
    signature: "0x"
  });
  return {
    domain: {
      chainId,
      name,
      version,
      verifyingContract: address
    },
    types: SIGNABLE_USER_OP_TYPED_DATA,
    primaryType: "PackedUserOperation",
    message: { ...packedUserOp, entryPoint: entryPoint.address }
  };
};
var signUserOperation = async ({
  privateKey,
  userOperation,
  entryPoint,
  chainId,
  name,
  address,
  version = "1"
}) => {
  const typedData = prepareSignUserOperationTypedData({
    userOperation,
    entryPoint,
    chainId,
    name,
    address,
    version
  });
  return signTypedData({
    privateKey,
    ...typedData
  });
};

// node_modules/@metamask/delegation-toolkit/dist/chunk-TMYAWDSH.mjs
var actions_exports = {};
__export(actions_exports, {
  caveatEnforcerActions: () => caveatEnforcerActions,
  getErc20PeriodTransferEnforcerAvailableAmount: () => getErc20PeriodTransferEnforcerAvailableAmount,
  getErc20StreamingEnforcerAvailableAmount: () => getErc20StreamingEnforcerAvailableAmount,
  getMultiTokenPeriodEnforcerAvailableAmount: () => getMultiTokenPeriodEnforcerAvailableAmount,
  getNativeTokenPeriodTransferEnforcerAvailableAmount: () => getNativeTokenPeriodTransferEnforcerAvailableAmount,
  getNativeTokenStreamingEnforcerAvailableAmount: () => getNativeTokenStreamingEnforcerAvailableAmount,
  isValid7702Implementation: () => isValid7702Implementation,
  signDelegation: () => signDelegation2,
  signDelegationActions: () => signDelegationActions,
  signUserOperation: () => signUserOperation2,
  signUserOperationActions: () => signUserOperationActions
});
function findMatchingCaveat({
  delegation,
  enforcerAddress,
  enforcerName
}) {
  const matchingCaveats = delegation.caveats.filter(
    (caveat) => caveat.enforcer.toLowerCase() === enforcerAddress.toLowerCase()
  );
  if (matchingCaveats.length === 0) {
    throw new Error(`No caveat found with enforcer matching ${enforcerName}`);
  }
  if (matchingCaveats.length > 1) {
    throw new Error(
      `Multiple caveats found with enforcer matching ${enforcerName}`
    );
  }
  const [{ terms, args }] = matchingCaveats;
  return {
    terms,
    args
  };
}
function getDelegationManager(environment) {
  if (!environment.DelegationManager) {
    throw new Error("Delegation manager address not found");
  }
  return environment.DelegationManager;
}
function getEnforcerAddress({
  enforcerName,
  environment
}) {
  const enforcerAddress = environment.caveatEnforcers[enforcerName];
  if (!enforcerAddress) {
    throw new Error(`${enforcerName} not found in environment`);
  }
  return enforcerAddress;
}
async function getErc20PeriodTransferEnforcerAvailableAmount(client, environment, params) {
  const enforcerName = "ERC20PeriodTransferEnforcer";
  const delegationManager = getDelegationManager(environment);
  const enforcerAddress = getEnforcerAddress({
    enforcerName,
    environment
  });
  const delegationHash = getDelegationHashOffchain(params.delegation);
  const { terms } = findMatchingCaveat({
    delegation: params.delegation,
    enforcerAddress,
    enforcerName
  });
  return read_exports.getAvailableAmount({
    client,
    contractAddress: enforcerAddress,
    delegationHash,
    delegationManager,
    terms
  });
}
async function getErc20StreamingEnforcerAvailableAmount(client, environment, params) {
  const enforcerName = "ERC20StreamingEnforcer";
  const delegationManager = getDelegationManager(environment);
  const enforcerAddress = getEnforcerAddress({
    enforcerName,
    environment
  });
  const delegationHash = getDelegationHashOffchain(params.delegation);
  const { terms } = findMatchingCaveat({
    delegation: params.delegation,
    enforcerAddress,
    enforcerName
  });
  return read_exports2.getAvailableAmount({
    client,
    contractAddress: enforcerAddress,
    delegationManager,
    delegationHash,
    terms
  });
}
async function getMultiTokenPeriodEnforcerAvailableAmount(client, environment, params) {
  const enforcerName = "MultiTokenPeriodEnforcer";
  const delegationManager = getDelegationManager(environment);
  const enforcerAddress = getEnforcerAddress({
    enforcerName,
    environment
  });
  const delegationHash = getDelegationHashOffchain(params.delegation);
  const { terms, args } = findMatchingCaveat({
    delegation: params.delegation,
    enforcerAddress,
    enforcerName
  });
  return read_exports3.getAvailableAmount({
    client,
    contractAddress: enforcerAddress,
    delegationHash,
    delegationManager,
    terms,
    args
  });
}
async function getNativeTokenPeriodTransferEnforcerAvailableAmount(client, environment, params) {
  const enforcerName = "NativeTokenPeriodTransferEnforcer";
  const delegationManager = getDelegationManager(environment);
  const enforcerAddress = getEnforcerAddress({
    enforcerName,
    environment
  });
  const delegationHash = getDelegationHashOffchain(params.delegation);
  const { terms } = findMatchingCaveat({
    delegation: params.delegation,
    enforcerAddress,
    enforcerName
  });
  return read_exports4.getAvailableAmount({
    client,
    contractAddress: enforcerAddress,
    delegationHash,
    delegationManager,
    terms
  });
}
async function getNativeTokenStreamingEnforcerAvailableAmount(client, environment, params) {
  const enforcerName = "NativeTokenStreamingEnforcer";
  const delegationManager = getDelegationManager(environment);
  const enforcerAddress = getEnforcerAddress({
    enforcerName,
    environment
  });
  const delegationHash = getDelegationHashOffchain(params.delegation);
  const { terms } = findMatchingCaveat({
    delegation: params.delegation,
    enforcerAddress,
    enforcerName
  });
  return read_exports5.getAvailableAmount({
    client,
    contractAddress: enforcerAddress,
    delegationManager,
    delegationHash,
    terms
  });
}
var caveatEnforcerActions = ({ environment }) => (client) => ({
  /**
   * Get available amount for ERC20 period transfer enforcer.
   *
   * @param params - The parameters for the ERC20 period transfer enforcer.
   * @returns Promise resolving to the period transfer result.
   */
  getErc20PeriodTransferEnforcerAvailableAmount: async (params) => {
    return getErc20PeriodTransferEnforcerAvailableAmount(
      client,
      environment,
      params
    );
  },
  /**
   * Get available amount for ERC20 streaming enforcer.
   *
   * @param params - The parameters for the ERC20 streaming enforcer.
   * @returns Promise resolving to the streaming result.
   */
  getErc20StreamingEnforcerAvailableAmount: async (params) => {
    return getErc20StreamingEnforcerAvailableAmount(
      client,
      environment,
      params
    );
  },
  /**
   * Get available amount for multi-token period enforcer.
   *
   * @param params - The parameters for the multi-token period enforcer.
   * @returns Promise resolving to the period transfer result.
   */
  getMultiTokenPeriodEnforcerAvailableAmount: async (params) => {
    return getMultiTokenPeriodEnforcerAvailableAmount(
      client,
      environment,
      params
    );
  },
  /**
   * Get available amount for native token period transfer enforcer.
   *
   * @param params - The parameters for the native token period transfer enforcer.
   * @returns Promise resolving to the period transfer result.
   */
  getNativeTokenPeriodTransferEnforcerAvailableAmount: async (params) => {
    return getNativeTokenPeriodTransferEnforcerAvailableAmount(
      client,
      environment,
      params
    );
  },
  /**
   * Get available amount for native token streaming enforcer.
   *
   * @param params - The parameters for the native token streaming enforcer.
   * @returns Promise resolving to the streaming result.
   */
  getNativeTokenStreamingEnforcerAvailableAmount: async (params) => {
    return getNativeTokenStreamingEnforcerAvailableAmount(
      client,
      environment,
      params
    );
  }
});
var DELEGATION_PREFIX = "0xef0100";
function extractDelegatedAddress(code) {
  if (code?.length !== 48) {
    return null;
  }
  if (!code.toLowerCase().startsWith(DELEGATION_PREFIX.toLowerCase())) {
    return null;
  }
  const addressHex = code.slice(8);
  return `0x${addressHex}`;
}
async function isValid7702Implementation({
  client,
  accountAddress,
  environment
}) {
  try {
    const code = await getCode(client, {
      address: accountAddress
    });
    const delegatedAddress = extractDelegatedAddress(code);
    if (!delegatedAddress) {
      return false;
    }
    const expectedImplementation = environment.implementations.EIP7702StatelessDeleGatorImpl;
    if (!expectedImplementation) {
      return false;
    }
    return isAddressEqual(delegatedAddress, expectedImplementation);
  } catch (error) {
    return false;
  }
}
async function signDelegation2(client, parameters) {
  const {
    account: accountParam = client.account,
    delegation,
    delegationManager,
    chainId,
    name = "DelegationManager",
    version = "1",
    allowInsecureUnrestrictedDelegation = false
  } = parameters;
  if (!accountParam) {
    throw new BaseError("Account not found. Please provide an account.");
  }
  const account = parseAccount(accountParam);
  const typedData = prepareSignDelegationTypedData({
    delegation,
    delegationManager,
    chainId,
    name,
    version,
    allowInsecureUnrestrictedDelegation
  });
  return client.signTypedData({
    account,
    ...typedData
  });
}
function signDelegationActions() {
  return (client) => ({
    signDelegation: async (parameters) => signDelegation2(client, {
      chainId: parameters.chainId ?? (() => {
        if (!client.chain?.id) {
          throw new BaseError(
            "Chain ID is required. Either provide it in parameters or configure the client with a chain."
          );
        }
        return client.chain.id;
      })(),
      ...parameters
    })
  });
}
async function signUserOperation2(client, parameters) {
  const {
    account: accountParam = client.account,
    userOperation,
    entryPoint,
    chainId,
    name,
    address,
    version = "1"
  } = parameters;
  if (!accountParam) {
    throw new BaseError("Account not found. Please provide an account.");
  }
  const account = parseAccount(accountParam);
  const typedData = prepareSignUserOperationTypedData({
    userOperation,
    entryPoint,
    chainId,
    name,
    address,
    version
  });
  return client.signTypedData({
    account,
    ...typedData
  });
}
function signUserOperationActions() {
  return (client) => ({
    signUserOperation: async (parameters) => signUserOperation2(client, {
      chainId: parameters.chainId ?? (() => {
        if (!client.chain?.id) {
          throw new BaseError(
            "Chain ID is required. Either provide it in parameters or configure the client with a chain."
          );
        }
        return client.chain.id;
      })(),
      ...parameters
    })
  });
}

// node_modules/webauthn-p256/_esm/utils.js
function bytesToHex2(bytes) {
  return `0x${bytesToHex(bytes)}`;
}
function hexToBytes2(value) {
  return hexToBytes(value.slice(2));
}

// node_modules/webauthn-p256/_esm/credential.js
var createChallenge = Uint8Array.from([
  105,
  171,
  180,
  181,
  160,
  222,
  75,
  198,
  42,
  42,
  32,
  31,
  141,
  37,
  186,
  233
]);

// node_modules/@noble/curves/esm/p256.js
var Fp = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var CURVE_A = Fp.create(BigInt("-3"));
var CURVE_B = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var p256 = createCurve({
  a: CURVE_A,
  // Equation params: a, b
  b: CURVE_B,
  Fp,
  // Field: 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n
  // Curve order, total count of valid points in the field
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  // Base (generator) point (x, y)
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: false
}, sha256);
var secp256r1 = p256;
var mapSWU = (() => mapToCurveSimpleSWU(Fp, {
  A: CURVE_A,
  B: CURVE_B,
  Z: Fp.create(BigInt("-10"))
}))();
var htf = (() => createHasher(secp256r1.ProjectivePoint, (scalars) => mapSWU(scalars[0]), {
  DST: "P256_XMD:SHA-256_SSWU_RO_",
  encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// node_modules/webauthn-p256/_esm/sign.js
function parseSignature(signature) {
  const bytes = typeof signature === "string" ? hexToBytes2(signature) : signature;
  const r = bytes.slice(0, 32);
  const s = bytes.slice(32, 64);
  return {
    r: BigInt(bytesToHex2(r)),
    s: BigInt(bytesToHex2(s))
  };
}

// node_modules/@metamask/delegation-toolkit/dist/chunk-NV2Z25GV.mjs
var Implementation = ((Implementation2) => {
  Implementation2["MultiSig"] = "MultiSig";
  Implementation2["Hybrid"] = "Hybrid";
  Implementation2["Stateless7702"] = "Stateless7702";
  return Implementation2;
})(Implementation || {});
var getCounterfactualAccountData = async ({
  factory,
  implementations,
  implementation,
  deployParams,
  deploySalt
}) => {
  let implementationAddress;
  let initcode;
  switch (implementation) {
    case "Hybrid": {
      const [owner, keyIds, xValues, yValues] = deployParams;
      if (!implementations.HybridDeleGatorImpl) {
        throw new Error(
          "HybridDeleGatorImpl address not provided in environment"
        );
      }
      implementationAddress = implementations.HybridDeleGatorImpl;
      const p256Owners = keyIds.map((keyId, index) => {
        const xValue = xValues[index];
        const yValue = yValues[index];
        if (!xValue || !yValue) {
          throw new Error(
            `Missing X or Y value for keyId ${keyId} at index ${index}`
          );
        }
        return {
          keyId,
          x: xValue,
          y: yValue
        };
      });
      initcode = encode2({ eoaOwner: owner, p256Owners });
      break;
    }
    case "MultiSig": {
      const [owners, threshold] = deployParams;
      if (!implementations.MultiSigDeleGatorImpl) {
        throw new Error(
          "MultiSigDeleGatorImpl address not provided in environment"
        );
      }
      implementationAddress = implementations.MultiSigDeleGatorImpl;
      initcode = encode7({ owners, threshold });
      break;
    }
    default:
      throw new Error(`Implementation type '${implementation}' not supported`);
  }
  const salt = pad(deploySalt, { dir: "left", size: 32 });
  const proxyCreationCode = encodeProxyCreationCode({
    implementationAddress,
    initcode
  });
  const address = getContractAddress({
    bytecode: proxyCreationCode,
    from: factory,
    opcode: "CREATE2",
    salt
  });
  const factoryData = encode14(proxyCreationCode, salt);
  return {
    factoryData,
    address
  };
};
var isDelegatedCall = (call) => {
  return "permissionsContext" in call && "delegationManager" in call;
};
var processDelegatedCall = (call) => {
  const {
    permissionsContext,
    delegationManager,
    to: target,
    value,
    data: callData
  } = call;
  const callAsExecution = createExecution({ target, value, callData });
  if (!permissionsContext) {
    return callAsExecution;
  }
  const redeemCalldata = encodeFunctionData({
    abi: DelegationManager_exports.abi,
    functionName: "redeemDelegations",
    args: [
      [permissionsContext],
      [
        "0x0000000000000000000000000000000000000000000000000000000000000000"
        /* SingleDefault */
      ],
      encodeExecutionCalldatas([[callAsExecution]])
    ]
  });
  return createExecution({
    target: delegationManager,
    callData: redeemCalldata
  });
};
var encodeCalls = (calls) => {
  if (calls.length === 1) {
    const call = calls[0];
    if (call && !isDelegatedCall(call)) {
      const { to: target, value, data: callData } = call;
      const execution = createExecution({ target, value, callData });
      return encode15({ execution });
    }
  }
  const executions = calls.map((call) => {
    if (isDelegatedCall(call)) {
      return processDelegatedCall(call);
    }
    const { to: target, value, data: callData } = call;
    return createExecution({ target, value, callData });
  });
  const mode = calls.length === 1 ? "0x0000000000000000000000000000000000000000000000000000000000000000" : "0x0100000000000000000000000000000000000000000000000000000000000000";
  return encode16({ mode, executions });
};
var encodeCallsForCaller = async (caller, calls) => {
  if (calls.length === 1) {
    const call = calls[0];
    if (call && call.to === caller && !isDelegatedCall(call)) {
      return call.data ?? "0x";
    }
  }
  return encodeCalls(calls);
};
var FIELD_MODULUS = 115792089210356248762697446949407573529996955224135760342422259061068512044369n;
var MALLEABILITY_THRESHOLD = FIELD_MODULUS / 2n;
var SIGNATURE_ABI_PARAMS = parseAbiParameters(
  "bytes32, uint256, uint256, bytes, bool, string, string, uint256"
);
var splitOnChallenge = (clientDataJson) => {
  try {
    const { challenge } = JSON.parse(clientDataJson);
    if (challenge === void 0) {
      throw new Error('No "challenge" found in the input string');
    }
    return clientDataJson.split(challenge);
  } catch (error) {
    throw new Error('No "challenge" found in the input string', {
      cause: error
    });
  }
};
var getResponseTypeLocation = (clientDataJson) => {
  try {
    const typeIndex = clientDataJson.indexOf('"type":');
    if (typeIndex === -1) {
      throw new Error('No "type" found in the input string');
    }
    return BigInt(typeIndex);
  } catch (error) {
    throw new Error('No "type" found in the input string', {
      cause: error
    });
  }
};
function encodeDeleGatorSignature(keyId, signature, clientDataJSON, authenticatorData) {
  const keyIdHash = keccak256(encodePacked(["string"], [keyId]));
  const parsedSignature = parseSignature(signature);
  let { s } = parsedSignature;
  while (s > MALLEABILITY_THRESHOLD) {
    s = FIELD_MODULUS - s;
  }
  const { r } = parsedSignature;
  const [clientDataComponent1, clientDataComponent2] = splitOnChallenge(clientDataJSON);
  const { userVerified } = parseAuthenticatorFlags(authenticatorData);
  const responseTypeLocation = getResponseTypeLocation(clientDataJSON);
  const encodedSignature = encodeAbiParameters(SIGNATURE_ABI_PARAMS, [
    keyIdHash,
    r,
    s,
    authenticatorData,
    userVerified,
    clientDataComponent1,
    clientDataComponent2,
    responseTypeLocation
  ]);
  return encodedSignature;
}
var AUTHENTICATOR_DATA_FLAGS_OFFSET = 32;
function parseAuthenticatorFlags(authenticatorData) {
  const authenticatorDataBuffer = Buffer.from(
    authenticatorData.slice(2),
    "hex"
  );
  const flags = authenticatorDataBuffer.readUInt8(
    AUTHENTICATOR_DATA_FLAGS_OFFSET
  );
  const bitMask = 1 << 2;
  return {
    // eslint-disable-next-line no-bitwise
    userVerified: (flags & bitMask) !== 0
  };
}
var createDummyWebAuthnSignature = (keyId) => {
  const rpIdHash = keccak256(encodePacked(["string"], ["AuthenticatorData"]));
  const flags = "0x05";
  const signCount = "0x00000000";
  const authenticatorData = concat([rpIdHash, flags, signCount]);
  const keyIdHash = keccak256(encodePacked(["string"], [keyId]));
  const rs = 57896044605178124381348723474703786764998477612067880171211129530534256022184n;
  const userVerification = true;
  const clientDataPrefix = '{"type":"webauthn.get","challenge":"';
  const clientDataSuffix = '","origin":"passkey-domain","crossOrigin":false}';
  const responseTypeLocation = 1n;
  const encodedSignature = encodeAbiParameters(SIGNATURE_ABI_PARAMS, [
    keyIdHash,
    rs,
    rs,
    authenticatorData,
    userVerification,
    clientDataPrefix,
    clientDataSuffix,
    responseTypeLocation
  ]);
  return encodedSignature;
};

// node_modules/@metamask/delegation-deployments/dist/index.mjs
var deployments_1_3_0 = {
  DelegationManager: "0xdb9B1e94B5b69Df7e401DDbedE43491141047dB3",
  EntryPoint: "0x0000000071727De22E5E9d8BAf0edAc6f37da032",
  SimpleFactory: "0x69Aa2f9fe1572F1B640E1bbc512f5c3a734fc77c",
  // Implementations
  MultiSigDeleGatorImpl: "0x56a9EdB16a0105eb5a4C54f4C062e2868844f3A7",
  HybridDeleGatorImpl: "0x48dBe696A4D990079e039489bA2053B36E8FFEC4",
  EIP7702StatelessDeleGatorImpl: "0x63c0c19a282a1B52b07dD5a65b58948A07DAE32B",
  // Caveat Enforcers
  AllowedCalldataEnforcer: "0xc2b0d624c1c4319760C96503BA27C347F3260f55",
  AllowedMethodsEnforcer: "0x2c21fD0Cb9DC8445CB3fb0DC5E7Bb0Aca01842B5",
  AllowedTargetsEnforcer: "0x7F20f61b1f09b08D970938F6fa563634d65c4EeB",
  BlockNumberEnforcer: "0x5d9818dF0AE3f66e9c3D0c5029DAF99d1823ca6c",
  DeployedEnforcer: "0x24ff2AA430D53a8CD6788018E902E098083dcCd2",
  ERC20BalanceChangeEnforcer: "0xcdF6aB796408598Cea671d79506d7D48E97a5437",
  ERC20TransferAmountEnforcer: "0xf100b0819427117EcF76Ed94B358B1A5b5C6D2Fc",
  ERC20PeriodTransferEnforcer: "0x474e3Ae7E169e940607cC624Da8A15Eb120139aB",
  ERC20StreamingEnforcer: "0x56c97aE02f233B29fa03502Ecc0457266d9be00e",
  ERC721BalanceChangeEnforcer: "0x8aFdf96eDBbe7e1eD3f5Cd89C7E084841e12A09e",
  ERC721TransferEnforcer: "0x3790e6B7233f779b09DA74C72b6e94813925b9aF",
  ERC1155BalanceChangeEnforcer: "0x63c322732695cAFbbD488Fc6937A0A7B66fC001A",
  ExactCalldataBatchEnforcer: "0x982FD5C86BBF425d7d1451f974192d4525113DfD",
  ExactCalldataEnforcer: "0x99F2e9bF15ce5eC84685604836F71aB835DBBdED",
  ExactExecutionBatchEnforcer: "0x1e141e455d08721Dd5BCDA1BaA6Ea5633Afd5017",
  ExactExecutionEnforcer: "0x146713078D39eCC1F5338309c28405ccf85Abfbb",
  IdEnforcer: "0xC8B5D93463c893401094cc70e66A206fb5987997",
  LimitedCallsEnforcer: "0x04658B29F6b82ed55274221a06Fc97D318E25416",
  NativeBalanceChangeEnforcer: "0xbD7B277507723490Cd50b12EaaFe87C616be6880",
  ArgsEqualityCheckEnforcer: "0x44B8C6ae3C304213c3e298495e12497Ed3E56E41",
  NativeTokenPaymentEnforcer: "0x4803a326ddED6dDBc60e659e5ed12d85c7582811",
  NativeTokenTransferAmountEnforcer: "0xF71af580b9c3078fbc2BBF16FbB8EEd82b330320",
  NativeTokenStreamingEnforcer: "0xD10b97905a320b13a0608f7E9cC506b56747df19",
  NativeTokenPeriodTransferEnforcer: "0x9BC0FAf4Aca5AE429F4c06aEEaC517520CB16BD9",
  NonceEnforcer: "0xDE4f2FAC4B3D87A1d9953Ca5FC09FCa7F366254f",
  OwnershipTransferEnforcer: "0x7EEf9734E7092032B5C56310Eb9BbD1f4A524681",
  RedeemerEnforcer: "0xE144b0b2618071B4E56f746313528a669c7E65c5",
  SpecificActionERC20TransferBatchEnforcer: "0x00e0251aaA263dfE3B3541B758A82D1CBA1c3B6D",
  TimestampEnforcer: "0x1046bb45C8d673d4ea75321280DB34899413c069",
  ValueLteEnforcer: "0x92Bf12322527cAA612fd31a0e810472BBB106A8F",
  MultiTokenPeriodEnforcer: "0xFB2f1a9BD76d3701B730E5d69C3219D42D80eBb7"
};
var deployments_1_1_0 = {
  DelegationManager: "0x56D56e07e3d6Ee5a24e30203A37a0a460f42D7A3",
  EntryPoint: "0x0000000071727De22E5E9d8BAf0edAc6f37da032",
  SimpleFactory: "0x6ff518884f21168c30c58CB21184D6AdBC18Ad90",
  // Implementations
  MultiSigDeleGatorImpl: "0xd1f421EDbA5e3FA9efe3874827114b20C5BEC40C",
  HybridDeleGatorImpl: "0x941f3a016F8726d5643Ce62452d0D78492D42b42",
  // Caveat Enforcers
  AllowedCalldataEnforcer: "0xff71d60f3208469cBCE0859717B5198042DCB3F3",
  AllowedMethodsEnforcer: "0xe32C2561792e8446Abe73B9f557B881C13906186",
  AllowedTargetsEnforcer: "0x06aaE4c67EEA95277c46Bf79b1583d4a01772D22",
  BlockNumberEnforcer: "0x8E470D2Ae278457b42d2405E0B8Cd4BE21Ed9045",
  DeployedEnforcer: "0xf9088f013dBD9ebb7Cebd66fEB48253c6Ac5a820",
  ERC20BalanceGteEnforcer: "0xB7B6f32ec6343261D814e55Ed8C5925d91Cab861",
  ERC20TransferAmountEnforcer: "0x9A069b18032B31429A363AeCFb1B6A0564b44471",
  IdEnforcer: "0x91015c3b9D9523966eD2399885e5Df7A567f916c",
  LimitedCallsEnforcer: "0xe694bFfffEA3E85923b1210b37e6a0175e910863",
  NonceEnforcer: "0xE83BCFD8bBE672A96747e831050a91cf44F4F87A",
  TimestampEnforcer: "0x550FdD13eEBC1f22ea2a2480024BacBF0Ad7e5CE",
  ValueLteEnforcer: "0xBE32a6DB7471F63BB168C088c57Db01AfAe87967",
  NativeTokenTransferAmountEnforcer: "0x5eD3833d7B957A8DB8A461c3AF2d668Ec25382E0",
  NativeBalanceGteEnforcer: "0x376a98860E210DdEda3689fb39565592c563cB0A",
  ArgsEqualityCheckEnforcer: "0x7378dE585998d3E18Ce147867C335C25B3dB8Ee5",
  NativeTokenPaymentEnforcer: "0x87Fe18EbF99e42fcE8A03a25F1d20E119407f8e7",
  RedeemerEnforcer: "0x926672b130D1EF60A9d6b11D2048d121b30f40C1"
};
var deployments_1_0_0 = {
  DelegationManager: "0xbe4138886cb096bdc1b930f2f0ca7892aa234d78",
  EntryPoint: "0x0000000071727De22E5E9d8BAf0edAc6f37da032",
  SimpleFactory: "0x6ff518884f21168c30c58CB21184D6AdBC18Ad90",
  // Implementations
  MultiSigDeleGatorImpl: "0x11f555af5844d85bfcf5d61d2a22866527eb585a",
  HybridDeleGatorImpl: "0xd6edd1256deccb2b06bdecef92dc16bcf26e531b",
  // Caveat Enforcers
  AllowedCalldataEnforcer: "0x48db3835a873d64a4af2c09f014052407c003bd7",
  AllowedMethodsEnforcer: "0xfd731951bf1c52afccee3e6f14ab656475b76dd4",
  AllowedTargetsEnforcer: "0xbc8673c0afa52d86d991c06881e55b2966920564",
  BlockNumberEnforcer: "0xc15faffa0d879b9263c15a46ce31eacfa2e0e8ae",
  DeployedEnforcer: "0x5accb9559b56a6c1e3f90e342c85c42d93720d43",
  ERC20BalanceGteEnforcer: "0xb5d6b1ec6d868a3bae5b7f48178eaa2686a7a087",
  ERC20TransferAmountEnforcer: "0x92ac423b9c111962179a6242e1adb58d02c103be",
  IdEnforcer: "0x34152d9f3f8f74338d50703e780389e829b4abac",
  LimitedCallsEnforcer: "0x4b3adad4a328bee8ba17b86074d92fe7372180cd",
  NonceEnforcer: "0x2f32ff3fc3086d7f63f16fe8d0065390d460b40d",
  TimestampEnforcer: "0x78e05f779490c24bf3bfa135b4112e7003b321cd",
  ValueLteEnforcer: "0xfc20ede0a1132e839fbda9d7ed3904ff3c89540f"
};
var CHAIN_ID = {
  // Mainnets
  mainnet: 1,
  optimism: 10,
  bsc: 56,
  gnosis: 100,
  polygon: 137,
  base: 8453,
  arbitrum: 42161,
  linea: 59144,
  berachain: 80094,
  unichain: 130,
  arbitrumNova: 42170,
  // Testnets
  bscTestnet: 97,
  megaEthTestnet: 6342,
  chiado: 10200,
  lineaSepolia: 59141,
  berachainBepolia: 80069,
  baseSepolia: 84532,
  arbitrumSepolia: 421614,
  sepolia: 11155111,
  optimismSepolia: 11155420,
  unichainSepolia: 1301,
  polygonAmoy: 80002,
  monadTestnet: 10143,
  // decommissioned
  lineaGoerli: 59140
};
var DELEGATOR_CONTRACTS = {
  "1.0.0": {
    // Mainnets
    [CHAIN_ID.optimism]: deployments_1_0_0,
    [CHAIN_ID.polygon]: deployments_1_0_0,
    [CHAIN_ID.base]: deployments_1_0_0,
    [CHAIN_ID.arbitrum]: deployments_1_0_0,
    [CHAIN_ID.linea]: deployments_1_0_0,
    // Testnets
    [CHAIN_ID.sepolia]: {
      ...deployments_1_0_0,
      HybridDeleGatorImpl: "0x5989F5D13DF8fc818EdA65e417AED90459fD67F7"
    },
    [CHAIN_ID.lineaSepolia]: {
      ...deployments_1_0_0,
      HybridDeleGatorImpl: "0x5989F5D13DF8fc818EdA65e417AED90459fD67F7"
    }
  },
  "1.1.0": {
    // Mainnets
    [CHAIN_ID.arbitrum]: deployments_1_1_0,
    [CHAIN_ID.base]: deployments_1_1_0,
    [CHAIN_ID.linea]: deployments_1_1_0,
    [CHAIN_ID.optimism]: deployments_1_1_0,
    [CHAIN_ID.polygon]: deployments_1_1_0,
    // Testnets
    [CHAIN_ID.sepolia]: deployments_1_1_0,
    [CHAIN_ID.lineaSepolia]: deployments_1_1_0,
    [CHAIN_ID.baseSepolia]: {
      ...deployments_1_1_0,
      SimpleFactory: "0xE8eA1DE8D6AfE400B7C8C1A81B7C29B7876b4d02"
    }
  },
  "1.3.0": {
    // Mainnets
    [CHAIN_ID.mainnet]: deployments_1_3_0,
    [CHAIN_ID.polygon]: deployments_1_3_0,
    [CHAIN_ID.bsc]: deployments_1_3_0,
    [CHAIN_ID.optimism]: deployments_1_3_0,
    [CHAIN_ID.arbitrum]: deployments_1_3_0,
    [CHAIN_ID.linea]: deployments_1_3_0,
    [CHAIN_ID.base]: deployments_1_3_0,
    [CHAIN_ID.gnosis]: deployments_1_3_0,
    [CHAIN_ID.berachain]: deployments_1_3_0,
    [CHAIN_ID.unichain]: deployments_1_3_0,
    [CHAIN_ID.arbitrumNova]: deployments_1_3_0,
    // Testnets
    [CHAIN_ID.sepolia]: deployments_1_3_0,
    [CHAIN_ID.lineaSepolia]: deployments_1_3_0,
    [CHAIN_ID.baseSepolia]: deployments_1_3_0,
    [CHAIN_ID.megaEthTestnet]: deployments_1_3_0,
    [CHAIN_ID.chiado]: deployments_1_3_0,
    [CHAIN_ID.bscTestnet]: deployments_1_3_0,
    [CHAIN_ID.optimismSepolia]: deployments_1_3_0,
    [CHAIN_ID.arbitrumSepolia]: deployments_1_3_0,
    [CHAIN_ID.berachainBepolia]: deployments_1_3_0,
    [CHAIN_ID.unichainSepolia]: deployments_1_3_0,
    [CHAIN_ID.polygonAmoy]: deployments_1_3_0,
    [CHAIN_ID.monadTestnet]: deployments_1_3_0
  }
};

// node_modules/@metamask/delegation-toolkit/dist/chunk-QYK4FFGA.mjs
var redeemDelegations = async (walletClient, publicClient, delegationManagerAddress, redemptions) => {
  if (redemptions.length === 0) {
    throw new Error("RedeemDelegations invalid zero redemptions");
  }
  const permissionContexts = [];
  const executionsBatch = [];
  const executionModes = [];
  redemptions.forEach((redemption) => {
    permissionContexts.push(redemption.permissionContext);
    executionsBatch.push(redemption.executions);
    executionModes.push(redemption.mode);
  });
  const encodedPermissionContexts = encodePermissionContexts(permissionContexts);
  const executionCalldatas = encodeExecutionCalldatas(executionsBatch);
  const { request } = await publicClient.simulateContract({
    account: walletClient.account,
    address: delegationManagerAddress,
    abi: DelegationManager_exports.abi,
    functionName: "redeemDelegations",
    args: [encodedPermissionContexts, executionModes, executionCalldatas]
  });
  return await walletClient.writeContract(request);
};
var PREFERRED_VERSION = "1.3.0";
var contractOverrideMap = /* @__PURE__ */ new Map();
var getContractOverrideKey = (chainId, version) => `${version}:${chainId}`;
function getDeleGatorEnvironment(chainId, version = PREFERRED_VERSION) {
  const overrideKey = getContractOverrideKey(chainId, version);
  const overriddenContracts = contractOverrideMap.get(overrideKey);
  if (overriddenContracts) {
    return overriddenContracts;
  }
  const contracts = DELEGATOR_CONTRACTS[version]?.[chainId];
  if (!contracts) {
    throw new Error(
      `No contracts found for version ${version} chain ${chainId}`
    );
  }
  return getDeleGatorEnvironmentV1(contracts);
}
function getDeleGatorEnvironmentV1(contracts) {
  return {
    DelegationManager: contracts.DelegationManager,
    EntryPoint: contracts.EntryPoint,
    SimpleFactory: contracts.SimpleFactory,
    implementations: {
      MultiSigDeleGatorImpl: contracts.MultiSigDeleGatorImpl,
      HybridDeleGatorImpl: contracts.HybridDeleGatorImpl,
      EIP7702StatelessDeleGatorImpl: contracts.EIP7702StatelessDeleGatorImpl
    },
    caveatEnforcers: {
      AllowedCalldataEnforcer: contracts.AllowedCalldataEnforcer,
      AllowedMethodsEnforcer: contracts.AllowedMethodsEnforcer,
      AllowedTargetsEnforcer: contracts.AllowedTargetsEnforcer,
      ArgsEqualityCheckEnforcer: contracts.ArgsEqualityCheckEnforcer,
      BlockNumberEnforcer: contracts.BlockNumberEnforcer,
      DeployedEnforcer: contracts.DeployedEnforcer,
      ERC20BalanceChangeEnforcer: contracts.ERC20BalanceChangeEnforcer,
      ERC20TransferAmountEnforcer: contracts.ERC20TransferAmountEnforcer,
      ERC20StreamingEnforcer: contracts.ERC20StreamingEnforcer,
      ERC721BalanceChangeEnforcer: contracts.ERC721BalanceChangeEnforcer,
      ERC721TransferEnforcer: contracts.ERC721TransferEnforcer,
      ERC1155BalanceChangeEnforcer: contracts.ERC1155BalanceChangeEnforcer,
      IdEnforcer: contracts.IdEnforcer,
      LimitedCallsEnforcer: contracts.LimitedCallsEnforcer,
      NonceEnforcer: contracts.NonceEnforcer,
      TimestampEnforcer: contracts.TimestampEnforcer,
      ValueLteEnforcer: contracts.ValueLteEnforcer,
      NativeTokenTransferAmountEnforcer: contracts.NativeTokenTransferAmountEnforcer,
      NativeBalanceChangeEnforcer: contracts.NativeBalanceChangeEnforcer,
      NativeTokenStreamingEnforcer: contracts.NativeTokenStreamingEnforcer,
      NativeTokenPaymentEnforcer: contracts.NativeTokenPaymentEnforcer,
      OwnershipTransferEnforcer: contracts.OwnershipTransferEnforcer,
      RedeemerEnforcer: contracts.RedeemerEnforcer,
      SpecificActionERC20TransferBatchEnforcer: contracts.SpecificActionERC20TransferBatchEnforcer,
      ERC20PeriodTransferEnforcer: contracts.ERC20PeriodTransferEnforcer,
      NativeTokenPeriodTransferEnforcer: contracts.NativeTokenPeriodTransferEnforcer,
      ExactCalldataBatchEnforcer: contracts.ExactCalldataBatchEnforcer,
      ExactCalldataEnforcer: contracts.ExactCalldataEnforcer,
      ExactExecutionEnforcer: contracts.ExactExecutionEnforcer,
      ExactExecutionBatchEnforcer: contracts.ExactExecutionBatchEnforcer,
      MultiTokenPeriodEnforcer: contracts.MultiTokenPeriodEnforcer
    }
  };
}

// node_modules/@metamask/delegation-toolkit/dist/index.mjs
var signatureTypes = ["ECDSA"];
var aggregateSignature = ({
  signatures
}) => {
  if (signatures.length === 0) {
    return "0x";
  }
  for (const { type } of signatures) {
    if (!signatureTypes.includes(type)) {
      throw new Error(`Invalid signature type: ${type}`);
    }
  }
  const sortedSignatures = [...signatures].sort(
    (a, b) => a.signer.localeCompare(b.signer)
  );
  return concat(sortedSignatures.map(({ signature }) => signature));
};
var EOA_STUB_SIGNATURE = "0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000011b";
var resolveSignerFromWalletConfig = (config) => {
  return {
    signMessage: config.walletClient.signMessage,
    signTypedData: async (typedData) => {
      return config.walletClient.signTypedData(typedData);
    },
    getStubSignature: async () => EOA_STUB_SIGNATURE
  };
};
var resolveSignerFromAccountConfig = (config) => {
  return {
    signMessage: config.account.signMessage,
    signTypedData: config.account.signTypedData,
    getStubSignature: async () => EOA_STUB_SIGNATURE
  };
};
var resolveHybridSigner = (config) => {
  if ("walletClient" in config) {
    return resolveSignerFromWalletConfig(config);
  } else if ("account" in config) {
    const { signMessage: signMessage2, signTypedData: signTypedData22, getStubSignature: getStubSignature2 } = resolveSignerFromAccountConfig(config);
    if (!signMessage2) {
      throw new Error("Account does not support signMessage");
    }
    if (!signTypedData22) {
      throw new Error("Account does not support signTypedData");
    }
    return {
      signMessage: signMessage2,
      signTypedData: signTypedData22,
      getStubSignature: getStubSignature2
    };
  }
  const { keyId, webAuthnAccount } = config;
  if (webAuthnAccount.type !== "webAuthn") {
    throw new Error("Account is not a webAuthn account");
  }
  const encodeSignature = ({ signature, webauthn }) => encodeDeleGatorSignature(
    keyId,
    signature,
    webauthn.clientDataJSON,
    webauthn.authenticatorData
  );
  const signMessage = async (args) => webAuthnAccount.signMessage(args).then(encodeSignature);
  const signTypedData2 = async (typedDataDefinition) => webAuthnAccount.signTypedData(typedDataDefinition).then(encodeSignature);
  const getStubSignature = async () => createDummyWebAuthnSignature(keyId);
  return {
    signMessage,
    signTypedData: signTypedData2,
    getStubSignature
  };
};
var resolveMultiSigSigner = (config) => {
  const resolvedSigners = config.map((signer) => {
    let individualSignMessage;
    let individualSignTypedData;
    let address;
    if ("walletClient" in signer) {
      const { signMessage: signMessage2, signTypedData: signTypedData22 } = resolveSignerFromWalletConfig(signer);
      individualSignMessage = signMessage2;
      individualSignTypedData = signTypedData22;
      address = signer.walletClient.account.address;
    } else {
      const { signMessage: signMessage2, signTypedData: signTypedData22 } = resolveSignerFromAccountConfig(signer);
      if (!signMessage2) {
        throw new Error("Account does not support signMessage");
      }
      if (!signTypedData22) {
        throw new Error("Account does not support signTypedData");
      }
      individualSignMessage = signMessage2;
      individualSignTypedData = signTypedData22;
      address = signer.account.address;
    }
    return {
      address,
      individualSignMessage,
      individualSignTypedData
    };
  });
  const signMessage = async (args) => {
    const addressAndSignatures = resolvedSigners.map(
      async ({ individualSignMessage, address }) => ({
        signature: await individualSignMessage(args),
        signer: address,
        type: "ECDSA"
      })
    );
    const signatures = await Promise.all(addressAndSignatures);
    return aggregateSignature({
      signatures
    });
  };
  const signTypedData2 = async (typedDataDefinition) => {
    const addressAndSignatures = resolvedSigners.map(
      async ({ individualSignTypedData, address }) => ({
        signature: await individualSignTypedData(typedDataDefinition),
        signer: address,
        type: "ECDSA"
      })
    );
    const signatures = await Promise.all(addressAndSignatures);
    return aggregateSignature({
      signatures
    });
  };
  const getStubSignature = async () => concat(resolvedSigners.map(() => EOA_STUB_SIGNATURE));
  return {
    signMessage,
    signTypedData: signTypedData2,
    getStubSignature
  };
};
var resolveStateless7702Signer = (config) => {
  if ("walletClient" in config) {
    return resolveSignerFromWalletConfig(config);
  } else if ("account" in config) {
    const { signMessage, signTypedData: signTypedData2, getStubSignature } = resolveSignerFromAccountConfig(config);
    if (!signMessage) {
      throw new Error("Account does not support signMessage");
    }
    if (!signTypedData2) {
      throw new Error("Account does not support signTypedData");
    }
    return {
      signMessage,
      signTypedData: signTypedData2,
      getStubSignature
    };
  }
  throw new Error("Invalid signer config");
};
var resolveSigner = (config) => {
  const { implementation } = config;
  if (implementation === "Hybrid") {
    return resolveHybridSigner(config.signer);
  } else if (implementation === "MultiSig") {
    return resolveMultiSigSigner(config.signer);
  } else if (implementation === "Stateless7702") {
    return resolveStateless7702Signer(
      config.signer
    );
  }
  throw new Error(`Implementation type '${implementation}' not supported`);
};
var ENTRYPOINT_VERSION = "0.7";
async function toMetaMaskSmartAccount(params) {
  const {
    client,
    client: { chain },
    implementation
  } = params;
  if (!chain) {
    throw new Error("Chain not specified");
  }
  const signer = resolveSigner({
    implementation,
    signer: params.signer
  });
  const environment = params.environment ?? getDeleGatorEnvironment(chain.id);
  let address, factoryData;
  if (params.address) {
    factoryData = void 0;
    address = params.address;
  } else {
    if (implementation === "Stateless7702") {
      throw new Error("Stateless7702 does not support counterfactual accounts");
    }
    const accountData = await getCounterfactualAccountData({
      factory: environment.SimpleFactory,
      implementations: environment.implementations,
      implementation,
      deployParams: params.deployParams,
      deploySalt: params.deploySalt
    });
    address = accountData.address;
    factoryData = accountData.factoryData;
  }
  const entryPoint = {
    abi: entryPoint07Abi,
    address: environment.EntryPoint,
    version: ENTRYPOINT_VERSION
  };
  const { abi, contractName } = {
    [
      "Hybrid"
      /* Hybrid */
    ]: {
      contractName: "HybridDeleGator",
      abi: HybridDeleGator_exports.abi
    },
    [
      "MultiSig"
      /* MultiSig */
    ]: {
      contractName: "MultiSigDeleGator",
      abi: MultiSigDeleGator_exports.abi
    },
    [
      "Stateless7702"
      /* Stateless7702 */
    ]: {
      contractName: "EIP7702StatelessDeleGator",
      abi: EIP7702StatelessDeleGator_exports.abi
    }
  }[implementation];
  const getFactoryArgs = async () => {
    if (factoryData === void 0) {
      throw new Error(
        "Deploy params were not provided, so factory args cannot be inferred"
      );
    }
    return {
      factoryData,
      factory: environment.SimpleFactory
    };
  };
  const signDelegation22 = async (delegationParams) => {
    const { delegation, chainId } = delegationParams;
    const delegationStruct = toDelegationStruct({
      ...delegation,
      signature: "0x"
    });
    const signature = signer.signTypedData({
      domain: {
        chainId: chainId ?? chain.id,
        name: "DelegationManager",
        version: "1",
        verifyingContract: environment.DelegationManager
      },
      types: SIGNABLE_DELEGATION_TYPED_DATA,
      primaryType: "Delegation",
      message: delegationStruct
    });
    return signature;
  };
  const signUserOperation22 = async (userOpParams) => {
    const { chainId } = userOpParams;
    const packedUserOp = toPackedUserOperation({
      sender: address,
      ...userOpParams,
      signature: "0x"
    });
    const signature = await signer.signTypedData({
      domain: {
        chainId: chainId ?? chain.id,
        name: contractName,
        version: "1",
        verifyingContract: address
      },
      types: SIGNABLE_USER_OP_TYPED_DATA,
      primaryType: "PackedUserOperation",
      message: { ...packedUserOp, entryPoint: entryPoint.address }
    });
    return signature;
  };
  const getAddress = async () => address;
  const getNonce = async () => read7({
    client,
    entryPoint: environment.EntryPoint,
    contractAddress: address,
    key: 0n
  });
  const encodeCalls2 = async (calls) => encodeCallsForCaller(address, calls);
  const smartAccount = await toSmartAccount({
    abi,
    client,
    entryPoint,
    environment,
    getAddress,
    getFactoryArgs,
    encodeCalls: encodeCalls2,
    getNonce,
    signUserOperation: signUserOperation22,
    signDelegation: signDelegation22,
    ...signer
  });
  if (implementation === "Stateless7702") {
    return {
      ...smartAccount,
      isDeployed: async () => isValid7702Implementation({
        client,
        accountAddress: address,
        environment
      })
    };
  }
  return smartAccount;
}
function createCaveatEnforcerClient({
  client,
  environment
}) {
  return client.extend(caveatEnforcerActions({ environment }));
}
var infuraBundlerActions = () => (client) => ({
  /**
   * Get user operation gas prices from Infura bundler.
   * Calls the pimlico_getUserOperationGasPrice RPC method.
   *
   * @returns Promise resolving to gas price tiers (slow, standard, fast).
   * @example
   * ```typescript
   * const gasPrices = await bundlerClient.getUserOperationGasPrice();
   * console.log(gasPrices.standard.maxFeePerGas);
   * ```
   */
  async getUserOperationGasPrice() {
    const pimlicoClient = client;
    return await pimlicoClient.request({
      method: "pimlico_getUserOperationGasPrice",
      params: []
    });
  }
});
function createInfuraBundlerClient(config) {
  const baseBundlerClient = createBundlerClient(config);
  return baseBundlerClient.extend(
    infuraBundlerActions()
  );
}
export {
  ANY_BENEFICIARY,
  BalanceChangeType,
  ExecutionMode,
  Implementation,
  PREFERRED_VERSION,
  ROOT_AUTHORITY,
  actions_exports as actions,
  aggregateSignature,
  contracts_exports as contracts,
  createCaveat,
  createCaveatEnforcerClient,
  createDelegation,
  createExecution,
  createInfuraBundlerClient,
  createOpenDelegation,
  getDeleGatorEnvironment,
  redeemDelegations,
  signDelegation,
  signUserOperation,
  toMetaMaskSmartAccount
};
/*! Bundled license information:

@noble/curves/esm/p256.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@metamask_delegation-toolkit.js.map
