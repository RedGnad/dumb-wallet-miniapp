{
  "version": 3,
  "sources": ["../../@metamask/delegation-toolkit/src/userOp.ts", "../../@metamask/delegation-toolkit/src/actions/index.ts", "../../@metamask/delegation-toolkit/src/actions/getCaveatAvailableAmount.ts", "../../@metamask/delegation-toolkit/src/actions/isValid7702Implementation.ts", "../../@metamask/delegation-toolkit/src/actions/signDelegation.ts", "../../@metamask/delegation-toolkit/src/actions/signUserOperation.ts", "../../webauthn-p256/utils.ts", "../../webauthn-p256/credential.ts", "../../@noble/curves/src/p256.ts", "../../webauthn-p256/sign.ts", "../../@metamask/delegation-toolkit/src/constants.ts", "../../@metamask/delegation-toolkit/src/counterfactualAccountData.ts", "../../@metamask/delegation-toolkit/src/encodeCalls.ts", "../../@metamask/delegation-toolkit/src/webAuthn.ts", "../../@metamask/delegation-deployments/src/contractAddresses.ts", "../../@metamask/delegation-deployments/src/index.ts", "../../@metamask/delegation-toolkit/src/write.ts", "../../@metamask/delegation-toolkit/src/delegatorEnvironment.ts", "../../@metamask/delegation-toolkit/src/toMetaMaskSmartAccount.ts", "../../@metamask/delegation-toolkit/src/signer.ts", "../../@metamask/delegation-toolkit/src/signatures.ts", "../../@metamask/delegation-toolkit/src/actions/caveatEnforcerClient.ts", "../../@metamask/delegation-toolkit/src/actions/infuraBundlerClient.ts"],
  "sourcesContent": ["import { concat, encodeAbiParameters, keccak256, pad, toHex } from 'viem';\nimport type { Address, Hex, TypedData } from 'viem';\nimport { toPackedUserOperation } from 'viem/account-abstraction';\nimport { signTypedData } from 'viem/accounts';\n\nimport type { OptionalUserOpProps, PackedUserOperationStruct } from './types';\n\n// v7 off-chain user operation, hexlified incoming data from rpc call\nexport type UserOperationV07Hexlify = {\n  sender: Hex;\n  nonce: Hex;\n  factory?: Hex;\n  factoryData?: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n\n  paymaster?: Hex;\n  paymasterVerificationGasLimit?: Hex;\n  paymasterPostOpGasLimit?: Hex;\n  paymasterData?: Hex;\n\n  signature: Hex;\n};\n\n// v7 off-chain user operation with BigInt fields\nexport type UserOperationV07 = {\n  sender: Hex;\n  nonce: bigint;\n  factory?: Hex;\n  factoryData?: Hex;\n  callData: Hex;\n\n  callGasLimit: bigint;\n  verificationGasLimit: bigint;\n  preVerificationGas: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n\n  paymaster?: Hex;\n  paymasterVerificationGasLimit?: bigint;\n  paymasterPostOpGasLimit?: bigint;\n  paymasterData?: Hex;\n\n  signature: Hex;\n};\n\n/**\n * Creates a raw user operation data structure.\n * @param sender - The smart account taking some action.\n * @param nonce - A nonce, ideally fetched from the Entry Point.\n * @param callData - Calldata to invoke on some contract.\n * @param signature - The signature for the user operation.\n * @param options - Optional properties for the user operation.\n * @returns The created raw user operation data structure.\n */\nexport const createRawUserOp = (\n  sender: Hex,\n  nonce: bigint,\n  callData: Hex,\n  signature: Hex = '0x',\n  options?: OptionalUserOpProps,\n): UserOperationV07 => ({\n  sender,\n  nonce,\n  callData,\n  factory: options?.factory,\n  factoryData: options?.factoryData,\n  callGasLimit: options?.callGasLimit ?? 0n,\n  verificationGasLimit: options?.verificationGasLimit ?? 0n,\n  preVerificationGas: options?.preVerificationGas ?? 0n,\n  maxFeePerGas: options?.maxFeePerGas ?? 0n,\n  maxPriorityFeePerGas: options?.maxPriorityFeePerGas ?? 0n,\n  paymaster: options?.paymaster,\n  paymasterVerificationGasLimit: options?.paymasterVerificationGasLimit,\n  paymasterPostOpGasLimit: options?.paymasterPostOpGasLimit,\n  paymasterData: options?.paymasterData,\n  signature,\n});\n\n// //////////////////////////////////////////////////////////////////////////////////////\n\n// TODO: These userOp functions are duplicated in ./apps/ew-client/src/utils/userOpBuilder.ts. We should move them to a shared location along with test(./apps/ew-client/test/UserOpBuilder.test.ts) to avoid duplication\n/**\n * Generates a salt value for address derivation.\n * @param salt - Optional salt value.\n * @returns The chosen salt value.\n */\nexport const getSalt = (salt?: Hex): Hex => {\n  return salt ?? '0x0';\n};\n\nexport const getPaymasterAndData = (userOp: UserOperationV07): Hex => {\n  let paymasterAndData: Hex;\n  if (userOp.paymaster) {\n    paymasterAndData = concat([\n      userOp.paymaster,\n      pad(toHex(userOp.paymasterVerificationGasLimit ?? 0n), {\n        size: 16,\n      }),\n      pad(toHex(userOp.paymasterPostOpGasLimit ?? 0n), {\n        size: 16,\n      }),\n      userOp.paymasterData ?? '0x',\n    ]);\n  } else {\n    paymasterAndData = '0x';\n  }\n\n  return paymasterAndData;\n};\n\nexport const getInitCode = (userOp: UserOperationV07): Hex => {\n  return userOp.factory\n    ? concat([userOp.factory, userOp.factoryData ?? ('0x' as Hex)])\n    : '0x';\n};\n\nexport const getAccountGasLimits = (userOp: UserOperationV07): Hex => {\n  return concat([\n    pad(toHex(userOp.verificationGasLimit), {\n      size: 16,\n    }),\n    pad(toHex(userOp.callGasLimit), { size: 16 }),\n  ]);\n};\n\nexport const getGasFees = (userOp: UserOperationV07): Hex => {\n  return concat([\n    pad(toHex(userOp.maxPriorityFeePerGas), {\n      size: 16,\n    }),\n    pad(toHex(userOp.maxFeePerGas), { size: 16 }),\n  ]);\n};\n\n/**\n * Packs a user operation into a `PackedUserOperationStruct` object.\n *\n * @param userOp - The user operation to pack.\n * @returns The packed user operation.\n */\nexport const packUserOp = (\n  userOp: UserOperationV07,\n): PackedUserOperationStruct => {\n  const packedOp = {\n    sender: userOp.sender,\n    nonce: BigInt(userOp.nonce),\n    initCode: getInitCode(userOp),\n    callData: userOp.callData,\n    accountGasLimits: getAccountGasLimits(userOp),\n    preVerificationGas: BigInt(userOp.preVerificationGas),\n    gasFees: getGasFees(userOp),\n    paymasterAndData: getPaymasterAndData(userOp),\n    signature: userOp.signature,\n  };\n\n  return packedOp;\n};\n\n/**\n * Calculates the user operation hash for a given packed user operation.\n * @param packedOp - The packed user operation.\n * @param entryPoint - The entry point address.\n * @param chainId - The chain ID.\n * @returns The user operation hash.\n */\nexport const createUserOpHashV07 = (\n  packedOp: PackedUserOperationStruct,\n  entryPoint: Hex,\n  chainId: bigint,\n) => {\n  const hash = keccak256(\n    encodeAbiParameters(\n      [\n        {\n          name: 'sender',\n          type: 'address',\n        },\n        {\n          name: 'nonce',\n          type: 'uint256',\n        },\n        {\n          name: 'initCodeHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'callDataHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'accountGasLimits',\n          type: 'bytes32',\n        },\n        {\n          name: 'preVerificationGas',\n          type: 'uint256',\n        },\n        {\n          name: 'gasFees',\n          type: 'bytes32',\n        },\n        {\n          name: 'paymasterAndDataHash',\n          type: 'bytes32',\n        },\n      ],\n      [\n        packedOp.sender,\n        packedOp.nonce,\n        keccak256(packedOp.initCode),\n        keccak256(packedOp.callData),\n        packedOp.accountGasLimits,\n        packedOp.preVerificationGas,\n        packedOp.gasFees,\n        keccak256(packedOp.paymasterAndData),\n      ],\n    ),\n  );\n\n  return keccak256(\n    encodeAbiParameters(\n      [\n        {\n          name: 'userOpHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'entryPointAddress',\n          type: 'address',\n        },\n        {\n          name: 'chainId',\n          type: 'uint256',\n        },\n      ],\n      [hash, entryPoint, chainId],\n    ),\n  );\n};\n\nexport const SIGNABLE_USER_OP_TYPED_DATA: TypedData = {\n  PackedUserOperation: [\n    { name: 'sender', type: 'address' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'initCode', type: 'bytes' },\n    { name: 'callData', type: 'bytes' },\n    { name: 'accountGasLimits', type: 'bytes32' },\n    { name: 'preVerificationGas', type: 'uint256' },\n    { name: 'gasFees', type: 'bytes32' },\n    { name: 'paymasterAndData', type: 'bytes' },\n    { name: 'entryPoint', type: 'address' },\n  ],\n} as const;\n\n/**\n * Prepares typed data for user operation signing.\n * This is an internal helper function that's not exposed in the public API.\n *\n * @param params - The parameters for preparing the typed data.\n * @param params.userOperation - The user operation to prepare for signing.\n * @param params.entryPoint - The entry point contract address.\n * @param params.entryPoint.address - The address of the entry point contract.\n * @param params.chainId - The chain ID that the entry point is deployed on.\n * @param params.name - The name of the domain of the implementation contract.\n * @param params.version - The version of the domain of the implementation contract.\n * @param params.address - The address of the smart account.\n * @returns The prepared typed data for signing.\n */\nexport const prepareSignUserOperationTypedData = ({\n  userOperation,\n  entryPoint,\n  chainId,\n  name,\n  address,\n  version = '1',\n}: {\n  userOperation: Omit<UserOperationV07, 'signature'>;\n  entryPoint: { address: Address };\n  chainId: number;\n  name: 'HybridDeleGator' | 'MultiSigDeleGator';\n  address: Address;\n  version?: string;\n}) => {\n  const packedUserOp = toPackedUserOperation({\n    ...userOperation,\n    signature: '0x',\n  });\n\n  return {\n    domain: {\n      chainId,\n      name,\n      version,\n      verifyingContract: address,\n    },\n    types: SIGNABLE_USER_OP_TYPED_DATA,\n    primaryType: 'PackedUserOperation' as const,\n    message: { ...packedUserOp, entryPoint: entryPoint.address },\n  };\n};\n\n/**\n * Signs a user operation using a private key.\n * @param params - The parameters for signing the user operation.\n * @param params.privateKey - The private key to use for signing.\n * @param params.userOperation - The user operation to sign.\n * @param params.entryPoint - The entry point contract address.\n * @param params.chainId - The chain ID that the entry point is deployed on.\n * @param params.name - The name of the domain of the implementation contract.\n * @param params.version - The version of the domain of the implementation contract.\n * @param params.address - The address of the smart account.\n * @param params.entryPoint.address - The address of the entry point contract.\n * @returns The signature of the user operation.\n */\nexport const signUserOperation = async ({\n  privateKey,\n  userOperation,\n  entryPoint,\n  chainId,\n  name,\n  address,\n  version = '1',\n}: {\n  privateKey: Hex;\n  userOperation: Omit<UserOperationV07, 'signature'>;\n  entryPoint: { address: Address };\n  chainId: number;\n  address: Address;\n  name: 'HybridDeleGator' | 'MultiSigDeleGator';\n  version?: string;\n}) => {\n  const typedData = prepareSignUserOperationTypedData({\n    userOperation,\n    entryPoint,\n    chainId,\n    name,\n    address,\n    version,\n  });\n\n  return signTypedData({\n    privateKey,\n    ...typedData,\n  });\n};\n", "/* eslint-disable */\n// experimental actions will be moved here once they have stabilized\n\nexport {\n  // Individual action functions\n  getErc20PeriodTransferEnforcerAvailableAmount,\n  getErc20StreamingEnforcerAvailableAmount,\n  getMultiTokenPeriodEnforcerAvailableAmount,\n  getNativeTokenPeriodTransferEnforcerAvailableAmount,\n  getNativeTokenStreamingEnforcerAvailableAmount,\n  // Action builder\n  caveatEnforcerActions,\n  // Parameter types\n  type CaveatEnforcerParams,\n  // Result types\n  type PeriodTransferResult,\n  type StreamingResult,\n} from './getCaveatAvailableAmount';\n\nexport { isValid7702Implementation } from './isValid7702Implementation';\n\n// Signing actions\nexport {\n  signDelegation,\n  signDelegationActions,\n  type SignDelegationParameters,\n  type SignDelegationReturnType,\n} from './signDelegation';\n\nexport {\n  signUserOperation,\n  signUserOperationActions,\n  type SignUserOperationParameters,\n  type SignUserOperationReturnType,\n} from './signUserOperation';\n", "import type { Address, Hex, Client } from 'viem';\n\nimport { getDelegationHashOffchain } from '../delegation';\nimport * as ERC20PeriodTransferEnforcer from '../DelegationFramework/ERC20PeriodTransferEnforcer';\nimport * as ERC20StreamingEnforcer from '../DelegationFramework/ERC20StreamingEnforcer';\nimport * as MultiTokenPeriodEnforcer from '../DelegationFramework/MultiTokenPeriodEnforcer';\nimport * as NativeTokenPeriodTransferEnforcer from '../DelegationFramework/NativeTokenPeriodTransferEnforcer';\nimport * as NativeTokenStreamingEnforcer from '../DelegationFramework/NativeTokenStreamingEnforcer';\nimport type { DeleGatorEnvironment, Delegation } from '../types';\n\n/**\n * Parameters for all caveat enforcer actions.\n */\nexport type CaveatEnforcerParams = {\n  delegation: Delegation;\n};\n\n/**\n * Return type for period-based transfer enforcers\n */\nexport type PeriodTransferResult = {\n  availableAmount: bigint;\n  isNewPeriod: boolean;\n  currentPeriod: bigint;\n};\n\n/**\n * Return type for streaming enforcers\n */\nexport type StreamingResult = {\n  availableAmount: bigint;\n};\n\n/**\n * Finds a caveat that matches the specified enforcer address.\n * @param config - The configuration object.\n * @param config.delegation - The delegation to search.\n * @param config.enforcerAddress - The enforcer address to match.\n * @param config.enforcerName - The name of the enforcer.\n * @returns The matching caveat.\n * @throws Error if no matching caveat is found.\n * @throws Error if multiple matching caveats are found.\n */\nfunction findMatchingCaveat({\n  delegation,\n  enforcerAddress,\n  enforcerName,\n}: {\n  delegation: Delegation;\n  enforcerAddress: Address;\n  enforcerName: keyof DeleGatorEnvironment['caveatEnforcers'];\n}): { terms: Hex; args: Hex } {\n  const matchingCaveats = delegation.caveats.filter(\n    (caveat) => caveat.enforcer.toLowerCase() === enforcerAddress.toLowerCase(),\n  );\n\n  if (matchingCaveats.length === 0) {\n    throw new Error(`No caveat found with enforcer matching ${enforcerName}`);\n  }\n\n  if (matchingCaveats.length > 1) {\n    throw new Error(\n      `Multiple caveats found with enforcer matching ${enforcerName}`,\n    );\n  }\n\n  const [{ terms, args }] = matchingCaveats as unknown as [\n    { terms: Hex; args: Hex },\n  ];\n\n  return {\n    terms,\n    args,\n  };\n}\n\n/**\n * Gets the delegation manager address from environment.\n *\n * @param environment - The delegator environment.\n * @returns The delegation manager address.\n */\nfunction getDelegationManager(environment: DeleGatorEnvironment): Address {\n  if (!environment.DelegationManager) {\n    throw new Error('Delegation manager address not found');\n  }\n\n  return environment.DelegationManager;\n}\n\n/**\n * Gets the enforcer address from environment.\n *\n * @param config - The configuration object.\n * @param config.enforcerName - The name of the enforcer.\n * @param config.environment - The delegator environment.\n * @returns The enforcer address.\n */\nfunction getEnforcerAddress({\n  enforcerName,\n  environment,\n}: {\n  enforcerName: keyof DeleGatorEnvironment['caveatEnforcers'];\n  environment: DeleGatorEnvironment;\n}): Address {\n  const enforcerAddress = environment.caveatEnforcers[enforcerName];\n  if (!enforcerAddress) {\n    throw new Error(`${enforcerName} not found in environment`);\n  }\n\n  return enforcerAddress;\n}\n\n/**\n * Get available amount for ERC20 period transfer enforcer.\n *\n * @param client - The viem client.\n * @param environment - The delegator environment.\n * @param params - The parameters for the ERC20 period transfer enforcer.\n * @returns Promise resolving to the period transfer result.\n */\nexport async function getErc20PeriodTransferEnforcerAvailableAmount(\n  client: Client,\n  environment: DeleGatorEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<PeriodTransferResult> {\n  const enforcerName = 'ERC20PeriodTransferEnforcer';\n\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return ERC20PeriodTransferEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationHash,\n    delegationManager,\n    terms,\n  });\n}\n\n/**\n * Get available amount for ERC20 streaming enforcer.\n *\n * @param client - The viem client.\n * @param environment - The delegator environment.\n * @param params - The parameters for the ERC20 streaming enforcer.\n * @returns Promise resolving to the streaming result.\n */\nexport async function getErc20StreamingEnforcerAvailableAmount(\n  client: Client,\n  environment: DeleGatorEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<StreamingResult> {\n  const enforcerName = 'ERC20StreamingEnforcer';\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return ERC20StreamingEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationManager,\n    delegationHash,\n    terms,\n  });\n}\n\n/**\n * Get available amount for multi-token period enforcer.\n *\n * @param client - The viem client.\n * @param environment - The delegator environment.\n * @param params - The parameters for the multi-token period enforcer.\n * @returns Promise resolving to the period transfer result.\n */\nexport async function getMultiTokenPeriodEnforcerAvailableAmount(\n  client: Client,\n  environment: DeleGatorEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<PeriodTransferResult> {\n  const enforcerName = 'MultiTokenPeriodEnforcer';\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms, args } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return MultiTokenPeriodEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationHash,\n    delegationManager,\n    terms,\n    args,\n  });\n}\n\n/**\n * Get available amount for native token period transfer enforcer.\n *\n * @param client - The viem client.\n * @param environment - The delegator environment.\n * @param params - The parameters for the native token period transfer enforcer.\n * @returns Promise resolving to the period transfer result.\n */\nexport async function getNativeTokenPeriodTransferEnforcerAvailableAmount(\n  client: Client,\n  environment: DeleGatorEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<PeriodTransferResult> {\n  const enforcerName = 'NativeTokenPeriodTransferEnforcer';\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return NativeTokenPeriodTransferEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationHash,\n    delegationManager,\n    terms,\n  });\n}\n\n/**\n * Get available amount for native token streaming enforcer.\n *\n * @param client - The viem client.\n * @param environment - The delegator environment.\n * @param params - The parameters for the native token streaming enforcer.\n * @returns Promise resolving to the streaming result.\n */\nexport async function getNativeTokenStreamingEnforcerAvailableAmount(\n  client: Client,\n  environment: DeleGatorEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<StreamingResult> {\n  const enforcerName = 'NativeTokenStreamingEnforcer';\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return NativeTokenStreamingEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationManager,\n    delegationHash,\n    terms,\n  });\n}\n\n/**\n * Caveat enforcer actions for extending viem clients.\n *\n * @param params - The parameters object.\n * @param params.environment - The delegator environment.\n * @returns A function that takes a client and returns the client extension with caveat enforcer actions.\n */\nexport const caveatEnforcerActions =\n  ({ environment }: { environment: DeleGatorEnvironment }) =>\n  (client: Client) => ({\n    /**\n     * Get available amount for ERC20 period transfer enforcer.\n     *\n     * @param params - The parameters for the ERC20 period transfer enforcer.\n     * @returns Promise resolving to the period transfer result.\n     */\n    getErc20PeriodTransferEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<PeriodTransferResult> => {\n      return getErc20PeriodTransferEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n\n    /**\n     * Get available amount for ERC20 streaming enforcer.\n     *\n     * @param params - The parameters for the ERC20 streaming enforcer.\n     * @returns Promise resolving to the streaming result.\n     */\n    getErc20StreamingEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<StreamingResult> => {\n      return getErc20StreamingEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n\n    /**\n     * Get available amount for multi-token period enforcer.\n     *\n     * @param params - The parameters for the multi-token period enforcer.\n     * @returns Promise resolving to the period transfer result.\n     */\n    getMultiTokenPeriodEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<PeriodTransferResult> => {\n      return getMultiTokenPeriodEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n\n    /**\n     * Get available amount for native token period transfer enforcer.\n     *\n     * @param params - The parameters for the native token period transfer enforcer.\n     * @returns Promise resolving to the period transfer result.\n     */\n    getNativeTokenPeriodTransferEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<PeriodTransferResult> => {\n      return getNativeTokenPeriodTransferEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n\n    /**\n     * Get available amount for native token streaming enforcer.\n     *\n     * @param params - The parameters for the native token streaming enforcer.\n     * @returns Promise resolving to the streaming result.\n     */\n    getNativeTokenStreamingEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<StreamingResult> => {\n      return getNativeTokenStreamingEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n  });\n", "import type { Client, Address, Hex } from 'viem';\nimport { isAddressEqual } from 'viem';\nimport { getCode } from 'viem/actions';\n\nimport type { DeleGatorEnvironment } from '../types';\n\n// EIP-7702 delegation prefix (0xef0100)\nconst DELEGATION_PREFIX = '0xef0100' as const;\n\n/**\n * Parameters for checking if an account is delegated to the EIP-7702 implementation.\n */\nexport type IsValid7702ImplementationParameters = {\n  /** The client to use for the query. */\n  client: Client;\n  /** The address to check for proper delegation. */\n  accountAddress: Address;\n  /** The DeleGator environment containing contract addresses. */\n  environment: DeleGatorEnvironment;\n};\n\n/**\n * Extracts the delegated contract address from EIP-7702 delegation code.\n *\n * @param code - The code returned from getCode for a delegated account.\n * @returns The delegated contract address or null if not a valid delegation.\n */\nfunction extractDelegatedAddress(code: Hex | undefined): Address | null {\n  if (code?.length !== 48) {\n    // 0x (2 chars) + ef0100 (6 chars) + address (40 chars) = 48 chars\n    return null;\n  }\n\n  if (!code.toLowerCase().startsWith(DELEGATION_PREFIX.toLowerCase())) {\n    return null;\n  }\n\n  // Extract the 20-byte address after the delegation prefix\n  const addressHex = code.slice(8); // Remove '0xef0100' prefix (8 chars)\n  return `0x${addressHex}`;\n}\n\n/**\n * Checks if an account is properly delegated to the EIP-7702 implementation.\n *\n * This function validates EIP-7702 delegations by checking if the EOA has a 7702\n * contract assigned to it and comparing the delegated address against the 7702\n * implementation found in the environment.\n *\n * @param params - The parameters for checking the delegation.\n * @param params.client - The client to use for the query.\n * @param params.accountAddress - The address to check for proper delegation.\n * @param params.environment - The DeleGator environment containing contract addresses.\n * @returns A promise that resolves to true if the account is properly delegated to the 7702 implementation, false otherwise.\n * @example\n * ```typescript\n * const isValid = await isValid7702Implementation({\n *   client: publicClient,\n *   accountAddress: '0x...',\n *   environment: delegatorEnvironment,\n * });\n *\n * if (isValid) {\n *   console.log('Account is properly delegated to EIP-7702 implementation');\n * } else {\n *   console.log('Account is not properly delegated');\n * }\n * ```\n */\nexport async function isValid7702Implementation({\n  client,\n  accountAddress,\n  environment,\n}: IsValid7702ImplementationParameters): Promise<boolean> {\n  try {\n    // Get the code at the account address\n    const code = await getCode(client, {\n      address: accountAddress,\n    });\n\n    // Extract the delegated contract address from the EIP-7702 delegation code\n    const delegatedAddress = extractDelegatedAddress(code);\n\n    // If no valid delegation found, return false\n    if (!delegatedAddress) {\n      return false;\n    }\n\n    // Compare the delegated address with the 7702 implementation in the environment\n    const expectedImplementation =\n      environment.implementations.EIP7702StatelessDeleGatorImpl;\n    if (!expectedImplementation) {\n      return false;\n    }\n\n    return isAddressEqual(delegatedAddress, expectedImplementation);\n  } catch (error) {\n    // If the call fails (e.g., no code at address, network error),\n    // then it's not properly delegated to our implementation\n    return false;\n  }\n}\n", "import type {\n  Account,\n  Address,\n  Chain,\n  Client,\n  Hex,\n  Transport,\n  WalletClient,\n} from 'viem';\nimport { BaseError } from 'viem';\nimport { parseAccount } from 'viem/accounts';\n\nimport { prepareSignDelegationTypedData } from '../delegation';\nimport type { Delegation } from '../types';\n\nexport type SignDelegationParameters = {\n  /** Account to sign with */\n  account?: Account | Address;\n  /** The delegation to sign */\n  delegation: Omit<Delegation, 'signature'>;\n  /** The address of the delegation manager contract */\n  delegationManager: Address;\n  /** The chain ID for the signature */\n  chainId: number;\n  /** The name of the contract */\n  name?: string;\n  /** The version of the contract */\n  version?: string;\n  /** Whether to allow insecure unrestricted delegation */\n  allowInsecureUnrestrictedDelegation?: boolean;\n};\n\nexport type SignDelegationReturnType = Hex;\n\n/**\n * Signs a delegation using a wallet client.\n * @param client - The wallet client to use for signing.\n * @param parameters - The parameters for signing the delegation.\n * @returns The signature of the delegation.\n * @example\n * ```ts\n * const signature = await signDelegation(walletClient, {\n *   delegation: {\n *     delegate: '0x...',\n *     delegator: '0x...',\n *     authority: '0x...',\n *     caveats: [],\n *     salt: '0x'\n *   },\n *   delegationManager: '0x...',\n *   chainId: 1\n * });\n * ```\n */\nexport async function signDelegation<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(\n  client: Client<Transport, TChain, TAccount> & {\n    signTypedData: WalletClient['signTypedData'];\n  },\n  parameters: SignDelegationParameters,\n): Promise<SignDelegationReturnType> {\n  const {\n    account: accountParam = client.account,\n    delegation,\n    delegationManager,\n    chainId,\n    name = 'DelegationManager',\n    version = '1',\n    allowInsecureUnrestrictedDelegation = false,\n  } = parameters;\n\n  if (!accountParam) {\n    throw new BaseError('Account not found. Please provide an account.');\n  }\n\n  const account = parseAccount(accountParam);\n\n  const typedData = prepareSignDelegationTypedData({\n    delegation,\n    delegationManager,\n    chainId,\n    name,\n    version,\n    allowInsecureUnrestrictedDelegation,\n  });\n\n  return client.signTypedData({\n    account,\n    ...typedData,\n  });\n}\n\n/**\n * Creates a sign delegation action that can be used to extend a wallet client.\n * @returns A function that can be used with wallet client extend method.\n * @example\n * ```ts\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http()\n * }).extend(signDelegationActions());\n * ```\n */\nexport function signDelegationActions() {\n  return <\n    TChain extends Chain | undefined,\n    TAccount extends Account | undefined,\n  >(\n    client: Client<Transport, TChain, TAccount> & {\n      signTypedData: WalletClient['signTypedData'];\n    },\n  ) => ({\n    signDelegation: async (\n      parameters: Omit<SignDelegationParameters, 'chainId'> & {\n        chainId?: number;\n      },\n    ) =>\n      signDelegation(client, {\n        chainId:\n          parameters.chainId ??\n          (() => {\n            if (!client.chain?.id) {\n              throw new BaseError(\n                'Chain ID is required. Either provide it in parameters or configure the client with a chain.',\n              );\n            }\n            return client.chain.id;\n          })(),\n        ...parameters,\n      }),\n  });\n}\n", "import type {\n  Account,\n  Address,\n  Chain,\n  Client,\n  Hex,\n  Transport,\n  WalletClient,\n} from 'viem';\nimport { BaseError } from 'viem';\nimport { parseAccount } from 'viem/accounts';\n\nimport { prepareSignUserOperationTypedData } from '../userOp';\nimport type { UserOperationV07 } from '../userOp';\n\nexport type SignUserOperationParameters = {\n  /** Account to sign with */\n  account?: Account | Address;\n  /** The user operation to sign */\n  userOperation: Omit<UserOperationV07, 'signature'>;\n  /** The entry point contract address */\n  entryPoint: { address: Address };\n  /** The chain ID that the entry point is deployed on */\n  chainId: number;\n  /** The address of the smart account */\n  address: Address;\n  /** The name of the domain of the implementation contract */\n  name: 'HybridDeleGator' | 'MultiSigDeleGator';\n  /** The version of the domain of the implementation contract */\n  version?: string;\n};\n\nexport type SignUserOperationReturnType = Hex;\n\n/**\n * Signs a user operation using a wallet client.\n * @param client - The wallet client to use for signing.\n * @param parameters - The parameters for signing the user operation.\n * @returns The signature of the user operation.\n * @example\n * ```ts\n * const signature = await signUserOperation(walletClient, {\n *   userOperation: {\n *     sender: '0x...',\n *     nonce: 0n,\n *     callData: '0x',\n *     callGasLimit: 1000000n,\n *     verificationGasLimit: 1000000n,\n *     preVerificationGas: 21000n,\n *     maxFeePerGas: 1000000000n,\n *     maxPriorityFeePerGas: 1000000000n\n *   },\n *   entryPoint: { address: '0x...' },\n *   chainId: 1,\n *   address: '0x...',\n *   name: 'HybridDeleGator'\n * });\n * ```\n */\nexport async function signUserOperation<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(\n  client: Client<Transport, TChain, TAccount> & {\n    signTypedData: WalletClient['signTypedData'];\n  },\n  parameters: SignUserOperationParameters,\n): Promise<SignUserOperationReturnType> {\n  const {\n    account: accountParam = client.account,\n    userOperation,\n    entryPoint,\n    chainId,\n    name,\n    address,\n    version = '1',\n  } = parameters;\n\n  if (!accountParam) {\n    throw new BaseError('Account not found. Please provide an account.');\n  }\n\n  const account = parseAccount(accountParam);\n\n  const typedData = prepareSignUserOperationTypedData({\n    userOperation,\n    entryPoint,\n    chainId,\n    name,\n    address,\n    version,\n  });\n\n  return client.signTypedData({\n    account,\n    ...typedData,\n  });\n}\n\n/**\n * Creates a sign user operation action that can be used to extend a wallet client.\n * @returns A function that can be used with wallet client extend method.\n * @example\n * ```ts\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http()\n * }).extend(signUserOperationActions());\n * ```\n */\nexport function signUserOperationActions() {\n  return <\n    TChain extends Chain | undefined,\n    TAccount extends Account | undefined,\n  >(\n    client: Client<Transport, TChain, TAccount> & {\n      signTypedData: WalletClient['signTypedData'];\n    },\n  ) => ({\n    signUserOperation: async (\n      parameters: Omit<SignUserOperationParameters, 'chainId'> & {\n        chainId?: number;\n      },\n    ) =>\n      signUserOperation(client, {\n        chainId:\n          parameters.chainId ??\n          (() => {\n            if (!client.chain?.id) {\n              throw new BaseError(\n                'Chain ID is required. Either provide it in parameters or configure the client with a chain.',\n              );\n            }\n            return client.chain.id;\n          })(),\n        ...parameters,\n      }),\n  });\n}\n", "import {\n  bytesToHex as bytesToHex_noble,\n  hexToBytes as hexToBytes_noble,\n} from '@noble/hashes/utils'\nimport type { Hex } from './types.js'\n\nexport function bytesToHex(bytes: Uint8Array): Hex {\n  return `0x${bytesToHex_noble(bytes)}`\n}\n\nexport function hexToBytes(value: Hex): Uint8Array {\n  return hexToBytes_noble(value.slice(2))\n}\n\nexport function base64UrlToBytes(base64Url: string): Uint8Array {\n  const base64 = base64UrlToBase64(base64Url)\n  const utf8 = base64ToUtf8(base64)\n  return Uint8Array.from(utf8, (c) => c.charCodeAt(0))\n}\n\nexport function bytesToBase64Url(bytes: Uint8Array): string {\n  const base64 = utf8ToBase64(String.fromCharCode(...bytes))\n  return base64ToBase64Url(base64)\n}\n\nexport function base64UrlToBase64(base64Url: string): string {\n  return base64Url.replaceAll('-', '+').replaceAll('_', '/')\n}\n\nexport function base64ToBase64Url(base64: string): string {\n  return base64.replaceAll('+', '-').replaceAll('/', '_').replace(/=+$/, '')\n}\n\nexport function base64ToUtf8(base64: string): string {\n  return atob(base64)\n}\n\nexport function utf8ToBase64(base64: string): string {\n  return btoa(base64)\n}\n\nexport async function bytesToCryptoKey(bytes: Uint8Array): Promise<any> {\n  return await crypto.subtle.importKey(\n    'spki',\n    bytes,\n    {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n      hash: 'SHA-256',\n    },\n    true,\n    ['verify'],\n  )\n}\n\nexport async function cryptoKeyToBytes(key: CryptoKey): Promise<Uint8Array> {\n  return new Uint8Array(await crypto.subtle.exportKey('raw', key))\n}\n", "import { keccak_256 } from '@noble/hashes/sha3'\nimport { toBytes } from '@noble/hashes/utils'\n\nimport { parseCredentialPublicKey, serializePublicKey } from './publicKey.js'\nimport type {\n  Credential,\n  OneOf,\n  P256Credential,\n  Prettify,\n  PublicKeyCredential,\n  PublicKeyCredentialCreationOptions,\n} from './types.js'\nimport { base64UrlToBytes } from './utils.js'\n\n// Challenge for credential creation – random 16 bytes.\nexport const createChallenge = Uint8Array.from([\n  105, 171, 180, 181, 160, 222, 75, 198, 42, 42, 32, 31, 141, 37, 186, 233,\n])\n\nexport type CreateCredentialParameters =\n  GetCredentialCreationOptionsParameters & {\n    /**\n     * Credential creation function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.create\n     */\n    createFn?:\n      | ((\n          options?: CredentialCreationOptions | undefined,\n        ) => Promise<Credential | null>)\n      | undefined\n  }\n\nexport type CreateCredentialReturnType = Prettify<P256Credential>\n\n/**\n * Creates a new credential, which can be stored and later used for signing.\n *\n * @example\n * ```ts\n * const credential = await createCredential({ name: 'Example' })\n * ```\n */\nexport async function createCredential(\n  parameters: CreateCredentialParameters,\n): Promise<CreateCredentialReturnType> {\n  const {\n    createFn = window.navigator.credentials.create.bind(\n      window.navigator.credentials,\n    ),\n    ...rest\n  } = parameters\n  const options = getCredentialCreationOptions(rest)\n  try {\n    const credential = (await createFn(options)) as PublicKeyCredential\n    if (!credential) throw new Error('credential creation failed.')\n    const publicKey = await parseCredentialPublicKey(\n      new Uint8Array((credential.response as any).getPublicKey()),\n    )\n    return {\n      id: credential.id,\n      publicKey: serializePublicKey(publicKey, { compressed: true }),\n      raw: credential,\n    }\n  } catch (error) {\n    throw new Error('credential creation failed.', { cause: error })\n  }\n}\n\nexport type GetCredentialCreationOptionsParameters = {\n  /**\n   * A string specifying the relying party's preference for how the attestation statement\n   * (i.e., provision of verifiable evidence of the authenticity of the authenticator and its data)\n   * is conveyed during credential creation.\n   */\n  attestation?: PublicKeyCredentialCreationOptions['attestation'] | undefined\n  /**\n   * An object whose properties are criteria used to filter out the potential authenticators\n   * for the credential creation operation.\n   */\n  authenticatorSelection?:\n    | PublicKeyCredentialCreationOptions['authenticatorSelection']\n    | undefined\n  /**\n   * An `ArrayBuffer`, `TypedArray`, or `DataView` used as a cryptographic challenge.\n   */\n  challenge?: PublicKeyCredentialCreationOptions['challenge'] | undefined\n  /**\n   * List of credential IDs to exclude from the creation. This property can be used\n   * to prevent creation of a credential if it already exists.\n   */\n  excludeCredentialIds?: readonly string[] | undefined\n  /**\n   * List of Web Authentication API credentials to use during creation or authentication.\n   */\n  extensions?: PublicKeyCredentialCreationOptions['extensions'] | undefined\n  /**\n   * An object describing the relying party that requested the credential creation\n   */\n  rp?:\n    | {\n        id: string\n        name: string\n      }\n    | undefined\n  /**\n   * A numerical hint, in milliseconds, which indicates the time the calling web app is willing to wait for the creation operation to complete.\n   */\n  timeout?: PublicKeyCredentialCreationOptions['timeout'] | undefined\n} & OneOf<\n  | {\n      /** Name for the credential (user.name). */\n      name: string\n    }\n  | {\n      /**\n       * An object describing the user account for which the credential is generated.\n       */\n      user: {\n        displayName?: string\n        id?: BufferSource\n        name: string\n      }\n    }\n>\n\nexport type GetCredentialCreationOptionsReturnType = CredentialCreationOptions\n\n/**\n * Returns the creation options for a P256 WebAuthn Credential with a Passkey authenticator.\n *\n * @example\n * ```ts\n * const options = getCredentialCreationOptions({ name: 'Example' })\n * const credentials = window.navigator.credentials.create(options)\n * ```\n */\nexport function getCredentialCreationOptions(\n  parameters: GetCredentialCreationOptionsParameters,\n): GetCredentialCreationOptionsReturnType {\n  const {\n    attestation = 'none',\n    authenticatorSelection = {\n      authenticatorAttachment: 'platform',\n      residentKey: 'preferred',\n      requireResidentKey: false,\n      userVerification: 'required',\n    },\n    challenge = createChallenge,\n    excludeCredentialIds,\n    name: name_,\n    rp = {\n      id: window.location.hostname,\n      name: window.document.title,\n    },\n    user,\n    extensions,\n  } = parameters\n  const name = (user?.name ?? name_)!\n  return {\n    publicKey: {\n      attestation,\n      authenticatorSelection,\n      challenge,\n      ...(excludeCredentialIds\n        ? {\n            excludeCredentials: excludeCredentialIds?.map((id) => ({\n              id: base64UrlToBytes(id),\n              type: 'public-key',\n            })),\n          }\n        : {}),\n      pubKeyCredParams: [\n        {\n          type: 'public-key',\n          alg: -7, // p256\n        },\n      ],\n      rp,\n      user: {\n        id: user?.id ?? keccak_256(toBytes(name)),\n        name,\n        displayName: user?.displayName ?? name,\n      },\n      extensions,\n    },\n  } as CredentialCreationOptions\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { createCurve } from './_shortw_utils.js';\nimport { createHasher } from './abstract/hash-to-curve.js';\nimport { Field } from './abstract/modular.js';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.js';\n\n// NIST secp256r1 aka p256\n// https://www.secg.org/sec2-v2.pdf, https://neuromancer.sk/std/nist/P-256\n\nconst Fp = Field(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'));\nconst CURVE_A = Fp.create(BigInt('-3'));\nconst CURVE_B = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b');\n\n// prettier-ignore\nexport const p256 = createCurve({\n  a: CURVE_A, // Equation params: a, b\n  b: CURVE_B,\n  Fp, // Field: 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n\n  // Curve order, total count of valid points in the field\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  // Base (generator) point (x, y)\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n  h: BigInt(1),\n  lowS: false,\n} as const, sha256);\nexport const secp256r1 = p256;\n\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp, {\n    A: CURVE_A,\n    B: CURVE_B,\n    Z: Fp.create(BigInt('-10')),\n  }))();\n\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(secp256r1.ProjectivePoint, (scalars: bigint[]) => mapSWU(scalars[0]), {\n    DST: 'P256_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n  }))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n", "import { numberToBytesBE } from '@noble/curves/abstract/utils'\nimport { p256 } from '@noble/curves/p256'\nimport type { Credential, Hex, Signature, WebAuthnData } from './types.js'\nimport {\n  base64UrlToBytes,\n  bytesToBase64Url,\n  bytesToHex,\n  hexToBytes,\n} from './utils.js'\n\nexport type SignParameters = GetCredentialSignRequestOptionsParameters & {\n  /**\n   * Credential request function. Useful for environments that do not support\n   * the WebAuthn API natively (i.e. React Native or testing environments).\n   *\n   * @default window.navigator.credentials.get\n   */\n  getFn?:\n    | ((\n        options?: CredentialRequestOptions | undefined,\n      ) => Promise<Credential | null>)\n    | undefined\n}\n\nexport type SignReturnType = {\n  signature: Hex\n  webauthn: WebAuthnData\n  raw: PublicKeyCredential\n}\n\n/**\n * Signs a hash using a stored credential. If no credential is provided,\n * a prompt will be displayed for the user to select an existing credential\n * that was previously registered.\n *\n * @example\n * ```ts\n * import { credential } from './credential'\n *\n * const signature = await sign({\n *   credentialId: credential.id,\n *   hash: '0x...',\n * })\n * ```\n */\nexport async function sign(\n  parameters: SignParameters,\n): Promise<SignReturnType> {\n  const {\n    getFn = window.navigator.credentials.get.bind(window.navigator.credentials),\n    ...rest\n  } = parameters\n  const options = getCredentialSignRequestOptions(rest)\n  try {\n    const credential = (await getFn(options)) as PublicKeyCredential\n    if (!credential) throw new Error('credential request failed.')\n    const response = credential.response as AuthenticatorAssertionResponse\n\n    const clientDataJSON = String.fromCharCode(\n      ...new Uint8Array(response.clientDataJSON),\n    )\n    const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n    const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n    const signature = parseAsn1Signature(\n      base64UrlToBytes(bytesToBase64Url(new Uint8Array(response.signature))),\n    )\n\n    return {\n      signature: serializeSignature(signature),\n      webauthn: {\n        authenticatorData: bytesToHex(\n          new Uint8Array(response.authenticatorData),\n        ),\n        clientDataJSON,\n        challengeIndex,\n        typeIndex,\n        userVerificationRequired:\n          options.publicKey!.userVerification === 'required',\n      },\n      raw: credential,\n    }\n  } catch (error) {\n    throw new Error('credential request failed.', { cause: error })\n  }\n}\n\nexport type GetCredentialSignRequestOptionsParameters = {\n  credentialId?: string | undefined\n  hash: Hex\n  /**\n   * The relying party identifier to use.\n   */\n  rpId?: PublicKeyCredentialRequestOptions['rpId'] | undefined\n  userVerification?:\n    | PublicKeyCredentialRequestOptions['userVerification']\n    | undefined\n}\nexport type GetCredentialSignRequestOptionsReturnType = CredentialRequestOptions\n\n/**\n * Returns the request options to sign a hash using a stored credential\n * with a P256 public key.\n *\n * @example\n * ```ts\n * const options = getCredentialSignRequestOptions({ hash: '0x...' })\n * const credentials = window.navigator.credentials.get(options)\n * ```\n */\nexport function getCredentialSignRequestOptions(\n  parameters: GetCredentialSignRequestOptionsParameters,\n): GetCredentialSignRequestOptionsReturnType {\n  const {\n    credentialId,\n    hash,\n    rpId = window.location.hostname,\n    userVerification = 'required',\n  } = parameters\n  const challenge = base64UrlToBytes(bytesToBase64Url(hexToBytes(hash)))\n  return {\n    publicKey: {\n      ...(credentialId\n        ? {\n            allowCredentials: [\n              {\n                id: base64UrlToBytes(credentialId),\n                type: 'public-key',\n              },\n            ],\n          }\n        : {}),\n      challenge,\n      rpId,\n      userVerification,\n    },\n  }\n}\n\n/**\n * @internal\n * Parses an ASN.1 signature into a r and s value.\n */\nexport function parseAsn1Signature(bytes: Uint8Array) {\n  const r_start = bytes[4] === 0 ? 5 : 4\n  const r_end = r_start + 32\n  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2\n\n  const r = BigInt(bytesToHex(bytes.slice(r_start, r_end)))\n  const s = BigInt(bytesToHex(bytes.slice(s_start)))\n  const n = p256.CURVE.n\n\n  return {\n    r,\n    s: s > n / 2n ? n - s : s,\n  }\n}\n\n/**\n * Parses a serialized signature into r and s values.\n */\nexport function parseSignature(signature: Hex | Uint8Array): Signature {\n  const bytes =\n    typeof signature === 'string' ? hexToBytes(signature) : signature\n  const r = bytes.slice(0, 32)\n  const s = bytes.slice(32, 64)\n  return {\n    r: BigInt(bytesToHex(r)),\n    s: BigInt(bytesToHex(s)),\n  }\n}\n\nexport type SerializeSignatureOptions<to extends 'hex' | 'bytes' = 'hex'> = {\n  to?: to | 'bytes' | 'hex' | undefined\n}\n\n/**\n * Serializes a signature into a hex string or bytes.\n */\nexport function serializeSignature<to extends 'hex' | 'bytes' = 'hex'>(\n  signature: Signature,\n  options: SerializeSignatureOptions<to> = {},\n): to extends 'hex' ? Hex : Uint8Array {\n  const { to = 'hex' } = options\n  const result = new Uint8Array([\n    ...numberToBytesBE(signature.r, 32),\n    ...numberToBytesBE(signature.s, 32),\n  ])\n  return (to === 'hex' ? bytesToHex(result) : result) as any\n}\n", "/**\n * To be used in sdk methods to call Implementation specific code\n * @type {Implementation}\n */\nexport enum Implementation {\n  MultiSig = 'MultiSig',\n  Hybrid = 'Hybrid',\n  Stateless7702 = 'Stateless7702',\n}\n", "import type { Address, Hex } from 'viem';\nimport { getContractAddress, pad } from 'viem';\n\nimport { Implementation } from './constants';\nimport { initializeHybridDeleGator } from './DelegationFramework/HybridDeleGator/encode';\nimport { initializeMultiSigDeleGator } from './DelegationFramework/MultiSigDeleGator/encode';\nimport { create2Deploy as encodeCreate2Deploy } from './DelegationFramework/SimpleFactory/encode';\nimport { encodeProxyCreationCode } from './DelegationFramework/utils';\nimport type {\n  DeleGatorEnvironment,\n  HybridDeleGatorDeployParams,\n  MultiSigDeleGatorDeployParams,\n  DeployParams,\n} from './types';\n\n/**\n * Infers counterfactual account data for a DeleGator smart account.\n *\n * @template TImplementation - The type of implementation, extending Implementation.\n * @template TDeployParams - The type of deployment parameters, defaults to DeployParams<Implementation>.\n * @param options - The options for generating counterfactual account data.\n * @param options.factory - The address of the SimpleFactory contract.\n * @param options.implementations - The DeleGator implementation contracts.\n * @param options.implementation - The implementation type to use.\n * @param options.deployParams - The deployment parameters for the specified implementation.\n * @param options.deploySalt - The salt to use for CREATE2 address computation.\n * @returns An object containing the counterfactual address and factory calldata.\n * @description This function calculates the address a DeleGator contract would have if deployed,\n * and provides the calldata needed to deploy it.\n */\nexport const getCounterfactualAccountData = async <\n  TImplementation extends Implementation,\n>({\n  factory,\n  implementations,\n  implementation,\n  deployParams,\n  deploySalt,\n}: {\n  factory: Address;\n  implementations: DeleGatorEnvironment['implementations'];\n  implementation: TImplementation;\n  deployParams: DeployParams<TImplementation>;\n  deploySalt: Hex;\n}): Promise<{ factoryData: Hex; address: Address }> => {\n  let implementationAddress: Address;\n  let initcode: Hex;\n\n  switch (implementation) {\n    case Implementation.Hybrid: {\n      const [owner, keyIds, xValues, yValues] =\n        deployParams as HybridDeleGatorDeployParams;\n\n      if (!implementations.HybridDeleGatorImpl) {\n        throw new Error(\n          'HybridDeleGatorImpl address not provided in environment',\n        );\n      }\n\n      implementationAddress = implementations.HybridDeleGatorImpl;\n\n      const p256Owners = keyIds.map((keyId, index) => {\n        const xValue = xValues[index];\n        const yValue = yValues[index];\n\n        if (!xValue || !yValue) {\n          throw new Error(\n            `Missing X or Y value for keyId ${keyId} at index ${index}`,\n          );\n        }\n\n        return {\n          keyId,\n          x: xValue,\n          y: yValue,\n        };\n      });\n\n      initcode = initializeHybridDeleGator({ eoaOwner: owner, p256Owners });\n      break;\n    }\n    case Implementation.MultiSig: {\n      const [owners, threshold] = deployParams as MultiSigDeleGatorDeployParams;\n\n      if (!implementations.MultiSigDeleGatorImpl) {\n        throw new Error(\n          'MultiSigDeleGatorImpl address not provided in environment',\n        );\n      }\n\n      implementationAddress = implementations.MultiSigDeleGatorImpl;\n      initcode = initializeMultiSigDeleGator({ owners, threshold });\n      break;\n    }\n    default:\n      throw new Error(`Implementation type '${implementation}' not supported`);\n  }\n\n  const salt = pad(deploySalt, { dir: 'left', size: 32 });\n\n  const proxyCreationCode = encodeProxyCreationCode({\n    implementationAddress,\n    initcode,\n  });\n\n  const address = getContractAddress({\n    bytecode: proxyCreationCode,\n    from: factory,\n    opcode: 'CREATE2',\n    salt,\n  });\n\n  const factoryData = encodeCreate2Deploy(proxyCreationCode, salt);\n\n  return {\n    factoryData,\n    address,\n  };\n};\n", "import { DelegationManager } from '@metamask/delegation-abis';\nimport { encodeFunctionData } from 'viem';\nimport type { Address, Hex } from 'viem';\n\nimport {\n  execute,\n  executeWithMode,\n} from './DelegationFramework/DeleGatorCore/encode';\nimport {\n  ExecutionMode,\n  createExecution,\n  encodeExecutionCalldatas,\n} from './executions';\nimport type { DelegatedCall } from './experimental/erc7710RedeemDelegationAction';\nimport type { Call } from './types';\n\n/**\n * Checks if a call is a delegated call by checking for the presence of permissionsContext and delegationManager.\n *\n * @param call - The call to check.\n * @returns True if the call is a delegated call, false otherwise.\n */\nconst isDelegatedCall = (call: Call): call is DelegatedCall => {\n  return 'permissionsContext' in call && 'delegationManager' in call;\n};\n\n/**\n * If there's a single call with permissionsContext and delegationManager,\n * processes it as a delegated call.\n *\n * @param call - The call to process.\n * @returns The execution object for the delegated call.\n * @description\n * This function creates an execution that calls redeemDelegations on the delegation manager.\n */\nconst processDelegatedCall = (call: DelegatedCall) => {\n  const {\n    permissionsContext,\n    delegationManager,\n    to: target,\n    value,\n    data: callData,\n  } = call;\n\n  const callAsExecution = createExecution({ target, value, callData });\n\n  if (!permissionsContext) {\n    return callAsExecution;\n  }\n\n  const redeemCalldata = encodeFunctionData({\n    abi: DelegationManager.abi,\n    functionName: 'redeemDelegations',\n    args: [\n      [permissionsContext],\n      [ExecutionMode.SingleDefault],\n      encodeExecutionCalldatas([[callAsExecution]]),\n    ],\n  });\n\n  return createExecution({\n    target: delegationManager,\n    callData: redeemCalldata,\n  });\n};\n\n/**\n * If there's a single call, encode the shorthand `execute` function. Otherwise, encode the `executeWithMode` function. Execution type will always be \"default\".\n *\n * @param calls - The calls to execute.\n * @returns The encoded calldata for the DeleGator to execute the calls.\n * @description\n * This function supports both single and batch execution modes.\n * For single calls, it uses the gas-efficient execute function.\n */\nexport const encodeCalls = (calls: readonly Call[]) => {\n  if (calls.length === 1) {\n    const call = calls[0];\n    if (call && !isDelegatedCall(call)) {\n      const { to: target, value, data: callData } = call;\n      const execution = createExecution({ target, value, callData });\n      return execute({ execution });\n    }\n  }\n\n  const executions = calls.map((call) => {\n    if (isDelegatedCall(call)) {\n      return processDelegatedCall(call);\n    }\n    const { to: target, value, data: callData } = call;\n    return createExecution({ target, value, callData });\n  });\n\n  const mode =\n    calls.length === 1\n      ? ExecutionMode.SingleDefault\n      : ExecutionMode.BatchDefault;\n  return executeWithMode({ mode, executions });\n};\n\n/**\n * Encodes calls for execution by a DeleGator smart contract.\n *\n * @param caller - The address of the DeleGator contract.\n * @param calls - An array of Call objects, each containing 'to', optional 'data', and optional 'value'.\n * @returns A promise that resolves to the encoded function data as a hexadecimal string.\n * @description\n * - If there's a single call directly to the delegator, it returns the call data directly.\n * - For multiple calls or calls to other addresses, it creates executions and encodes them for the DeleGator's execute function.\n * - The execution mode is set to ExecutionMode.SingleDefault for a single call, or ExecutionMode.BatchDefault for multiple calls.\n *\n * todo: This doesn't fully expose the flexibility of the DeleGator's execute function, but it's a start.\n * maybe we add a mechanism where individual calls passed to this function can be encoded batches.\n */\nexport const encodeCallsForCaller = async (\n  caller: Address,\n  calls: readonly Call[],\n): Promise<Hex> => {\n  if (calls.length === 1) {\n    const call = calls[0];\n    if (call && call.to === caller && !isDelegatedCall(call)) {\n      // if there's a single call, and it's to the delegator, we can just return the calldata directly.\n      return call.data ?? '0x';\n    }\n  }\n  return encodeCalls(calls);\n};\n", "import {\n  parseAbiParameters,\n  encodeAbiParameters,\n  type Hex,\n  encodePacked,\n  keccak256,\n  concat,\n} from 'viem';\nimport { parseSignature } from 'webauthn-p256';\n\nexport const FIELD_MODULUS =\n  115792089210356248762697446949407573529996955224135760342422259061068512044369n;\nexport const MALLEABILITY_THRESHOLD = FIELD_MODULUS / 2n;\n\nexport const SIGNATURE_ABI_PARAMS = parseAbiParameters(\n  'bytes32, uint256, uint256, bytes, bool, string, string, uint256',\n);\n\n/**\n * This function is used to convert the client data returned from the\n * credentials API into a format that can be consumed by the DeleGator\n * contracts. We need the flattend JSON strings before and after the\n * userOpHash/challenge. This function provides those two client data string\n * slices.\n * @param clientDataJson - The client data JSON string.\n * @returns Returns [clientDataJSONPrefix and clientDataJSONSuffix]\n * ClientDataJSONPrefix contains the client data till the challengeHash\n * ClientDataJSONSuffix contains the client data after the challengeHash.\n */\nexport const splitOnChallenge = (\n  clientDataJson: string,\n): [clientDataJSONPrefix: string, clientDataJSONSuffix: string] => {\n  /*\n  CientData looks like this:\n  {\n    \"type\": \"webauthn.create\" | \"webauthn.get\",\n    \"challenge\": \"{userOpHash}\",\n    \"origin\": \"{Domain}\",\n    \"crossOrigin\": boolean\n  }  \n  */\n  try {\n    const { challenge } = JSON.parse(clientDataJson);\n    if (challenge === undefined) {\n      throw new Error('No \"challenge\" found in the input string');\n    }\n    return clientDataJson.split(challenge) as [string, string];\n  } catch (error) {\n    throw new Error('No \"challenge\" found in the input string', {\n      cause: error,\n    });\n  }\n};\n\n/**\n * Returns the index of '\"type\":' in the ClientData.\n * @param clientDataJson - Stringified ClientDataJSON.\n * @returns The index of '\"type\":' in the ClientData.\n */\nexport const getResponseTypeLocation = (clientDataJson: string): bigint => {\n  try {\n    // Find the index of the `\"type\":` key in the JSON string directly\n    const typeIndex = clientDataJson.indexOf('\"type\":');\n\n    if (typeIndex === -1) {\n      throw new Error('No \"type\" found in the input string');\n    }\n    // Return the index of the `\"type\":` key\n    return BigInt(typeIndex);\n  } catch (error) {\n    // Handle any errors that occur during the search\n    throw new Error('No \"type\" found in the input string', {\n      cause: error,\n    });\n  }\n};\n\n/**\n * Encodes a signature to a hexadecimal signature that will be accepted\n * by the DeleGator contracts.\n * @param keyId - The key used for the signature, represented as a hexadecimal string.\n * @param signature - The signature to convert, as Hex.\n * @param clientDataJSON - The client data used in the creation of the signature.\n * @param authenticatorData - The authenticator data used in the creation of the signature.\n * @returns The signature as a valid DeleGator signature encoded as Hexadecimal string.\n */\nexport function encodeDeleGatorSignature(\n  keyId: string,\n  signature: Hex,\n  clientDataJSON: string,\n  authenticatorData: Hex,\n): Hex {\n  const keyIdHash = keccak256(encodePacked(['string'], [keyId]));\n\n  const parsedSignature = parseSignature(signature);\n\n  let { s } = parsedSignature;\n\n  while (s > MALLEABILITY_THRESHOLD) {\n    s = FIELD_MODULUS - s;\n  }\n\n  const { r } = parsedSignature;\n\n  const [clientDataComponent1, clientDataComponent2] =\n    splitOnChallenge(clientDataJSON);\n\n  const { userVerified } = parseAuthenticatorFlags(authenticatorData);\n\n  const responseTypeLocation = getResponseTypeLocation(clientDataJSON);\n\n  const encodedSignature = encodeAbiParameters(SIGNATURE_ABI_PARAMS, [\n    keyIdHash,\n    r,\n    s,\n    authenticatorData,\n    userVerified,\n    clientDataComponent1,\n    clientDataComponent2,\n    responseTypeLocation,\n  ]);\n  return encodedSignature;\n}\n\nconst AUTHENTICATOR_DATA_FLAGS_OFFSET = 32;\n// We have all of the flag bits defined here for completeness, even though we only extract the userVerified flag.\nenum AuthenticatorDataFlagBitIndex {\n  UserPresence = 0,\n  UserVerified = 2,\n  BackupEligibility = 3,\n  BackupState = 4,\n  AttestedCredentialData = 6,\n  ExtensionData = 7,\n}\n\nexport type AuthenticatorFlags = {\n  userVerified: boolean;\n};\n\n/**\n * Parses the authenticator data and returns an authenticator flags object with the `userVerified` flag.\n * See https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data.\n * @param authenticatorData - The authenticator data to parse.\n * @returns An object representing the parsed authenticator flags.\n */\nexport function parseAuthenticatorFlags(\n  authenticatorData: Hex,\n): AuthenticatorFlags {\n  // eslint-disable-next-line no-restricted-globals\n  const authenticatorDataBuffer = Buffer.from(\n    authenticatorData.slice(2),\n    'hex',\n  );\n  const flags = authenticatorDataBuffer.readUInt8(\n    AUTHENTICATOR_DATA_FLAGS_OFFSET,\n  );\n\n  // Bit 0 is the least significant bit in the flags byte, so we left shift 0b1 by the bit index\n  // eslint-disable-next-line no-bitwise\n  const bitMask = 0b1 << AuthenticatorDataFlagBitIndex.UserVerified;\n\n  return {\n    // eslint-disable-next-line no-bitwise\n    userVerified: (flags & bitMask) !== 0x0,\n  };\n}\n\n/**\n * Creates a dummy signature.\n * This must meet all early-failure conditions of the real signature, but does not need to be a valid signature.\n * @param keyId - The key ID to use for the dummy signature.\n * @returns The encoded signature.\n */\nexport const createDummyWebAuthnSignature = (keyId: Hex) => {\n  // https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#data_structure\n  const rpIdHash = keccak256(encodePacked(['string'], ['AuthenticatorData']));\n  const flags = '0x05';\n  const signCount = '0x00000000';\n  const authenticatorData = concat([rpIdHash, flags, signCount]);\n\n  const keyIdHash = keccak256(encodePacked(['string'], [keyId]));\n  const rs =\n    57896044605178124381348723474703786764998477612067880171211129530534256022184n;\n  const userVerification = true;\n  const clientDataPrefix = '{\"type\":\"webauthn.get\",\"challenge\":\"';\n  const clientDataSuffix = '\",\"origin\":\"passkey-domain\",\"crossOrigin\":false}';\n  const responseTypeLocation = 1n;\n\n  const encodedSignature = encodeAbiParameters(SIGNATURE_ABI_PARAMS, [\n    keyIdHash,\n    rs,\n    rs,\n    authenticatorData,\n    userVerification,\n    clientDataPrefix,\n    clientDataSuffix,\n    responseTypeLocation,\n  ]);\n\n  return encodedSignature;\n};\n", "export const deployments_1_3_0 = {\n  DelegationManager: '0xdb9B1e94B5b69Df7e401DDbedE43491141047dB3',\n  EntryPoint: '0x0000000071727De22E5E9d8BAf0edAc6f37da032',\n  SimpleFactory: '0x69Aa2f9fe1572F1B640E1bbc512f5c3a734fc77c',\n  // Implementations\n  MultiSigDeleGatorImpl: '0x56a9EdB16a0105eb5a4C54f4C062e2868844f3A7',\n  HybridDeleGatorImpl: '0x48dBe696A4D990079e039489bA2053B36E8FFEC4',\n  EIP7702StatelessDeleGatorImpl: '0x63c0c19a282a1B52b07dD5a65b58948A07DAE32B',\n  // Caveat Enforcers\n  AllowedCalldataEnforcer: '0xc2b0d624c1c4319760C96503BA27C347F3260f55',\n  AllowedMethodsEnforcer: '0x2c21fD0Cb9DC8445CB3fb0DC5E7Bb0Aca01842B5',\n  AllowedTargetsEnforcer: '0x7F20f61b1f09b08D970938F6fa563634d65c4EeB',\n  BlockNumberEnforcer: '0x5d9818dF0AE3f66e9c3D0c5029DAF99d1823ca6c',\n  DeployedEnforcer: '0x24ff2AA430D53a8CD6788018E902E098083dcCd2',\n  ERC20BalanceChangeEnforcer: '0xcdF6aB796408598Cea671d79506d7D48E97a5437',\n  ERC20TransferAmountEnforcer: '0xf100b0819427117EcF76Ed94B358B1A5b5C6D2Fc',\n  ERC20PeriodTransferEnforcer: '0x474e3Ae7E169e940607cC624Da8A15Eb120139aB',\n  ERC20StreamingEnforcer: '0x56c97aE02f233B29fa03502Ecc0457266d9be00e',\n  ERC721BalanceChangeEnforcer: '0x8aFdf96eDBbe7e1eD3f5Cd89C7E084841e12A09e',\n  ERC721TransferEnforcer: '0x3790e6B7233f779b09DA74C72b6e94813925b9aF',\n  ERC1155BalanceChangeEnforcer: '0x63c322732695cAFbbD488Fc6937A0A7B66fC001A',\n  ExactCalldataBatchEnforcer: '0x982FD5C86BBF425d7d1451f974192d4525113DfD',\n  ExactCalldataEnforcer: '0x99F2e9bF15ce5eC84685604836F71aB835DBBdED',\n  ExactExecutionBatchEnforcer: '0x1e141e455d08721Dd5BCDA1BaA6Ea5633Afd5017',\n  ExactExecutionEnforcer: '0x146713078D39eCC1F5338309c28405ccf85Abfbb',\n  IdEnforcer: '0xC8B5D93463c893401094cc70e66A206fb5987997',\n  LimitedCallsEnforcer: '0x04658B29F6b82ed55274221a06Fc97D318E25416',\n  NativeBalanceChangeEnforcer: '0xbD7B277507723490Cd50b12EaaFe87C616be6880',\n  ArgsEqualityCheckEnforcer: '0x44B8C6ae3C304213c3e298495e12497Ed3E56E41',\n  NativeTokenPaymentEnforcer: '0x4803a326ddED6dDBc60e659e5ed12d85c7582811',\n  NativeTokenTransferAmountEnforcer:\n    '0xF71af580b9c3078fbc2BBF16FbB8EEd82b330320',\n  NativeTokenStreamingEnforcer: '0xD10b97905a320b13a0608f7E9cC506b56747df19',\n  NativeTokenPeriodTransferEnforcer:\n    '0x9BC0FAf4Aca5AE429F4c06aEEaC517520CB16BD9',\n  NonceEnforcer: '0xDE4f2FAC4B3D87A1d9953Ca5FC09FCa7F366254f',\n  OwnershipTransferEnforcer: '0x7EEf9734E7092032B5C56310Eb9BbD1f4A524681',\n  RedeemerEnforcer: '0xE144b0b2618071B4E56f746313528a669c7E65c5',\n  SpecificActionERC20TransferBatchEnforcer:\n    '0x00e0251aaA263dfE3B3541B758A82D1CBA1c3B6D',\n  TimestampEnforcer: '0x1046bb45C8d673d4ea75321280DB34899413c069',\n  ValueLteEnforcer: '0x92Bf12322527cAA612fd31a0e810472BBB106A8F',\n  MultiTokenPeriodEnforcer: '0xFB2f1a9BD76d3701B730E5d69C3219D42D80eBb7',\n} as const;\n\nexport const deployments_1_1_0 = {\n  DelegationManager: '0x56D56e07e3d6Ee5a24e30203A37a0a460f42D7A3',\n  EntryPoint: '0x0000000071727De22E5E9d8BAf0edAc6f37da032',\n  SimpleFactory: '0x6ff518884f21168c30c58CB21184D6AdBC18Ad90',\n  // Implementations\n  MultiSigDeleGatorImpl: '0xd1f421EDbA5e3FA9efe3874827114b20C5BEC40C',\n  HybridDeleGatorImpl: '0x941f3a016F8726d5643Ce62452d0D78492D42b42',\n  // Caveat Enforcers\n  AllowedCalldataEnforcer: '0xff71d60f3208469cBCE0859717B5198042DCB3F3',\n  AllowedMethodsEnforcer: '0xe32C2561792e8446Abe73B9f557B881C13906186',\n  AllowedTargetsEnforcer: '0x06aaE4c67EEA95277c46Bf79b1583d4a01772D22',\n  BlockNumberEnforcer: '0x8E470D2Ae278457b42d2405E0B8Cd4BE21Ed9045',\n  DeployedEnforcer: '0xf9088f013dBD9ebb7Cebd66fEB48253c6Ac5a820',\n  ERC20BalanceGteEnforcer: '0xB7B6f32ec6343261D814e55Ed8C5925d91Cab861',\n  ERC20TransferAmountEnforcer: '0x9A069b18032B31429A363AeCFb1B6A0564b44471',\n  IdEnforcer: '0x91015c3b9D9523966eD2399885e5Df7A567f916c',\n  LimitedCallsEnforcer: '0xe694bFfffEA3E85923b1210b37e6a0175e910863',\n  NonceEnforcer: '0xE83BCFD8bBE672A96747e831050a91cf44F4F87A',\n  TimestampEnforcer: '0x550FdD13eEBC1f22ea2a2480024BacBF0Ad7e5CE',\n  ValueLteEnforcer: '0xBE32a6DB7471F63BB168C088c57Db01AfAe87967',\n  NativeTokenTransferAmountEnforcer:\n    '0x5eD3833d7B957A8DB8A461c3AF2d668Ec25382E0',\n  NativeBalanceGteEnforcer: '0x376a98860E210DdEda3689fb39565592c563cB0A',\n  ArgsEqualityCheckEnforcer: '0x7378dE585998d3E18Ce147867C335C25B3dB8Ee5',\n  NativeTokenPaymentEnforcer: '0x87Fe18EbF99e42fcE8A03a25F1d20E119407f8e7',\n  RedeemerEnforcer: '0x926672b130D1EF60A9d6b11D2048d121b30f40C1',\n} as const;\n\nexport const deployments_1_0_0 = {\n  DelegationManager: '0xbe4138886cb096bdc1b930f2f0ca7892aa234d78',\n  EntryPoint: '0x0000000071727De22E5E9d8BAf0edAc6f37da032',\n  SimpleFactory: '0x6ff518884f21168c30c58CB21184D6AdBC18Ad90',\n  // Implementations\n  MultiSigDeleGatorImpl: '0x11f555af5844d85bfcf5d61d2a22866527eb585a',\n  HybridDeleGatorImpl: '0xd6edd1256deccb2b06bdecef92dc16bcf26e531b',\n  // Caveat Enforcers\n  AllowedCalldataEnforcer: '0x48db3835a873d64a4af2c09f014052407c003bd7',\n  AllowedMethodsEnforcer: '0xfd731951bf1c52afccee3e6f14ab656475b76dd4',\n  AllowedTargetsEnforcer: '0xbc8673c0afa52d86d991c06881e55b2966920564',\n  BlockNumberEnforcer: '0xc15faffa0d879b9263c15a46ce31eacfa2e0e8ae',\n  DeployedEnforcer: '0x5accb9559b56a6c1e3f90e342c85c42d93720d43',\n  ERC20BalanceGteEnforcer: '0xb5d6b1ec6d868a3bae5b7f48178eaa2686a7a087',\n  ERC20TransferAmountEnforcer: '0x92ac423b9c111962179a6242e1adb58d02c103be',\n  IdEnforcer: '0x34152d9f3f8f74338d50703e780389e829b4abac',\n  LimitedCallsEnforcer: '0x4b3adad4a328bee8ba17b86074d92fe7372180cd',\n  NonceEnforcer: '0x2f32ff3fc3086d7f63f16fe8d0065390d460b40d',\n  TimestampEnforcer: '0x78e05f779490c24bf3bfa135b4112e7003b321cd',\n  ValueLteEnforcer: '0xfc20ede0a1132e839fbda9d7ed3904ff3c89540f',\n} as const;\n", "import {\n  deployments_1_3_0,\n  deployments_1_1_0,\n  deployments_1_0_0,\n} from './contractAddresses';\n\nexport const CHAIN_ID = {\n  // Mainnets\n  mainnet: 1,\n  optimism: 10,\n  bsc: 56,\n  gnosis: 100,\n  polygon: 137,\n  base: 8453,\n  arbitrum: 42161,\n  linea: 59144,\n  berachain: 80094,\n  unichain: 130,\n  arbitrumNova: 42170,\n  // Testnets\n  bscTestnet: 97,\n  megaEthTestnet: 6342,\n  chiado: 10200,\n  lineaSepolia: 59141,\n  berachainBepolia: 80069,\n  baseSepolia: 84532,\n  arbitrumSepolia: 421614,\n  sepolia: 11155111,\n  optimismSepolia: 11155420,\n  unichainSepolia: 1301,\n  polygonAmoy: 80002,\n  monadTestnet: 10143,\n  // decommissioned\n  lineaGoerli: 59140,\n};\n\ntype DeployedContracts = Record<\n  string,\n  Record<number, Record<string, `0x${string}`>>\n>;\n\nexport const DELEGATOR_CONTRACTS: DeployedContracts = {\n  '1.0.0': {\n    // Mainnets\n    [CHAIN_ID.optimism]: deployments_1_0_0,\n    [CHAIN_ID.polygon]: deployments_1_0_0,\n    [CHAIN_ID.base]: deployments_1_0_0,\n    [CHAIN_ID.arbitrum]: deployments_1_0_0,\n    [CHAIN_ID.linea]: deployments_1_0_0,\n    // Testnets\n    [CHAIN_ID.sepolia]: {\n      ...deployments_1_0_0,\n      HybridDeleGatorImpl: '0x5989F5D13DF8fc818EdA65e417AED90459fD67F7',\n    },\n    [CHAIN_ID.lineaSepolia]: {\n      ...deployments_1_0_0,\n      HybridDeleGatorImpl: '0x5989F5D13DF8fc818EdA65e417AED90459fD67F7',\n    },\n  },\n  '1.1.0': {\n    // Mainnets\n    [CHAIN_ID.arbitrum]: deployments_1_1_0,\n    [CHAIN_ID.base]: deployments_1_1_0,\n    [CHAIN_ID.linea]: deployments_1_1_0,\n    [CHAIN_ID.optimism]: deployments_1_1_0,\n    [CHAIN_ID.polygon]: deployments_1_1_0,\n    // Testnets\n    [CHAIN_ID.sepolia]: deployments_1_1_0,\n    [CHAIN_ID.lineaSepolia]: deployments_1_1_0,\n    [CHAIN_ID.baseSepolia]: {\n      ...deployments_1_1_0,\n      SimpleFactory: '0xE8eA1DE8D6AfE400B7C8C1A81B7C29B7876b4d02',\n    },\n  },\n  '1.3.0': {\n    // Mainnets\n    [CHAIN_ID.mainnet]: deployments_1_3_0,\n    [CHAIN_ID.polygon]: deployments_1_3_0,\n    [CHAIN_ID.bsc]: deployments_1_3_0,\n    [CHAIN_ID.optimism]: deployments_1_3_0,\n    [CHAIN_ID.arbitrum]: deployments_1_3_0,\n    [CHAIN_ID.linea]: deployments_1_3_0,\n    [CHAIN_ID.base]: deployments_1_3_0,\n    [CHAIN_ID.gnosis]: deployments_1_3_0,\n    [CHAIN_ID.berachain]: deployments_1_3_0,\n    [CHAIN_ID.unichain]: deployments_1_3_0,\n    [CHAIN_ID.arbitrumNova]: deployments_1_3_0,\n    // Testnets\n    [CHAIN_ID.sepolia]: deployments_1_3_0,\n    [CHAIN_ID.lineaSepolia]: deployments_1_3_0,\n    [CHAIN_ID.baseSepolia]: deployments_1_3_0,\n    [CHAIN_ID.megaEthTestnet]: deployments_1_3_0,\n    [CHAIN_ID.chiado]: deployments_1_3_0,\n    [CHAIN_ID.bscTestnet]: deployments_1_3_0,\n    [CHAIN_ID.optimismSepolia]: deployments_1_3_0,\n    [CHAIN_ID.arbitrumSepolia]: deployments_1_3_0,\n    [CHAIN_ID.berachainBepolia]: deployments_1_3_0,\n    [CHAIN_ID.unichainSepolia]: deployments_1_3_0,\n    [CHAIN_ID.polygonAmoy]: deployments_1_3_0,\n    [CHAIN_ID.monadTestnet]: deployments_1_3_0,\n  },\n};\n", "import { SimpleFactory, DelegationManager } from '@metamask/delegation-abis';\nimport type { Address, Chain, Hex, PublicClient, WalletClient } from 'viem';\n\nimport { encodePermissionContexts } from './delegation';\nimport type { ExecutionStruct, ExecutionMode } from './executions';\nimport { encodeExecutionCalldatas } from './executions';\nimport type { Delegation, ContractMetaData, Redemption } from './types';\n\n/**\n * Deploys a contract using the SimpleFactory contract.\n * @param walletClient - The wallet client to use for deployment.\n * @param publicClient - The public client to use for simulation.\n * @param simpleFactoryAddress - The address of the SimpleFactory contract.\n * @param creationCode - The creation code for the contract to deploy.\n * @param salt - The salt to use for deterministic deployment.\n * @returns The transaction hash of the deployment.\n */\nexport const deployWithSimpleFactory = async (\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  simpleFactoryAddress: Address,\n  creationCode: Hex,\n  salt: Hex,\n) => {\n  const { request } = await publicClient.simulateContract({\n    account: walletClient.account,\n    address: simpleFactoryAddress,\n    abi: SimpleFactory.abi,\n    functionName: 'deploy',\n    args: [creationCode, salt],\n  });\n  return await walletClient.writeContract(request);\n};\n\n/**\n * Redeems a delegation to execute the provided executions.\n * @param walletClient - The wallet client to use for redemption.\n * @param publicClient - The public client to use for simulation.\n * @param delegationManagerAddress - The address of the DelegationManager contract.\n * @param redemptions - The redemptions to execute, containing permission contexts, executions, and modes.\n * @returns The transaction hash of the redemption.\n */\nexport const redeemDelegations = async (\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  delegationManagerAddress: Address,\n  redemptions: Redemption[],\n) => {\n  if (redemptions.length === 0) {\n    throw new Error('RedeemDelegations invalid zero redemptions');\n  }\n\n  const permissionContexts: Delegation[][] = [];\n  const executionsBatch: ExecutionStruct[][] = [];\n  const executionModes: ExecutionMode[] = [];\n\n  redemptions.forEach((redemption) => {\n    permissionContexts.push(redemption.permissionContext);\n    executionsBatch.push(redemption.executions);\n    executionModes.push(redemption.mode);\n  });\n\n  const encodedPermissionContexts =\n    encodePermissionContexts(permissionContexts);\n  const executionCalldatas = encodeExecutionCalldatas(executionsBatch);\n\n  const { request } = await publicClient.simulateContract({\n    account: walletClient.account,\n    address: delegationManagerAddress,\n    abi: DelegationManager.abi,\n    functionName: 'redeemDelegations',\n    args: [encodedPermissionContexts, executionModes, executionCalldatas],\n  });\n  return await walletClient.writeContract(request);\n};\n\n/**\n * Deploys a contract to the blockchain.\n * @param walletClient - The wallet client to use for deployment.\n * @param publicClient - The public client to use for transaction receipt.\n * @param chain - The chain to deploy on.\n * @param contractMetadata - The metadata of the contract to deploy.\n * @param contractMetadata.bytecode - The bytecode of the contract to deploy.\n * @param contractMetadata.abi - The ABI of the contract to deploy.\n * @param args - The constructor arguments for the contract.\n * @returns An object containing the deployed contract address, transaction hash, and receipt.\n */\nexport async function deployContract(\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  chain: Chain,\n  { bytecode, abi }: ContractMetaData,\n  args: any[] = [],\n) {\n  if (!walletClient.account) {\n    throw new Error('Wallet client account is required');\n  }\n\n  const hash = await walletClient.deployContract({\n    abi,\n    bytecode,\n    args,\n    account: walletClient.account,\n    chain,\n  });\n\n  const receipt = await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  if (!receipt.contractAddress) {\n    throw new Error('No contract address in receipt');\n  }\n\n  return { address: receipt.contractAddress, hash, receipt };\n}\n", "import {\n  EntryPoint,\n  SimpleFactory,\n  DelegationManager,\n  MultiSigDeleGator,\n  HybridDeleGator,\n  EIP7702StatelessDeleGator,\n  SCL_RIP7212,\n  AllowedTargetsEnforcer,\n  AllowedMethodsEnforcer,\n  DeployedEnforcer,\n  TimestampEnforcer,\n  NonceEnforcer,\n  AllowedCalldataEnforcer,\n  BlockNumberEnforcer,\n  LimitedCallsEnforcer,\n  ERC20BalanceChangeEnforcer,\n  ERC20StreamingEnforcer,\n  IdEnforcer,\n  ERC20TransferAmountEnforcer,\n  ValueLteEnforcer,\n  NativeTokenTransferAmountEnforcer,\n  NativeBalanceChangeEnforcer,\n  NativeTokenStreamingEnforcer,\n  NativeTokenPaymentEnforcer,\n  RedeemerEnforcer,\n  ArgsEqualityCheckEnforcer,\n  ERC721BalanceChangeEnforcer,\n  ERC721TransferEnforcer,\n  ERC1155BalanceChangeEnforcer,\n  OwnershipTransferEnforcer,\n  SpecificActionERC20TransferBatchEnforcer,\n  ERC20PeriodTransferEnforcer,\n  NativeTokenPeriodTransferEnforcer,\n  ExactCalldataBatchEnforcer,\n  ExactCalldataEnforcer,\n  ExactExecutionEnforcer,\n  ExactExecutionBatchEnforcer,\n  MultiTokenPeriodEnforcer,\n} from '@metamask/delegation-abis';\nimport { DELEGATOR_CONTRACTS } from '@metamask/delegation-deployments';\nimport type { Chain, Hex, PublicClient, WalletClient } from 'viem';\n\nimport type { ContractMetaData, DeleGatorEnvironment } from './types';\nimport { deployContract } from './write';\n\ntype SupportedVersion = '1.0.0' | '1.1.0' | '1.2.0' | '1.3.0';\nexport const PREFERRED_VERSION: SupportedVersion = '1.3.0';\n\nconst contractOverrideMap: Map<string, DeleGatorEnvironment> = new Map();\n\nconst getContractOverrideKey = (chainId: number, version: SupportedVersion) =>\n  `${version}:${chainId}`;\n\n/**\n * Overrides the deployed environment for a specific chain and version.\n * @param chainId - The chain ID to override.\n * @param version - The version of the environment to override.\n * @param environment - The environment to use as override.\n */\nexport function overrideDeployedEnvironment(\n  chainId: number,\n  version: SupportedVersion,\n  environment: DeleGatorEnvironment,\n) {\n  contractOverrideMap.set(\n    getContractOverrideKey(chainId, version),\n    environment,\n  );\n}\n\n/**\n * Gets the DeleGator environment for the specified chain and version.\n * @param chainId - The chain ID to get the environment for.\n * @param version - The version of the environment to get.\n * @returns The DeleGator environment.\n */\nexport function getDeleGatorEnvironment(\n  chainId: number,\n  version: SupportedVersion = PREFERRED_VERSION,\n): DeleGatorEnvironment {\n  const overrideKey = getContractOverrideKey(chainId, version);\n\n  const overriddenContracts = contractOverrideMap.get(overrideKey);\n  if (overriddenContracts) {\n    return overriddenContracts;\n  }\n\n  const contracts = DELEGATOR_CONTRACTS[version]?.[chainId];\n  if (!contracts) {\n    throw new Error(\n      `No contracts found for version ${version} chain ${chainId}`,\n    );\n  }\n  return getDeleGatorEnvironmentV1(contracts);\n}\n\n/**\n * Creates a DeleGator environment from contract addresses.\n * @param contracts - The contract addresses to create the environment from.\n * @returns The created DeleGator environment.\n */\nexport function getDeleGatorEnvironmentV1(contracts: {\n  [contract: string]: Hex;\n}) {\n  return {\n    DelegationManager: contracts.DelegationManager,\n    EntryPoint: contracts.EntryPoint,\n    SimpleFactory: contracts.SimpleFactory,\n    implementations: {\n      MultiSigDeleGatorImpl: contracts.MultiSigDeleGatorImpl,\n      HybridDeleGatorImpl: contracts.HybridDeleGatorImpl,\n      EIP7702StatelessDeleGatorImpl: contracts.EIP7702StatelessDeleGatorImpl,\n    },\n    caveatEnforcers: {\n      AllowedCalldataEnforcer: contracts.AllowedCalldataEnforcer,\n      AllowedMethodsEnforcer: contracts.AllowedMethodsEnforcer,\n      AllowedTargetsEnforcer: contracts.AllowedTargetsEnforcer,\n      ArgsEqualityCheckEnforcer: contracts.ArgsEqualityCheckEnforcer,\n      BlockNumberEnforcer: contracts.BlockNumberEnforcer,\n      DeployedEnforcer: contracts.DeployedEnforcer,\n      ERC20BalanceChangeEnforcer: contracts.ERC20BalanceChangeEnforcer,\n      ERC20TransferAmountEnforcer: contracts.ERC20TransferAmountEnforcer,\n      ERC20StreamingEnforcer: contracts.ERC20StreamingEnforcer,\n      ERC721BalanceChangeEnforcer: contracts.ERC721BalanceChangeEnforcer,\n      ERC721TransferEnforcer: contracts.ERC721TransferEnforcer,\n      ERC1155BalanceChangeEnforcer: contracts.ERC1155BalanceChangeEnforcer,\n      IdEnforcer: contracts.IdEnforcer,\n      LimitedCallsEnforcer: contracts.LimitedCallsEnforcer,\n      NonceEnforcer: contracts.NonceEnforcer,\n      TimestampEnforcer: contracts.TimestampEnforcer,\n      ValueLteEnforcer: contracts.ValueLteEnforcer,\n      NativeTokenTransferAmountEnforcer:\n        contracts.NativeTokenTransferAmountEnforcer,\n      NativeBalanceChangeEnforcer: contracts.NativeBalanceChangeEnforcer,\n      NativeTokenStreamingEnforcer: contracts.NativeTokenStreamingEnforcer,\n      NativeTokenPaymentEnforcer: contracts.NativeTokenPaymentEnforcer,\n      OwnershipTransferEnforcer: contracts.OwnershipTransferEnforcer,\n      RedeemerEnforcer: contracts.RedeemerEnforcer,\n      SpecificActionERC20TransferBatchEnforcer:\n        contracts.SpecificActionERC20TransferBatchEnforcer,\n      ERC20PeriodTransferEnforcer: contracts.ERC20PeriodTransferEnforcer,\n      NativeTokenPeriodTransferEnforcer:\n        contracts.NativeTokenPeriodTransferEnforcer,\n      ExactCalldataBatchEnforcer: contracts.ExactCalldataBatchEnforcer,\n      ExactCalldataEnforcer: contracts.ExactCalldataEnforcer,\n      ExactExecutionEnforcer: contracts.ExactExecutionEnforcer,\n      ExactExecutionBatchEnforcer: contracts.ExactExecutionBatchEnforcer,\n      MultiTokenPeriodEnforcer: contracts.MultiTokenPeriodEnforcer,\n    },\n  } as DeleGatorEnvironment;\n}\n\nexport type DeployedContract = {\n  name: string;\n  address: string;\n};\n\n/**\n * Deploys the contracts needed for the Delegation Framework and DeleGator SCA to be functional as well as all Caveat Enforcers.\n * @param walletClient - The wallet client to use for deployment.\n * @param publicClient - The public client to use for deployment.\n * @param chain - The chain to deploy to.\n * @param deployedContracts - Optional map of already deployed contracts.\n * @returns A promise that resolves when all contracts are deployed.\n */\nexport async function deployDeleGatorEnvironment(\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  chain: Chain,\n  deployedContracts: { [contract: string]: Hex } = {},\n) {\n  const deployContractCurried = async (\n    name: string,\n    contract: ContractMetaData,\n    params: any[] = [],\n  ) => {\n    const existingAddress = deployedContracts[name];\n    if (existingAddress) {\n      return {\n        address: existingAddress,\n        name,\n      };\n    }\n\n    const deployedContract = await deployContract(\n      walletClient,\n      publicClient,\n      chain,\n      contract,\n      params,\n    );\n\n    const newDeployedContracts = { ...deployedContracts };\n    newDeployedContracts[name] = deployedContract.address;\n    Object.assign(deployedContracts, newDeployedContracts);\n\n    return { ...deployedContract, name };\n  };\n\n  // Deploy v1.3.0 DeleGator contracts\n  // - deploy standalone contracts\n  const standaloneContracts = {\n    SimpleFactory,\n    AllowedCalldataEnforcer,\n    AllowedTargetsEnforcer,\n    AllowedMethodsEnforcer,\n    ArgsEqualityCheckEnforcer,\n    DeployedEnforcer,\n    TimestampEnforcer,\n    BlockNumberEnforcer,\n    LimitedCallsEnforcer,\n    ERC20BalanceChangeEnforcer,\n    ERC20TransferAmountEnforcer,\n    ERC20StreamingEnforcer,\n    ERC721BalanceChangeEnforcer,\n    ERC721TransferEnforcer,\n    ERC1155BalanceChangeEnforcer,\n    IdEnforcer,\n    NonceEnforcer,\n    ValueLteEnforcer,\n    NativeTokenTransferAmountEnforcer,\n    NativeBalanceChangeEnforcer,\n    NativeTokenStreamingEnforcer,\n    OwnershipTransferEnforcer,\n    RedeemerEnforcer,\n    SpecificActionERC20TransferBatchEnforcer,\n    ERC20PeriodTransferEnforcer,\n    NativeTokenPeriodTransferEnforcer,\n    ExactCalldataBatchEnforcer,\n    ExactCalldataEnforcer,\n    ExactExecutionEnforcer,\n    ExactExecutionBatchEnforcer,\n    MultiTokenPeriodEnforcer,\n  };\n  for (const [name, contract] of Object.entries(standaloneContracts)) {\n    await deployContractCurried(name, contract);\n  }\n\n  // - deploy dependencies\n  const delegationManager = await deployContractCurried(\n    'DelegationManager',\n    DelegationManager,\n    [walletClient.account?.address],\n  );\n\n  // - NativeTokenPaymentEnforcer DelegationManager and ArgsEqualityCheckEnforcer as constructor args\n  await deployContractCurried(\n    'NativeTokenPaymentEnforcer',\n    NativeTokenPaymentEnforcer,\n    [delegationManager.address, deployedContracts.ArgsEqualityCheckEnforcer],\n  );\n\n  const entryPoint = await deployContractCurried('EntryPoint', EntryPoint);\n\n  // This is a hack to work around the SCL_RIP7212 being deployed as a library.\n  // Forge handles this gracefully, but in the tests we need to manually link\n  // the library.\n  // We don't use the curried function here because we don't need it added to\n  // the environment.\n  const { address: sclRIP7212 } = await deployContract(\n    walletClient,\n    publicClient,\n    chain,\n    SCL_RIP7212,\n    [],\n  );\n\n  // replace linked library address in bytecode https://docs.soliditylang.org/en/latest/using-the-compiler.html#library-linking\n  const hybridDeleGatorWithLinkedLibrary = {\n    ...HybridDeleGator,\n    bytecode: HybridDeleGator.bytecode.replace(\n      /__\\$b8f96b288d4d0429e38b8ed50fd423070f\\$__/gu,\n      sclRIP7212.slice(2),\n    ) as Hex,\n  };\n\n  // - deploy DeleGator implementations\n  await deployContractCurried(\n    'HybridDeleGatorImpl',\n    hybridDeleGatorWithLinkedLibrary,\n    [delegationManager.address, entryPoint.address],\n  );\n\n  await deployContractCurried('MultiSigDeleGatorImpl', MultiSigDeleGator, [\n    delegationManager.address,\n    entryPoint.address,\n  ]);\n\n  await deployContractCurried(\n    'EIP7702StatelessDeleGatorImpl',\n    EIP7702StatelessDeleGator,\n    [delegationManager.address, entryPoint.address],\n  );\n\n  // Format deployments\n  return getDeleGatorEnvironmentV1(deployedContracts);\n}\n", "import {\n  EIP7702StatelessDeleGator,\n  HybridDeleGator,\n  MultiSigDeleGator,\n} from '@metamask/delegation-abis';\nimport { type Address, type Hex } from 'viem';\nimport {\n  entryPoint07Abi,\n  toPackedUserOperation,\n  toSmartAccount,\n} from 'viem/account-abstraction';\n\nimport { isValid7702Implementation } from './actions/isValid7702Implementation';\nimport { Implementation } from './constants';\nimport { getCounterfactualAccountData } from './counterfactualAccountData';\nimport {\n  SIGNABLE_DELEGATION_TYPED_DATA,\n  toDelegationStruct,\n} from './delegation';\nimport { entryPointGetNonce as _getNonce } from './DelegationFramework/EntryPoint/read';\nimport { getDeleGatorEnvironment } from './delegatorEnvironment';\nimport { encodeCallsForCaller } from './encodeCalls';\nimport { resolveSigner } from './signer';\nimport type {\n  Call,\n  ToMetaMaskSmartAccountParameters,\n  ToMetaMaskSmartAccountReturnType,\n  SignDelegationParams,\n  SignUserOperationParams,\n  AbiByImplementation,\n} from './types';\nimport { SIGNABLE_USER_OP_TYPED_DATA } from './userOp';\n\nconst ENTRYPOINT_VERSION = '0.7' as const;\n\n/**\n * Creates a MetaMask DeleGator smart account instance.\n *\n * @template TImplementation - The type of implementation, extending Implementation.\n * @param params - The parameters for creating the smart account.\n * @returns A promise that resolves to a MetaMask DeleGator smart account instance.\n * @description\n * This function sets up a MetaMask DeleGator smart account with the specified implementation.\n * It handles both deployed accounts, and counterfactual accounts.\n * A caller may specify a DeleGator environment, otherwise the environment will be inferred from the chain.\n */\nexport async function toMetaMaskSmartAccount<\n  TImplementation extends Implementation,\n>(\n  params: ToMetaMaskSmartAccountParameters<TImplementation>,\n): Promise<ToMetaMaskSmartAccountReturnType<TImplementation>> {\n  const {\n    client,\n    client: { chain },\n    implementation,\n  } = params;\n\n  if (!chain) {\n    throw new Error('Chain not specified');\n  }\n\n  const signer = resolveSigner({\n    implementation,\n    signer: params.signer,\n  });\n\n  const environment = params.environment ?? getDeleGatorEnvironment(chain.id);\n\n  let address: Address, factoryData: Hex | undefined;\n\n  if (params.address) {\n    factoryData = undefined;\n    address = params.address;\n  } else {\n    if (implementation === Implementation.Stateless7702) {\n      throw new Error('Stateless7702 does not support counterfactual accounts');\n    }\n\n    const accountData = await getCounterfactualAccountData({\n      factory: environment.SimpleFactory,\n      implementations: environment.implementations,\n      implementation,\n      deployParams: params.deployParams,\n      deploySalt: params.deploySalt,\n    });\n\n    address = accountData.address;\n    factoryData = accountData.factoryData;\n  }\n\n  const entryPoint = {\n    abi: entryPoint07Abi,\n    address: environment.EntryPoint,\n    version: ENTRYPOINT_VERSION,\n  } as const;\n\n  const { abi, contractName } = {\n    [Implementation.Hybrid]: {\n      contractName: 'HybridDeleGator',\n      abi: HybridDeleGator.abi,\n    },\n    [Implementation.MultiSig]: {\n      contractName: 'MultiSigDeleGator',\n      abi: MultiSigDeleGator.abi,\n    },\n    [Implementation.Stateless7702]: {\n      contractName: 'EIP7702StatelessDeleGator',\n      abi: EIP7702StatelessDeleGator.abi,\n    },\n  }[implementation] as {\n    contractName: string;\n    abi: AbiByImplementation[TImplementation];\n  };\n\n  const getFactoryArgs = async () => {\n    if (factoryData === undefined) {\n      throw new Error(\n        'Deploy params were not provided, so factory args cannot be inferred',\n      );\n    }\n    return {\n      factoryData,\n      factory: environment.SimpleFactory,\n    };\n  };\n\n  const signDelegation = async (delegationParams: SignDelegationParams) => {\n    const { delegation, chainId } = delegationParams;\n\n    const delegationStruct = toDelegationStruct({\n      ...delegation,\n      signature: '0x',\n    });\n\n    const signature = signer.signTypedData({\n      domain: {\n        chainId: chainId ?? chain.id,\n        name: 'DelegationManager',\n        version: '1',\n        verifyingContract: environment.DelegationManager,\n      },\n      types: SIGNABLE_DELEGATION_TYPED_DATA,\n      primaryType: 'Delegation',\n      message: delegationStruct,\n    });\n\n    return signature;\n  };\n\n  const signUserOperation = async (userOpParams: SignUserOperationParams) => {\n    const { chainId } = userOpParams;\n\n    const packedUserOp = toPackedUserOperation({\n      sender: address,\n      ...userOpParams,\n      signature: '0x',\n    });\n\n    const signature = await signer.signTypedData({\n      domain: {\n        chainId: chainId ?? chain.id,\n        name: contractName,\n        version: '1',\n        verifyingContract: address,\n      },\n      types: SIGNABLE_USER_OP_TYPED_DATA,\n      primaryType: 'PackedUserOperation',\n      message: { ...packedUserOp, entryPoint: entryPoint.address },\n    });\n\n    return signature;\n  };\n\n  const getAddress = async () => address;\n\n  const getNonce = async () =>\n    _getNonce({\n      client,\n      entryPoint: environment.EntryPoint,\n      contractAddress: address,\n      key: 0n,\n    });\n\n  const encodeCalls = async (calls: readonly Call[]) =>\n    encodeCallsForCaller(address, calls);\n\n  const smartAccount = await toSmartAccount({\n    abi,\n    client,\n    entryPoint,\n    environment,\n    getAddress,\n    getFactoryArgs,\n    encodeCalls,\n    getNonce,\n    signUserOperation,\n    signDelegation,\n    ...signer,\n  });\n\n  // Override isDeployed only for EIP-7702 implementation to check proper delegation code\n  if (implementation === Implementation.Stateless7702) {\n    return {\n      ...smartAccount,\n      isDeployed: async () =>\n        isValid7702Implementation({\n          client,\n          accountAddress: address,\n          environment,\n        }),\n    };\n  }\n\n  // For other implementations, use the default isDeployed behavior\n  return smartAccount;\n}\n", "import { concat } from 'viem';\nimport type {\n  Address,\n  SignableMessage,\n  TypedData,\n  TypedDataDefinition,\n} from 'viem';\nimport type { SignReturnType as WebAuthnSignReturnType } from 'webauthn-p256';\n\nimport { Implementation } from './constants';\nimport { aggregateSignature } from './signatures';\nimport type {\n  AccountSignerConfig,\n  HybridSignerConfig,\n  InternalSigner,\n  MultiSigSignerConfig,\n  SignerConfigByImplementation,\n  Stateless7702SignerConfig,\n  WalletSignerConfig,\n} from './types';\nimport {\n  createDummyWebAuthnSignature,\n  encodeDeleGatorSignature,\n} from './webAuthn';\n\n// A valid ECDSA signature, this must be able to ecrecover an address, otherwise the contracts will revert in isValidSignature\nconst EOA_STUB_SIGNATURE =\n  '0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000011b' as const;\n\nconst resolveSignerFromWalletConfig = (\n  config: WalletSignerConfig,\n): InternalSigner => {\n  return {\n    signMessage: config.walletClient.signMessage,\n    signTypedData: async (typedData) => {\n      // todo: figure out this type so that we don't need the type assertion\n      return config.walletClient.signTypedData(typedData as any);\n    },\n    getStubSignature: async () => EOA_STUB_SIGNATURE,\n  };\n};\n\nconst resolveSignerFromAccountConfig = (config: AccountSignerConfig) => {\n  return {\n    signMessage: config.account.signMessage,\n    signTypedData: config.account.signTypedData,\n    getStubSignature: async () => EOA_STUB_SIGNATURE,\n  };\n};\n\nconst resolveHybridSigner = (config: HybridSignerConfig): InternalSigner => {\n  if ('walletClient' in config) {\n    return resolveSignerFromWalletConfig(config);\n  } else if ('account' in config) {\n    const { signMessage, signTypedData, getStubSignature } =\n      resolveSignerFromAccountConfig(config);\n    if (!signMessage) {\n      throw new Error('Account does not support signMessage');\n    }\n    if (!signTypedData) {\n      throw new Error('Account does not support signTypedData');\n    }\n    return {\n      signMessage,\n      signTypedData,\n      getStubSignature,\n    };\n  }\n  const { keyId, webAuthnAccount } = config;\n\n  if (webAuthnAccount.type !== 'webAuthn') {\n    throw new Error('Account is not a webAuthn account');\n  }\n\n  const encodeSignature = ({ signature, webauthn }: WebAuthnSignReturnType) =>\n    encodeDeleGatorSignature(\n      keyId,\n      signature,\n      webauthn.clientDataJSON,\n      webauthn.authenticatorData,\n    );\n\n  const signMessage = async (args: { message: SignableMessage }) =>\n    webAuthnAccount.signMessage(args).then(encodeSignature);\n  const signTypedData = async <\n    const TTypedData extends TypedData | Record<string, unknown>,\n    TPrimaryType extends keyof TTypedData | 'EIP712Domain' = keyof TTypedData,\n  >(\n    typedDataDefinition: TypedDataDefinition<TTypedData, TPrimaryType>,\n  ) => webAuthnAccount.signTypedData(typedDataDefinition).then(encodeSignature);\n\n  const getStubSignature = async () => createDummyWebAuthnSignature(keyId);\n\n  return {\n    signMessage,\n    signTypedData,\n    getStubSignature,\n  };\n};\n\nconst resolveMultiSigSigner = (\n  config: MultiSigSignerConfig,\n): InternalSigner => {\n  const resolvedSigners = config.map((signer) => {\n    let individualSignMessage: InternalSigner['signMessage'];\n    let individualSignTypedData: InternalSigner['signTypedData'];\n    let address: Address;\n    if ('walletClient' in signer) {\n      const { signMessage, signTypedData } =\n        resolveSignerFromWalletConfig(signer);\n      individualSignMessage = signMessage;\n      individualSignTypedData = signTypedData;\n\n      address = signer.walletClient.account.address;\n    } else {\n      const { signMessage, signTypedData } =\n        resolveSignerFromAccountConfig(signer);\n      if (!signMessage) {\n        throw new Error('Account does not support signMessage');\n      }\n      if (!signTypedData) {\n        throw new Error('Account does not support signTypedData');\n      }\n\n      individualSignMessage = signMessage;\n      individualSignTypedData = signTypedData;\n\n      address = signer.account.address;\n    }\n    return {\n      address,\n      individualSignMessage,\n      individualSignTypedData,\n    };\n  });\n\n  const signMessage = async (args: { message: SignableMessage }) => {\n    const addressAndSignatures = resolvedSigners.map(\n      async ({ individualSignMessage, address }) => ({\n        signature: await individualSignMessage(args),\n        signer: address,\n        type: 'ECDSA' as const,\n      }),\n    );\n\n    const signatures = await Promise.all(addressAndSignatures);\n\n    return aggregateSignature({\n      signatures,\n    });\n  };\n\n  const signTypedData = async <\n    const TTypedData extends TypedData | Record<string, unknown>,\n    TPrimaryType extends keyof TTypedData | 'EIP712Domain' = keyof TTypedData,\n  >(\n    typedDataDefinition: TypedDataDefinition<TTypedData, TPrimaryType>,\n  ) => {\n    const addressAndSignatures = resolvedSigners.map(\n      async ({ individualSignTypedData, address }) => ({\n        signature: await individualSignTypedData(typedDataDefinition),\n        signer: address,\n        type: 'ECDSA' as const,\n      }),\n    );\n\n    const signatures = await Promise.all(addressAndSignatures);\n\n    return aggregateSignature({\n      signatures,\n    });\n  };\n\n  const getStubSignature = async () =>\n    concat(resolvedSigners.map(() => EOA_STUB_SIGNATURE));\n\n  return {\n    signMessage,\n    signTypedData,\n    getStubSignature,\n  };\n};\n\nconst resolveStateless7702Signer = (\n  config: Stateless7702SignerConfig,\n): InternalSigner => {\n  if ('walletClient' in config) {\n    return resolveSignerFromWalletConfig(config);\n  } else if ('account' in config) {\n    const { signMessage, signTypedData, getStubSignature } =\n      resolveSignerFromAccountConfig(config);\n    if (!signMessage) {\n      throw new Error('Account does not support signMessage');\n    }\n    if (!signTypedData) {\n      throw new Error('Account does not support signTypedData');\n    }\n\n    return {\n      signMessage,\n      signTypedData,\n      getStubSignature,\n    };\n  }\n\n  throw new Error('Invalid signer config');\n};\n\nexport const resolveSigner = <TImplementation extends Implementation>(config: {\n  implementation: TImplementation;\n  signer: SignerConfigByImplementation<TImplementation>;\n}): InternalSigner => {\n  const { implementation } = config;\n\n  if (implementation === Implementation.Hybrid) {\n    return resolveHybridSigner(config.signer as HybridSignerConfig);\n  } else if (implementation === Implementation.MultiSig) {\n    return resolveMultiSigSigner(config.signer as MultiSigSignerConfig);\n  } else if (implementation === Implementation.Stateless7702) {\n    return resolveStateless7702Signer(\n      config.signer as Stateless7702SignerConfig,\n    );\n  }\n  throw new Error(`Implementation type '${implementation}' not supported`);\n};\n", "import type { Address, Hex } from 'viem';\nimport { concat } from 'viem';\n\nconst signatureTypes = ['ECDSA'] as const;\n\nexport type SignatureType = (typeof signatureTypes)[number];\n\n/**\n * Represents a partial signature that can be aggregated with others.\n */\nexport type PartialSignature = {\n  signer: Address;\n  signature: Hex;\n  type: SignatureType;\n};\n\n/**\n * Aggregates signatures into a single signature as expected by the MultiSig implementation.\n * @param params - The parameters for signature aggregation.\n * @param params.signatures - The array of partial signatures to aggregate.\n * @returns The aggregated signature.\n */\nexport const aggregateSignature = ({\n  signatures,\n}: {\n  signatures: PartialSignature[];\n}): Hex => {\n  if (signatures.length === 0) {\n    return '0x';\n  }\n\n  for (const { type } of signatures) {\n    if (!signatureTypes.includes(type)) {\n      throw new Error(`Invalid signature type: ${type}`);\n    }\n  }\n\n  // Sort signatures by signer address as required by MultiSig implementation\n  const sortedSignatures = [...signatures].sort((a, b) =>\n    a.signer.localeCompare(b.signer),\n  );\n\n  // Concatenate all signatures\n  return concat(sortedSignatures.map(({ signature }) => signature));\n};\n\n/**\n * Type definition for the aggregateSignature function parameters.\n */\nexport type AggregateSignatureParams = {\n  signatures: PartialSignature[];\n};\n", "import type { Client, Transport, Chain, Account } from 'viem';\n\nimport type { DeleGatorEnvironment } from '../types';\nimport {\n  caveatEnforcerActions,\n  type CaveatEnforcerParams,\n  type PeriodTransferResult,\n  type StreamingResult,\n} from './getCaveatAvailableAmount';\n\n/**\n * Type for client extended with caveat enforcer actions.\n */\nexport type CaveatEnforcerClient<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n> = Client<TTransport, TChain, TAccount> &\n  ReturnType<ReturnType<typeof caveatEnforcerActions>>;\n\n/**\n * Create a viem client extended with caveat enforcer actions.\n *\n * @param params - The parameters object.\n * @param params.client - The viem client.\n * @param params.environment - The delegator environment.\n * @returns The extended client with caveat enforcer actions.\n */\nexport function createCaveatEnforcerClient<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n>({\n  client,\n  environment,\n}: {\n  client: Client<TTransport, TChain, TAccount>;\n  environment: DeleGatorEnvironment;\n}): CaveatEnforcerClient<TTransport, TChain, TAccount> {\n  return client.extend(caveatEnforcerActions({ environment }));\n}\n\n// Re-export types for convenience\nexport type { CaveatEnforcerParams, PeriodTransferResult, StreamingResult };\n", "import type { Transport, Chain, Hex, Client, Account } from 'viem';\nimport {\n  createBundlerClient,\n  type BundlerClient,\n  type BundlerClientConfig,\n  type SmartAccount,\n} from 'viem/account-abstraction';\n\n/**\n * Gas price tiers returned by pimlico_getUserOperationGasPrice\n */\nexport type GasPriceTier = {\n  /** Maximum fee per gas in hex format */\n  maxFeePerGas: Hex;\n  /** Maximum priority fee per gas in hex format */\n  maxPriorityFeePerGas: Hex;\n};\n\n/**\n * Response from pimlico_getUserOperationGasPrice RPC method\n */\nexport type UserOperationGasPriceResponse = {\n  /** Slow gas price tier */\n  slow: GasPriceTier;\n  /** Standard gas price tier */\n  standard: GasPriceTier;\n  /** Fast gas price tier */\n  fast: GasPriceTier;\n};\n\n/**\n * Pimlico bundler schema for type-safe RPC method calls\n */\n/* eslint-disable @typescript-eslint/naming-convention */\ntype PimlicoBundlerSchema = [\n  {\n    Method: 'pimlico_getUserOperationGasPrice';\n    Parameters: [];\n    ReturnType: UserOperationGasPriceResponse;\n  },\n];\n\n/**\n * Infura bundler actions for extending bundler clients.\n *\n * @returns A function that takes a client and returns the client extension with Infura bundler actions.\n */\nconst infuraBundlerActions = () => (client: Client) => ({\n  /**\n   * Get user operation gas prices from Infura bundler.\n   * Calls the pimlico_getUserOperationGasPrice RPC method.\n   *\n   * @returns Promise resolving to gas price tiers (slow, standard, fast).\n   * @example\n   * ```typescript\n   * const gasPrices = await bundlerClient.getUserOperationGasPrice();\n   * console.log(gasPrices.standard.maxFeePerGas);\n   * ```\n   */\n  async getUserOperationGasPrice(): Promise<UserOperationGasPriceResponse> {\n    const pimlicoClient = client as Client<\n      Transport,\n      Chain | undefined,\n      Account | undefined,\n      PimlicoBundlerSchema\n    >;\n\n    return await pimlicoClient.request({\n      method: 'pimlico_getUserOperationGasPrice',\n      params: [],\n    });\n  },\n});\n\n/**\n * Type for bundler client extended with Infura bundler actions.\n */\nexport type InfuraBundlerClient<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends SmartAccount | undefined = SmartAccount | undefined,\n> = BundlerClient<TTransport, TChain, TAccount> & {\n  /**\n   * Get user operation gas prices from Infura bundler.\n   * Calls the pimlico_getUserOperationGasPrice RPC method.\n   *\n   * @returns Promise resolving to gas price tiers (slow, standard, fast).\n   */\n  getUserOperationGasPrice(): Promise<UserOperationGasPriceResponse>;\n};\n\n/**\n * Creates an Infura bundler client extended with Infura bundler actions.\n *\n * This is a wrapper around viem's createBundlerClient that extends it with\n * the getUserOperationGasPrice method for retrieving gas prices from Pimlico's\n * bundler infrastructure via Infura's proxy.\n *\n * @param config - Configuration for the bundler client.\n * @returns Extended bundler client with Infura bundler actions.\n * @example\n * ```typescript\n * import { createPublicClient, http } from 'viem';\n * import { sepolia } from 'viem/chains';\n * import { createInfuraBundlerClient } from '@metamask/delegation-toolkit';\n *\n * const publicClient = createPublicClient({\n *   chain: sepolia,\n *   transport: http('https://sepolia.infura.io/v3/YOUR_API_KEY'),\n * });\n *\n * const bundlerClient = createInfuraBundlerClient({\n *   client: publicClient,\n *   transport: http('https://sepolia.infura.io/v3/YOUR_API_KEY'),\n *   chain: sepolia,\n * });\n *\n * // Use standard bundler methods\n * const userOpHash = await bundlerClient.sendUserOperation({...});\n *\n * // Use Infura specific methods\n * const gasPrices = await bundlerClient.getUserOperationGasPrice();\n * ```\n */\nexport function createInfuraBundlerClient<\n  TTransport extends Transport,\n  TChain extends Chain | undefined = undefined,\n  TAccount extends SmartAccount | undefined = undefined,\n>(\n  config: BundlerClientConfig<TTransport, TChain, TAccount>,\n): InfuraBundlerClient<TTransport, TChain, TAccount> {\n  // Create the base bundler client using viem's function\n  const baseBundlerClient = createBundlerClient(config);\n\n  // Extend the client with Infura bundler actions\n  return baseBundlerClient.extend(\n    infuraBundlerActions(),\n  ) as unknown as InfuraBundlerClient<TTransport, TChain, TAccount>;\n}\n"],
  "mappings": "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",
  "names": ["signDelegation", "signUserOperation", "read_exports", "BaseError", "parseAccount", "bytesToHex", "hexToBytes", "hexToBytes", "bytesToHex", "Implementation", "encode", "signMessage", "signTypedData", "getStubSignature", "concat", "signDelegation", "signUserOperation", "encodeCalls"]
}
