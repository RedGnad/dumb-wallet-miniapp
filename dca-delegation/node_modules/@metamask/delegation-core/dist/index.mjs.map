{"version":3,"sources":["../src/returns.ts","../src/utils.ts","../src/caveats/valueLte.ts","../src/caveats/timestamp.ts","../src/caveats/nativeTokenPeriodTransfer.ts","../src/caveats/exactCalldata.ts","../src/caveats/nativeTokenStreaming.ts","../src/caveats/erc20Streaming.ts","../src/caveats/erc20TokenPeriodTransfer.ts","../src/caveats/nonce.ts","../src/delegation.ts"],"sourcesContent":["import { type BytesLike, bytesToHex, hexToBytes } from '@metamask/utils';\n\nimport type { Hex } from './types';\n\n/**\n * The possible return value types for encoding/decoding operations.\n */\nexport type ResultValue = 'hex' | 'bytes';\n\n/**\n * Utility type for function return types based on ResultValue.\n */\nexport type ResultType<TResultValue extends ResultValue> =\n  TResultValue extends 'hex' ? Hex : Uint8Array;\n\n/**\n * Base options interface for operations that can return hex or bytes.\n */\nexport type EncodingOptions<TResultValue extends ResultValue> = {\n  out: TResultValue;\n};\n\n/**\n * Default options value with proper typing. Use this as your default parameter.\n */\nexport const defaultOptions = { out: 'hex' } as EncodingOptions<any>;\n\n/**\n * Prepares a result by converting between hex and bytes based on options.\n * @param result - The value to convert (either Uint8Array or Hex optionally prefixed with 0x).\n * @param options - The options specifying the desired output format.\n * @returns The converted value with proper type narrowing.\n */\nexport function prepareResult<TResultValue extends ResultValue>(\n  result: Uint8Array | Hex | string,\n  options: EncodingOptions<TResultValue>,\n): ResultType<TResultValue> {\n  if (options.out === 'hex') {\n    const hexValue = typeof result === 'string' ? result : bytesToHex(result);\n\n    return hexValue.startsWith('0x')\n      ? (hexValue as ResultType<TResultValue>)\n      : (`0x${hexValue}` as ResultType<TResultValue>);\n  }\n  const bytesValue = result instanceof Uint8Array ? result : hexToBytes(result);\n  return bytesValue as ResultType<TResultValue>;\n}\n\n/**\n * Converts a bytes-like value to a hex string.\n * @param bytesLike - The bytes-like value to convert.\n * @returns The hex string representation of the bytes-like value.\n */\nexport const bytesLikeToHex = (bytesLike: BytesLike) => {\n  if (typeof bytesLike === 'string') {\n    return bytesLike;\n  }\n  return bytesToHex(bytesLike);\n};\n\n/**\n * Converts a bytes-like value to a Uint8Array.\n * @param bytesLike - The bytes-like value to convert.\n * @returns The Uint8Array representation of the bytes-like value.\n */\nexport const bytesLikeToBytes = (bytesLike: BytesLike) => {\n  if (typeof bytesLike === 'string') {\n    return hexToBytes(bytesLike);\n  }\n  return bytesLike;\n};\n","/**\n * Converts a numeric value to a hexadecimal string with zero-padding, without 0x prefix.\n *\n * @param options - The options for the conversion.\n * @param options.value - The numeric value to convert to hex (bigint or number).\n * @param options.size - The size in bytes for the resulting hex string (each byte = 2 hex characters).\n * @returns A hexadecimal string prefixed with zeros to match the specified size.\n * @example\n * ```typescript\n * toHexString({ value: 255, size: 2 }) // Returns \"00ff\"\n * toHexString({ value: 16n, size: 1 }) // Returns \"10\"\n * ```\n */\nexport const toHexString = ({\n  value,\n  size,\n}: {\n  value: bigint | number;\n  size: number;\n}): string => {\n  return value.toString(16).padStart(size * 2, '0');\n};\n","import {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\nimport { toHexString } from '../utils';\n\n/**\n * Terms for configuring a ValueLte caveat.\n */\nexport type ValueLteTerms = {\n  /** The maximum value allowed for the transaction as a bigint. */\n  maxValue: bigint;\n};\n\n/**\n * Creates terms for a ValueLte caveat that limits the maximum value of native tokens that can be spent.\n *\n * @param terms - The terms for the ValueLte caveat.\n * @param options - The encoding options for the result.\n * @returns The terms as a 32-byte hex string.\n * @throws Error if the maxValue is negative.\n */\nexport function createValueLteTerms(\n  terms: ValueLteTerms,\n  options?: EncodingOptions<'hex'>,\n): Hex;\nexport function createValueLteTerms(\n  terms: ValueLteTerms,\n  options: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for a ValueLte caveat that limits the maximum value of native tokens that can be spent.\n *\n * @param terms - The terms for the ValueLte caveat.\n * @param options - The encoding options for the result.\n * @returns The terms as a 32-byte hex string.\n * @throws Error if the maxValue is negative.\n */\nexport function createValueLteTerms(\n  terms: ValueLteTerms,\n  options: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { maxValue } = terms;\n\n  if (maxValue < 0n) {\n    throw new Error('Invalid maxValue: must be greater than or equal to zero');\n  }\n  const hexValue = toHexString({ value: maxValue, size: 32 });\n\n  return prepareResult(hexValue, options);\n}\n","import {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\nimport { toHexString } from '../utils';\n\n// Upper bound for timestamps (equivalent to January 1, 10000 CE)\nconst TIMESTAMP_UPPER_BOUND_SECONDS = 253402300799;\n\n/**\n * Terms for configuring a timestamp threshold for delegation usage.\n */\nexport type TimestampTerms = {\n  /** The timestamp (in seconds) after which the delegation can be used. */\n  timestampAfterThreshold: number;\n  /** The timestamp (in seconds) before which the delegation can be used. */\n  timestampBeforeThreshold: number;\n};\n\n/**\n * Creates terms for a Timestamp caveat that enforces time-based constraints on delegation usage.\n *\n * @param terms - The terms for the Timestamp caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 32-byte hex string (16 bytes for each timestamp).\n * @throws Error if the timestamps are invalid.\n */\nexport function createTimestampTerms(\n  terms: TimestampTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createTimestampTerms(\n  terms: TimestampTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for a Timestamp caveat that enforces time-based constraints on delegation usage.\n *\n * @param terms - The terms for the Timestamp caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 32-byte hex string (16 bytes for each timestamp).\n * @throws Error if the timestamps are invalid.\n */\nexport function createTimestampTerms(\n  terms: TimestampTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { timestampAfterThreshold, timestampBeforeThreshold } = terms;\n\n  if (timestampAfterThreshold < 0) {\n    throw new Error(\n      'Invalid timestampAfterThreshold: must be zero or positive',\n    );\n  }\n\n  if (timestampBeforeThreshold < 0) {\n    throw new Error(\n      'Invalid timestampBeforeThreshold: must be zero or positive',\n    );\n  }\n\n  if (timestampBeforeThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      `Invalid timestampBeforeThreshold: must be less than or equal to ${TIMESTAMP_UPPER_BOUND_SECONDS}`,\n    );\n  }\n\n  if (timestampAfterThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      `Invalid timestampAfterThreshold: must be less than or equal to ${TIMESTAMP_UPPER_BOUND_SECONDS}`,\n    );\n  }\n\n  if (\n    timestampBeforeThreshold !== 0 &&\n    timestampAfterThreshold >= timestampBeforeThreshold\n  ) {\n    throw new Error(\n      'Invalid thresholds: timestampBeforeThreshold must be greater than timestampAfterThreshold when both are specified',\n    );\n  }\n\n  const afterThresholdHex = toHexString({\n    value: timestampAfterThreshold,\n    size: 16,\n  });\n  const beforeThresholdHex = toHexString({\n    value: timestampBeforeThreshold,\n    size: 16,\n  });\n\n  const hexValue = `0x${afterThresholdHex}${beforeThresholdHex}`;\n\n  return prepareResult(hexValue, encodingOptions);\n}\n","import {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\nimport { toHexString } from '../utils';\n\n/**\n * Terms for configuring a periodic transfer allowance of native tokens.\n */\nexport type NativeTokenPeriodTransferTerms = {\n  /** The maximum amount that can be transferred within each period (in wei). */\n  periodAmount: bigint;\n  /** The duration of each period in seconds. */\n  periodDuration: number;\n  /** Unix timestamp when the first period begins. */\n  startDate: number;\n};\n\n/**\n * Creates terms for a NativeTokenPeriodTransfer caveat that validates that native token (ETH) transfers\n * do not exceed a specified amount within a given time period. The transferable amount resets at the\n * beginning of each period, and any unused ETH is forfeited once the period ends.\n *\n * @param terms - The terms for the NativeTokenPeriodTransfer caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 96-byte hex string (32 bytes for each parameter).\n * @throws Error if any of the numeric parameters are invalid.\n */\nexport function createNativeTokenPeriodTransferTerms(\n  terms: NativeTokenPeriodTransferTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createNativeTokenPeriodTransferTerms(\n  terms: NativeTokenPeriodTransferTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for a NativeTokenPeriodTransfer caveat that validates that native token (ETH) transfers\n * do not exceed a specified amount within a given time period.\n *\n * @param terms - The terms for the NativeTokenPeriodTransfer caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 96-byte hex string (32 bytes for each parameter).\n * @throws Error if any of the numeric parameters are invalid.\n */\nexport function createNativeTokenPeriodTransferTerms(\n  terms: NativeTokenPeriodTransferTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { periodAmount, periodDuration, startDate } = terms;\n\n  if (periodAmount <= 0n) {\n    throw new Error('Invalid periodAmount: must be a positive number');\n  }\n\n  if (periodDuration <= 0) {\n    throw new Error('Invalid periodDuration: must be a positive number');\n  }\n\n  if (startDate <= 0) {\n    throw new Error('Invalid startDate: must be a positive number');\n  }\n\n  const periodAmountHex = toHexString({ value: periodAmount, size: 32 });\n  const periodDurationHex = toHexString({ value: periodDuration, size: 32 });\n  const startDateHex = toHexString({ value: startDate, size: 32 });\n\n  const hexValue = `0x${periodAmountHex}${periodDurationHex}${startDateHex}`;\n\n  return prepareResult(hexValue, encodingOptions);\n}\n","import type { BytesLike } from '@metamask/utils';\n\nimport {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\n\n/**\n * Terms for configuring an ExactCalldata caveat.\n */\nexport type ExactCalldataTerms = {\n  /** The expected calldata to match against. */\n  calldata: BytesLike;\n};\n\n/**\n * Creates terms for an ExactCalldata caveat that ensures the provided execution calldata\n * matches exactly the expected calldata.\n *\n * @param terms - The terms for the ExactCalldata caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as the calldata itself.\n * @throws Error if the `calldata` is invalid.\n */\nexport function createExactCalldataTerms(\n  terms: ExactCalldataTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createExactCalldataTerms(\n  terms: ExactCalldataTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for an ExactCalldata caveat that ensures the provided execution calldata\n * matches exactly the expected calldata.\n * @param terms - The terms for the ExactCalldata caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as the calldata itself.\n * @throws Error if the `calldata` is invalid.\n */\nexport function createExactCalldataTerms(\n  terms: ExactCalldataTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { calldata } = terms;\n\n  if (typeof calldata === 'string' && !calldata.startsWith('0x')) {\n    throw new Error('Invalid calldata: must be a hex string starting with 0x');\n  }\n\n  // For exact calldata, the terms are simply the expected calldata\n  return prepareResult(calldata, encodingOptions);\n}\n","import {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\nimport { toHexString } from '../utils';\n\n// Upper bound for timestamps (January 1, 10000 CE)\nconst TIMESTAMP_UPPER_BOUND_SECONDS = 253402300799;\n\n/**\n * Terms for configuring a linear streaming allowance of native tokens.\n */\nexport type NativeTokenStreamingTerms = {\n  /** The initial amount available immediately (in wei). */\n  initialAmount: bigint;\n  /** The maximum total amount that can be transferred (in wei). */\n  maxAmount: bigint;\n  /** The rate at which allowance increases per second (in wei). */\n  amountPerSecond: bigint;\n  /** Unix timestamp when streaming begins. */\n  startTime: number;\n};\n\n/**\n * Creates terms for the NativeTokenStreaming caveat, configuring a linear\n * streaming allowance of native tokens.\n *\n * @param terms - The terms for the NativeTokenStreaming caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns Hex-encoded terms for the caveat (128 bytes).\n * @throws Error if initialAmount is negative.\n * @throws Error if maxAmount is not positive.\n * @throws Error if maxAmount is less than initialAmount.\n * @throws Error if amountPerSecond is not positive.\n * @throws Error if startTime is not positive.\n * @throws Error if startTime exceeds upper bound.\n */\nexport function createNativeTokenStreamingTerms(\n  terms: NativeTokenStreamingTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createNativeTokenStreamingTerms(\n  terms: NativeTokenStreamingTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for the NativeTokenStreaming caveat, configuring a linear\n * streaming allowance of native tokens.\n *\n * @param terms - The terms for the NativeTokenStreaming caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 128-byte hex string.\n * @throws Error if any of the numeric parameters are invalid.\n */\nexport function createNativeTokenStreamingTerms(\n  terms: NativeTokenStreamingTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { initialAmount, maxAmount, amountPerSecond, startTime } = terms;\n\n  if (initialAmount < 0n) {\n    throw new Error('Invalid initialAmount: must be greater than zero');\n  }\n\n  if (maxAmount <= 0n) {\n    throw new Error('Invalid maxAmount: must be a positive number');\n  }\n\n  if (maxAmount < initialAmount) {\n    throw new Error('Invalid maxAmount: must be greater than initialAmount');\n  }\n\n  if (amountPerSecond <= 0n) {\n    throw new Error('Invalid amountPerSecond: must be a positive number');\n  }\n\n  if (startTime <= 0) {\n    throw new Error('Invalid startTime: must be a positive number');\n  }\n\n  if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      'Invalid startTime: must be less than or equal to 253402300799',\n    );\n  }\n\n  const initialAmountHex = toHexString({ value: initialAmount, size: 32 });\n  const maxAmountHex = toHexString({ value: maxAmount, size: 32 });\n  const amountPerSecondHex = toHexString({ value: amountPerSecond, size: 32 });\n  const startTimeHex = toHexString({ value: startTime, size: 32 });\n\n  const hexValue = `0x${initialAmountHex}${maxAmountHex}${amountPerSecondHex}${startTimeHex}`;\n\n  return prepareResult(hexValue, encodingOptions);\n}\n","import { type BytesLike, bytesToHex, isHexString } from '@metamask/utils';\n\nimport {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\nimport { toHexString } from '../utils';\n\n// Upper bound for timestamps (January 1, 10000 CE)\nconst TIMESTAMP_UPPER_BOUND_SECONDS = 253402300799;\n\n/**\n * Terms for configuring a linear streaming allowance of ERC20 tokens.\n */\nexport type ERC20StreamingTerms = {\n  /** The address of the ERC20 token contract. */\n  tokenAddress: BytesLike;\n  /** The initial amount available immediately. */\n  initialAmount: bigint;\n  /** The maximum total amount that can be transferred. */\n  maxAmount: bigint;\n  /** The rate at which allowance increases per second. */\n  amountPerSecond: bigint;\n  /** Unix timestamp when streaming begins. */\n  startTime: number;\n};\n\n/**\n * Creates terms for the ERC20Streaming caveat, configuring a linear\n * streaming allowance of ERC20 tokens.\n *\n * @param terms - The terms for the ERC20Streaming caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns Hex-encoded terms for the caveat (160 bytes).\n * @throws Error if tokenAddress is invalid.\n * @throws Error if initialAmount is negative.\n * @throws Error if maxAmount is not positive.\n * @throws Error if maxAmount is less than initialAmount.\n * @throws Error if amountPerSecond is not positive.\n * @throws Error if startTime is not positive.\n * @throws Error if startTime exceeds upper bound.\n */\nexport function createERC20StreamingTerms(\n  terms: ERC20StreamingTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createERC20StreamingTerms(\n  terms: ERC20StreamingTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for the ERC20Streaming caveat, configuring a linear\n * streaming allowance of ERC20 tokens.\n *\n * @param terms - The terms for the ERC20Streaming caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 160-byte hex string.\n * @throws Error if any of the parameters are invalid.\n */\nexport function createERC20StreamingTerms(\n  terms: ERC20StreamingTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { tokenAddress, initialAmount, maxAmount, amountPerSecond, startTime } =\n    terms;\n\n  if (!tokenAddress) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  let prefixedTokenAddressHex: string;\n\n  if (typeof tokenAddress === 'string') {\n    if (!isHexString(tokenAddress) || tokenAddress.length !== 42) {\n      throw new Error('Invalid tokenAddress: must be a valid address');\n    }\n    prefixedTokenAddressHex = tokenAddress;\n  } else {\n    if (tokenAddress.length !== 20) {\n      throw new Error('Invalid tokenAddress: must be a valid address');\n    }\n    prefixedTokenAddressHex = bytesToHex(tokenAddress);\n  }\n\n  if (initialAmount < 0n) {\n    throw new Error('Invalid initialAmount: must be greater than zero');\n  }\n\n  if (maxAmount <= 0n) {\n    throw new Error('Invalid maxAmount: must be a positive number');\n  }\n\n  if (maxAmount < initialAmount) {\n    throw new Error('Invalid maxAmount: must be greater than initialAmount');\n  }\n\n  if (amountPerSecond <= 0n) {\n    throw new Error('Invalid amountPerSecond: must be a positive number');\n  }\n\n  if (startTime <= 0) {\n    throw new Error('Invalid startTime: must be a positive number');\n  }\n\n  if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      'Invalid startTime: must be less than or equal to 253402300799',\n    );\n  }\n\n  const initialAmountHex = toHexString({ value: initialAmount, size: 32 });\n  const maxAmountHex = toHexString({ value: maxAmount, size: 32 });\n  const amountPerSecondHex = toHexString({ value: amountPerSecond, size: 32 });\n  const startTimeHex = toHexString({ value: startTime, size: 32 });\n\n  const hexValue = `${prefixedTokenAddressHex}${initialAmountHex}${maxAmountHex}${amountPerSecondHex}${startTimeHex}`;\n\n  return prepareResult(hexValue, encodingOptions);\n}\n","import { type BytesLike, isHexString, bytesToHex } from '@metamask/utils';\n\nimport {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\nimport { toHexString } from '../utils';\n\n/**\n * Terms for configuring a periodic transfer allowance of ERC20 tokens.\n */\nexport type ERC20TokenPeriodTransferTerms = {\n  /** The address of the ERC20 token. */\n  tokenAddress: BytesLike;\n  /** The maximum amount that can be transferred within each period. */\n  periodAmount: bigint;\n  /** The duration of each period in seconds. */\n  periodDuration: number;\n  /** Unix timestamp when the first period begins. */\n  startDate: number;\n};\n\n/**\n * Creates terms for an ERC20TokenPeriodTransfer caveat that validates that ERC20 token transfers\n * do not exceed a specified amount within a given time period. The transferable amount resets at the\n * beginning of each period, and any unused tokens are forfeited once the period ends.\n *\n * @param terms - The terms for the ERC20TokenPeriodTransfer caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 128-byte hex string (32 bytes for each parameter).\n * @throws Error if any of the numeric parameters are invalid.\n */\nexport function createERC20TokenPeriodTransferTerms(\n  terms: ERC20TokenPeriodTransferTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createERC20TokenPeriodTransferTerms(\n  terms: ERC20TokenPeriodTransferTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for an ERC20TokenPeriodTransfer caveat that validates that ERC20 token transfers\n * do not exceed a specified amount within a given time period.\n *\n * @param terms - The terms for the ERC20TokenPeriodTransfer caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 128-byte hex string (32 bytes for each parameter).\n * @throws Error if any of the numeric parameters are invalid.\n */\nexport function createERC20TokenPeriodTransferTerms(\n  terms: ERC20TokenPeriodTransferTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { tokenAddress, periodAmount, periodDuration, startDate } = terms;\n\n  if (!tokenAddress) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  let prefixedTokenAddressHex: string;\n\n  if (typeof tokenAddress === 'string') {\n    if (!isHexString(tokenAddress) || tokenAddress.length !== 42) {\n      throw new Error('Invalid tokenAddress: must be a valid address');\n    }\n    prefixedTokenAddressHex = tokenAddress;\n  } else {\n    if (tokenAddress.length !== 20) {\n      throw new Error('Invalid tokenAddress: must be a valid address');\n    }\n    prefixedTokenAddressHex = bytesToHex(tokenAddress);\n  }\n\n  if (periodAmount <= 0n) {\n    throw new Error('Invalid periodAmount: must be a positive number');\n  }\n\n  if (periodDuration <= 0) {\n    throw new Error('Invalid periodDuration: must be a positive number');\n  }\n\n  if (startDate <= 0) {\n    throw new Error('Invalid startDate: must be a positive number');\n  }\n\n  const periodAmountHex = toHexString({ value: periodAmount, size: 32 });\n  const periodDurationHex = toHexString({ value: periodDuration, size: 32 });\n  const startDateHex = toHexString({ value: startDate, size: 32 });\n\n  const hexValue = `${prefixedTokenAddressHex}${periodAmountHex}${periodDurationHex}${startDateHex}`;\n\n  return prepareResult(hexValue, encodingOptions);\n}\n","import { isHexString } from '@metamask/utils';\nimport type { BytesLike } from '@metamask/utils';\n\nimport {\n  bytesLikeToHex,\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\n\n// char length of 32 byte hex string (including 0x prefix)\nconst MAX_NONCE_STRING_LENGTH = 66;\n\n/**\n * Terms for configuring a Nonce caveat.\n */\nexport type NonceTerms = {\n  /** The nonce as BytesLike (0x-prefixed hex string or Uint8Array) to allow bulk revocation of delegations. */\n  nonce: BytesLike;\n};\n\n/**\n * Creates terms for a Nonce caveat that uses a nonce value for bulk revocation of delegations.\n *\n * @param terms - The terms for the Nonce caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 32-byte hex string.\n * @throws Error if the nonce is invalid.\n */\nexport function createNonceTerms(\n  terms: NonceTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createNonceTerms(\n  terms: NonceTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for a Nonce caveat that uses a nonce value for bulk revocation of delegations.\n *\n * @param terms - The terms for the Nonce caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 32-byte padded value in the specified encoding format.\n * @throws Error if the nonce is invalid or empty.\n */\nexport function createNonceTerms(\n  terms: NonceTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { nonce } = terms;\n\n  // Handle zero-length Uint8Array specifically\n  if (nonce instanceof Uint8Array && nonce.length === 0) {\n    throw new Error('Invalid nonce: Uint8Array must not be empty');\n  }\n\n  // Validate that strings have 0x prefix (as required by BytesLike)\n  if (typeof nonce === 'string' && !nonce.startsWith('0x')) {\n    throw new Error('Invalid nonce: string must have 0x prefix');\n  }\n\n  // Convert to hex string for consistent processing\n  const hexNonce = bytesLikeToHex(nonce);\n\n  // Check for empty hex string (0x) first - more specific error\n  if (hexNonce === '0x') {\n    throw new Error('Invalid nonce: must not be empty');\n  }\n\n  if (!isHexString(hexNonce)) {\n    throw new Error('Invalid nonce: must be a valid BytesLike value');\n  }\n\n  if (hexNonce.length > MAX_NONCE_STRING_LENGTH) {\n    throw new Error('Invalid nonce: must be 32 bytes or less in length');\n  }\n\n  // Remove '0x' prefix for padding, then add it back\n  const nonceWithoutPrefix = hexNonce.slice(2);\n  const paddedNonce = nonceWithoutPrefix.padStart(64, '0'); // 64 hex chars = 32 bytes\n  const hexValue = `0x${paddedNonce}`;\n\n  return prepareResult(hexValue, encodingOptions);\n}\n","import { encode, encodeSingle, decodeSingle } from '@metamask/abi-utils';\nimport { hexToBytes, type BytesLike } from '@metamask/utils';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\n\nimport {\n  bytesLikeToBytes,\n  bytesLikeToHex,\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from './returns';\nimport type { CaveatStruct, DelegationStruct, Hex } from './types';\n\n/**\n * When designated as the delegate address in a delegation, this allows any beneficiary to redeem the delegation.\n */\nexport const ANY_BENEFICIARY = '0x0000000000000000000000000000000000000a11';\n\n/**\n * To be used on a delegation as the root authority.\n */\nexport const ROOT_AUTHORITY =\n  '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';\n\n/**\n * The typehash for a delegation, used when generating a delegation hash.\n *\n * keccak('Delegation(address delegate,address delegator,bytes32 authority,Caveat[] caveats,uint256 salt)Caveat(address enforcer,bytes terms)')\n */\nexport const DELEGATION_TYPEHASH =\n  '0x88c1d2ecf185adf710588203a5f263f0ff61be0d33da39792cde19ba9aa4331e';\n\n/**\n * The typehash for a caveat, used when generating a caveat hash.\n *\n * keccak('Caveat(address enforcer,bytes terms)')\n */\nexport const CAVEAT_TYPEHASH =\n  '0x80ad7e1b04ee6d994a125f4714ca0720908bd80ed16063ec8aee4b88e9253e2d';\n\n/**\n * The ABI types for an array of delegations.\n */\nconst DELEGATION_ARRAY_ABI_TYPES =\n  '(address,address,bytes32,(address,bytes,bytes)[],uint256,bytes)[]' as const;\n\n/**\n * Encodes an array of delegations into a permission context.\n * @param delegations - The delegations to encode.\n * @param options - Encoding options. Defaults to { out: 'hex' }.\n * @returns The encoded delegations as a hex string (default) or Uint8Array.\n */\nexport function encodeDelegations(\n  delegations: DelegationStruct[],\n  options?: EncodingOptions<'hex'>,\n): Hex;\nexport function encodeDelegations(\n  delegations: DelegationStruct[],\n  options: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Encodes an array of delegations into a permission context.\n * @param delegations - The delegations to encode.\n * @param options - Encoding options. Defaults to { out: 'hex' }.\n * @returns The encoded delegations as a hex string (default) or Uint8Array.\n */\nexport function encodeDelegations(\n  delegations: DelegationStruct[],\n  options: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  let result: Uint8Array;\n\n  if (delegations.length === 0) {\n    // short circuit for empty delegations, derived from\n    // `encode(['(address,address,bytes32,(address,bytes,bytes)[],uint256,bytes)[]'],[[]],);`\n    result = new Uint8Array(64);\n    result[31] = 0x20;\n  } else {\n    const encodableStructs = delegations.map((struct) => [\n      struct.delegate,\n      struct.delegator,\n      struct.authority,\n      struct.caveats.map((caveat) => [\n        caveat.enforcer,\n        caveat.terms,\n        caveat.args,\n      ]),\n      struct.salt,\n      struct.signature,\n    ]);\n\n    result = encodeSingle(DELEGATION_ARRAY_ABI_TYPES, encodableStructs);\n  }\n\n  return prepareResult(result, options);\n}\n\n/**\n * Converts a decoded delegation struct to a delegation object using the provided conversion function.\n * @param decodedDelegation - The decoded delegation struct as a tuple.\n * @param convertFn - Function to convert BytesLike values to the desired output type.\n * @returns A delegation object with all bytes-like values converted using the provided function.\n */\nconst delegationFromDecodedDelegation = <TEncoding extends BytesLike>(\n  decodedDelegation: DecodedDelegation,\n  convertFn: (value: BytesLike) => TEncoding,\n): DelegationStruct<TEncoding> => {\n  const [delegate, delegator, authority, caveats, salt, signature] =\n    decodedDelegation;\n\n  return {\n    delegate: convertFn(delegate),\n    delegator: convertFn(delegator),\n    authority: convertFn(authority),\n    caveats: caveats.map(([enforcer, terms, args]) => ({\n      enforcer: convertFn(enforcer),\n      terms: convertFn(terms),\n      args: convertFn(args),\n    })),\n    salt,\n    signature: convertFn(signature),\n  };\n};\n\n/**\n * Represents a decoded delegation as a tuple structure.\n * This type defines the structure of a delegation after it has been decoded from\n * an encoded format.\n */\ntype DecodedDelegation = [\n  BytesLike,\n  BytesLike,\n  BytesLike,\n  [BytesLike, BytesLike, BytesLike][],\n  bigint,\n  BytesLike,\n];\n\n/**\n * Decodes an encoded permission context back into an array of delegations.\n * @param encoded - The encoded delegations as a hex string or Uint8Array.\n * @param options - Encoding options. Defaults to { out: 'hex' }.\n * @returns The decoded delegations array with types resolved based on options.\n */\nexport function decodeDelegations(\n  encoded: BytesLike,\n  options?: EncodingOptions<'hex'>,\n): DelegationStruct<Hex>[];\nexport function decodeDelegations(\n  encoded: BytesLike,\n  options: EncodingOptions<'bytes'>,\n): DelegationStruct<Uint8Array>[];\n/**\n * Decodes an encoded permission context back into an array of delegations.\n * @param encoded - The encoded delegations as a hex string or Uint8Array.\n * @param options - Encoding options. Defaults to { out: 'hex' }.\n * @returns The decoded delegations array with types resolved based on options.\n */\nexport function decodeDelegations(\n  encoded: BytesLike,\n  options: EncodingOptions<ResultValue> = defaultOptions,\n): DelegationStruct<Hex>[] | DelegationStruct<Uint8Array>[] {\n  // it's possible to short circuit for empty delegations, but due to the\n  // complexity of the input type, and the relative infrequency of empty delegations,\n  // it's not worthwhile.\n\n  const decodedStructs = decodeSingle(\n    DELEGATION_ARRAY_ABI_TYPES,\n    encoded,\n    // return types cannot be inferred from complex ABI types, so we must assert the type\n  ) as DecodedDelegation[];\n\n  if (options.out === 'bytes') {\n    return decodedStructs.map((struct) =>\n      delegationFromDecodedDelegation(struct, bytesLikeToBytes),\n    );\n  }\n  return decodedStructs.map((struct) =>\n    delegationFromDecodedDelegation(struct, bytesLikeToHex),\n  );\n}\n\n/**\n * Calculates the hash of a delegation for signing purposes.\n * The hash is computed by encoding the delegation parameters with the delegation typehash\n * and then applying keccak256 hashing.\n *\n * @param delegation - The delegation to hash.\n * @param options - Encoding options. Defaults to { out: 'hex' }.\n * @returns The keccak256 hash of the encoded delegation as a hex string (default) or Uint8Array.\n */\nexport function hashDelegation(\n  delegation: DelegationStruct,\n  options?: EncodingOptions<'hex'>,\n): Hex;\nexport function hashDelegation(\n  delegation: DelegationStruct,\n  options: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Calculates the hash of a delegation for signing purposes.\n * The hash is computed by encoding the delegation parameters with the delegation typehash\n * and then applying keccak256 hashing.\n *\n * @param delegation - The delegation to hash.\n * @param options - Encoding options. Defaults to { out: 'hex' }.\n * @returns The keccak256 hash of the encoded delegation as a hex string (default) or Uint8Array.\n */\nexport function hashDelegation(\n  delegation: DelegationStruct,\n  options: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const encoded = encode(\n    ['bytes32', 'address', 'address', 'bytes32', 'bytes32', 'uint256'],\n    [\n      DELEGATION_TYPEHASH,\n      delegation.delegate,\n      delegation.delegator,\n      delegation.authority,\n      getCaveatsArrayHash(delegation.caveats),\n      delegation.salt,\n    ],\n  );\n  const hash = keccak256(encoded);\n  return prepareResult(hash, options);\n}\n\n/**\n * Calculates the hash of an array of caveats. The caveats are individually abi\n * encoded and hashed, and concatenated. The resulting byte array is then\n * hashed to produce the CaveatsArrayHash.\n *\n * @param caveats - The array of caveats to hash.\n * @returns The keccak256 hash of the encoded caveat array.\n */\nfunction getCaveatsArrayHash(caveats: CaveatStruct[]): Uint8Array {\n  const byteLength = 32 * caveats.length;\n  const encoded = new Uint8Array(byteLength);\n\n  for (let i = 0; i < caveats.length; i++) {\n    const caveat = caveats[i];\n    if (!caveat) {\n      throw new Error(`Caveat was undefined at index ${i}`);\n    }\n    const caveatHash = getCaveatHash(caveat);\n    encoded.set(caveatHash, i * 32);\n  }\n\n  return keccak256(encoded);\n}\n\n/**\n * Calculates the hash of a single caveat.\n * @param caveat - The caveat to hash.\n * @returns The keccak256 hash of the encoded caveat.\n */\nfunction getCaveatHash(caveat: CaveatStruct): Uint8Array {\n  const termsBytes =\n    typeof caveat.terms === 'string' ? hexToBytes(caveat.terms) : caveat.terms;\n\n  const termsHash = keccak256(termsBytes);\n\n  const encoded = encode(\n    ['bytes32', 'address', 'bytes32'],\n    [CAVEAT_TYPEHASH, caveat.enforcer, termsHash],\n  );\n  const hash = keccak256(encoded);\n  return hash;\n}\n"],"mappings":"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","names":["TIMESTAMP_UPPER_BOUND_SECONDS","bytesToHex","TIMESTAMP_UPPER_BOUND_SECONDS","bytesToHex","isHexString","bytesToHex","isHexString","bytesToHex","isHexString","isHexString","hexToBytes","hexToBytes"]}