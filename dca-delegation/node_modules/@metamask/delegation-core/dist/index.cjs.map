{"version":3,"sources":["/home/runner/work/delegation-toolkit/delegation-toolkit/packages/delegation-core/dist/index.cjs","../src/returns.ts","../src/utils.ts","../src/caveats/valueLte.ts","../src/caveats/timestamp.ts","../src/caveats/nativeTokenPeriodTransfer.ts","../src/caveats/exactCalldata.ts","../src/caveats/nativeTokenStreaming.ts","../src/caveats/erc20Streaming.ts","../src/caveats/erc20TokenPeriodTransfer.ts","../src/caveats/nonce.ts","../src/delegation.ts"],"names":["bytesToHex","hexToBytes"],"mappings":"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","file":"/home/runner/work/delegation-toolkit/delegation-toolkit/packages/delegation-core/dist/index.cjs","sourcesContent":[null,"import { type BytesLike, bytesToHex, hexToBytes } from '@metamask/utils';\n\nimport type { Hex } from './types';\n\n/**\n * The possible return value types for encoding/decoding operations.\n */\nexport type ResultValue = 'hex' | 'bytes';\n\n/**\n * Utility type for function return types based on ResultValue.\n */\nexport type ResultType<TResultValue extends ResultValue> =\n  TResultValue extends 'hex' ? Hex : Uint8Array;\n\n/**\n * Base options interface for operations that can return hex or bytes.\n */\nexport type EncodingOptions<TResultValue extends ResultValue> = {\n  out: TResultValue;\n};\n\n/**\n * Default options value with proper typing. Use this as your default parameter.\n */\nexport const defaultOptions = { out: 'hex' } as EncodingOptions<any>;\n\n/**\n * Prepares a result by converting between hex and bytes based on options.\n * @param result - The value to convert (either Uint8Array or Hex optionally prefixed with 0x).\n * @param options - The options specifying the desired output format.\n * @returns The converted value with proper type narrowing.\n */\nexport function prepareResult<TResultValue extends ResultValue>(\n  result: Uint8Array | Hex | string,\n  options: EncodingOptions<TResultValue>,\n): ResultType<TResultValue> {\n  if (options.out === 'hex') {\n    const hexValue = typeof result === 'string' ? result : bytesToHex(result);\n\n    return hexValue.startsWith('0x')\n      ? (hexValue as ResultType<TResultValue>)\n      : (`0x${hexValue}` as ResultType<TResultValue>);\n  }\n  const bytesValue = result instanceof Uint8Array ? result : hexToBytes(result);\n  return bytesValue as ResultType<TResultValue>;\n}\n\n/**\n * Converts a bytes-like value to a hex string.\n * @param bytesLike - The bytes-like value to convert.\n * @returns The hex string representation of the bytes-like value.\n */\nexport const bytesLikeToHex = (bytesLike: BytesLike) => {\n  if (typeof bytesLike === 'string') {\n    return bytesLike;\n  }\n  return bytesToHex(bytesLike);\n};\n\n/**\n * Converts a bytes-like value to a Uint8Array.\n * @param bytesLike - The bytes-like value to convert.\n * @returns The Uint8Array representation of the bytes-like value.\n */\nexport const bytesLikeToBytes = (bytesLike: BytesLike) => {\n  if (typeof bytesLike === 'string') {\n    return hexToBytes(bytesLike);\n  }\n  return bytesLike;\n};\n","/**\n * Converts a numeric value to a hexadecimal string with zero-padding, without 0x prefix.\n *\n * @param options - The options for the conversion.\n * @param options.value - The numeric value to convert to hex (bigint or number).\n * @param options.size - The size in bytes for the resulting hex string (each byte = 2 hex characters).\n * @returns A hexadecimal string prefixed with zeros to match the specified size.\n * @example\n * ```typescript\n * toHexString({ value: 255, size: 2 }) // Returns \"00ff\"\n * toHexString({ value: 16n, size: 1 }) // Returns \"10\"\n * ```\n */\nexport const toHexString = ({\n  value,\n  size,\n}: {\n  value: bigint | number;\n  size: number;\n}): string => {\n  return value.toString(16).padStart(size * 2, '0');\n};\n","import {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\nimport { toHexString } from '../utils';\n\n/**\n * Terms for configuring a ValueLte caveat.\n */\nexport type ValueLteTerms = {\n  /** The maximum value allowed for the transaction as a bigint. */\n  maxValue: bigint;\n};\n\n/**\n * Creates terms for a ValueLte caveat that limits the maximum value of native tokens that can be spent.\n *\n * @param terms - The terms for the ValueLte caveat.\n * @param options - The encoding options for the result.\n * @returns The terms as a 32-byte hex string.\n * @throws Error if the maxValue is negative.\n */\nexport function createValueLteTerms(\n  terms: ValueLteTerms,\n  options?: EncodingOptions<'hex'>,\n): Hex;\nexport function createValueLteTerms(\n  terms: ValueLteTerms,\n  options: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for a ValueLte caveat that limits the maximum value of native tokens that can be spent.\n *\n * @param terms - The terms for the ValueLte caveat.\n * @param options - The encoding options for the result.\n * @returns The terms as a 32-byte hex string.\n * @throws Error if the maxValue is negative.\n */\nexport function createValueLteTerms(\n  terms: ValueLteTerms,\n  options: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { maxValue } = terms;\n\n  if (maxValue < 0n) {\n    throw new Error('Invalid maxValue: must be greater than or equal to zero');\n  }\n  const hexValue = toHexString({ value: maxValue, size: 32 });\n\n  return prepareResult(hexValue, options);\n}\n","import {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\nimport { toHexString } from '../utils';\n\n// Upper bound for timestamps (equivalent to January 1, 10000 CE)\nconst TIMESTAMP_UPPER_BOUND_SECONDS = 253402300799;\n\n/**\n * Terms for configuring a timestamp threshold for delegation usage.\n */\nexport type TimestampTerms = {\n  /** The timestamp (in seconds) after which the delegation can be used. */\n  timestampAfterThreshold: number;\n  /** The timestamp (in seconds) before which the delegation can be used. */\n  timestampBeforeThreshold: number;\n};\n\n/**\n * Creates terms for a Timestamp caveat that enforces time-based constraints on delegation usage.\n *\n * @param terms - The terms for the Timestamp caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 32-byte hex string (16 bytes for each timestamp).\n * @throws Error if the timestamps are invalid.\n */\nexport function createTimestampTerms(\n  terms: TimestampTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createTimestampTerms(\n  terms: TimestampTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for a Timestamp caveat that enforces time-based constraints on delegation usage.\n *\n * @param terms - The terms for the Timestamp caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 32-byte hex string (16 bytes for each timestamp).\n * @throws Error if the timestamps are invalid.\n */\nexport function createTimestampTerms(\n  terms: TimestampTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { timestampAfterThreshold, timestampBeforeThreshold } = terms;\n\n  if (timestampAfterThreshold < 0) {\n    throw new Error(\n      'Invalid timestampAfterThreshold: must be zero or positive',\n    );\n  }\n\n  if (timestampBeforeThreshold < 0) {\n    throw new Error(\n      'Invalid timestampBeforeThreshold: must be zero or positive',\n    );\n  }\n\n  if (timestampBeforeThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      `Invalid timestampBeforeThreshold: must be less than or equal to ${TIMESTAMP_UPPER_BOUND_SECONDS}`,\n    );\n  }\n\n  if (timestampAfterThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      `Invalid timestampAfterThreshold: must be less than or equal to ${TIMESTAMP_UPPER_BOUND_SECONDS}`,\n    );\n  }\n\n  if (\n    timestampBeforeThreshold !== 0 &&\n    timestampAfterThreshold >= timestampBeforeThreshold\n  ) {\n    throw new Error(\n      'Invalid thresholds: timestampBeforeThreshold must be greater than timestampAfterThreshold when both are specified',\n    );\n  }\n\n  const afterThresholdHex = toHexString({\n    value: timestampAfterThreshold,\n    size: 16,\n  });\n  const beforeThresholdHex = toHexString({\n    value: timestampBeforeThreshold,\n    size: 16,\n  });\n\n  const hexValue = `0x${afterThresholdHex}${beforeThresholdHex}`;\n\n  return prepareResult(hexValue, encodingOptions);\n}\n","import {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\nimport { toHexString } from '../utils';\n\n/**\n * Terms for configuring a periodic transfer allowance of native tokens.\n */\nexport type NativeTokenPeriodTransferTerms = {\n  /** The maximum amount that can be transferred within each period (in wei). */\n  periodAmount: bigint;\n  /** The duration of each period in seconds. */\n  periodDuration: number;\n  /** Unix timestamp when the first period begins. */\n  startDate: number;\n};\n\n/**\n * Creates terms for a NativeTokenPeriodTransfer caveat that validates that native token (ETH) transfers\n * do not exceed a specified amount within a given time period. The transferable amount resets at the\n * beginning of each period, and any unused ETH is forfeited once the period ends.\n *\n * @param terms - The terms for the NativeTokenPeriodTransfer caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 96-byte hex string (32 bytes for each parameter).\n * @throws Error if any of the numeric parameters are invalid.\n */\nexport function createNativeTokenPeriodTransferTerms(\n  terms: NativeTokenPeriodTransferTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createNativeTokenPeriodTransferTerms(\n  terms: NativeTokenPeriodTransferTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for a NativeTokenPeriodTransfer caveat that validates that native token (ETH) transfers\n * do not exceed a specified amount within a given time period.\n *\n * @param terms - The terms for the NativeTokenPeriodTransfer caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 96-byte hex string (32 bytes for each parameter).\n * @throws Error if any of the numeric parameters are invalid.\n */\nexport function createNativeTokenPeriodTransferTerms(\n  terms: NativeTokenPeriodTransferTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { periodAmount, periodDuration, startDate } = terms;\n\n  if (periodAmount <= 0n) {\n    throw new Error('Invalid periodAmount: must be a positive number');\n  }\n\n  if (periodDuration <= 0) {\n    throw new Error('Invalid periodDuration: must be a positive number');\n  }\n\n  if (startDate <= 0) {\n    throw new Error('Invalid startDate: must be a positive number');\n  }\n\n  const periodAmountHex = toHexString({ value: periodAmount, size: 32 });\n  const periodDurationHex = toHexString({ value: periodDuration, size: 32 });\n  const startDateHex = toHexString({ value: startDate, size: 32 });\n\n  const hexValue = `0x${periodAmountHex}${periodDurationHex}${startDateHex}`;\n\n  return prepareResult(hexValue, encodingOptions);\n}\n","import type { BytesLike } from '@metamask/utils';\n\nimport {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\n\n/**\n * Terms for configuring an ExactCalldata caveat.\n */\nexport type ExactCalldataTerms = {\n  /** The expected calldata to match against. */\n  calldata: BytesLike;\n};\n\n/**\n * Creates terms for an ExactCalldata caveat that ensures the provided execution calldata\n * matches exactly the expected calldata.\n *\n * @param terms - The terms for the ExactCalldata caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as the calldata itself.\n * @throws Error if the `calldata` is invalid.\n */\nexport function createExactCalldataTerms(\n  terms: ExactCalldataTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createExactCalldataTerms(\n  terms: ExactCalldataTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for an ExactCalldata caveat that ensures the provided execution calldata\n * matches exactly the expected calldata.\n * @param terms - The terms for the ExactCalldata caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as the calldata itself.\n * @throws Error if the `calldata` is invalid.\n */\nexport function createExactCalldataTerms(\n  terms: ExactCalldataTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { calldata } = terms;\n\n  if (typeof calldata === 'string' && !calldata.startsWith('0x')) {\n    throw new Error('Invalid calldata: must be a hex string starting with 0x');\n  }\n\n  // For exact calldata, the terms are simply the expected calldata\n  return prepareResult(calldata, encodingOptions);\n}\n","import {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\nimport { toHexString } from '../utils';\n\n// Upper bound for timestamps (January 1, 10000 CE)\nconst TIMESTAMP_UPPER_BOUND_SECONDS = 253402300799;\n\n/**\n * Terms for configuring a linear streaming allowance of native tokens.\n */\nexport type NativeTokenStreamingTerms = {\n  /** The initial amount available immediately (in wei). */\n  initialAmount: bigint;\n  /** The maximum total amount that can be transferred (in wei). */\n  maxAmount: bigint;\n  /** The rate at which allowance increases per second (in wei). */\n  amountPerSecond: bigint;\n  /** Unix timestamp when streaming begins. */\n  startTime: number;\n};\n\n/**\n * Creates terms for the NativeTokenStreaming caveat, configuring a linear\n * streaming allowance of native tokens.\n *\n * @param terms - The terms for the NativeTokenStreaming caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns Hex-encoded terms for the caveat (128 bytes).\n * @throws Error if initialAmount is negative.\n * @throws Error if maxAmount is not positive.\n * @throws Error if maxAmount is less than initialAmount.\n * @throws Error if amountPerSecond is not positive.\n * @throws Error if startTime is not positive.\n * @throws Error if startTime exceeds upper bound.\n */\nexport function createNativeTokenStreamingTerms(\n  terms: NativeTokenStreamingTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createNativeTokenStreamingTerms(\n  terms: NativeTokenStreamingTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for the NativeTokenStreaming caveat, configuring a linear\n * streaming allowance of native tokens.\n *\n * @param terms - The terms for the NativeTokenStreaming caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 128-byte hex string.\n * @throws Error if any of the numeric parameters are invalid.\n */\nexport function createNativeTokenStreamingTerms(\n  terms: NativeTokenStreamingTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { initialAmount, maxAmount, amountPerSecond, startTime } = terms;\n\n  if (initialAmount < 0n) {\n    throw new Error('Invalid initialAmount: must be greater than zero');\n  }\n\n  if (maxAmount <= 0n) {\n    throw new Error('Invalid maxAmount: must be a positive number');\n  }\n\n  if (maxAmount < initialAmount) {\n    throw new Error('Invalid maxAmount: must be greater than initialAmount');\n  }\n\n  if (amountPerSecond <= 0n) {\n    throw new Error('Invalid amountPerSecond: must be a positive number');\n  }\n\n  if (startTime <= 0) {\n    throw new Error('Invalid startTime: must be a positive number');\n  }\n\n  if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      'Invalid startTime: must be less than or equal to 253402300799',\n    );\n  }\n\n  const initialAmountHex = toHexString({ value: initialAmount, size: 32 });\n  const maxAmountHex = toHexString({ value: maxAmount, size: 32 });\n  const amountPerSecondHex = toHexString({ value: amountPerSecond, size: 32 });\n  const startTimeHex = toHexString({ value: startTime, size: 32 });\n\n  const hexValue = `0x${initialAmountHex}${maxAmountHex}${amountPerSecondHex}${startTimeHex}`;\n\n  return prepareResult(hexValue, encodingOptions);\n}\n","import { type BytesLike, bytesToHex, isHexString } from '@metamask/utils';\n\nimport {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\nimport { toHexString } from '../utils';\n\n// Upper bound for timestamps (January 1, 10000 CE)\nconst TIMESTAMP_UPPER_BOUND_SECONDS = 253402300799;\n\n/**\n * Terms for configuring a linear streaming allowance of ERC20 tokens.\n */\nexport type ERC20StreamingTerms = {\n  /** The address of the ERC20 token contract. */\n  tokenAddress: BytesLike;\n  /** The initial amount available immediately. */\n  initialAmount: bigint;\n  /** The maximum total amount that can be transferred. */\n  maxAmount: bigint;\n  /** The rate at which allowance increases per second. */\n  amountPerSecond: bigint;\n  /** Unix timestamp when streaming begins. */\n  startTime: number;\n};\n\n/**\n * Creates terms for the ERC20Streaming caveat, configuring a linear\n * streaming allowance of ERC20 tokens.\n *\n * @param terms - The terms for the ERC20Streaming caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns Hex-encoded terms for the caveat (160 bytes).\n * @throws Error if tokenAddress is invalid.\n * @throws Error if initialAmount is negative.\n * @throws Error if maxAmount is not positive.\n * @throws Error if maxAmount is less than initialAmount.\n * @throws Error if amountPerSecond is not positive.\n * @throws Error if startTime is not positive.\n * @throws Error if startTime exceeds upper bound.\n */\nexport function createERC20StreamingTerms(\n  terms: ERC20StreamingTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createERC20StreamingTerms(\n  terms: ERC20StreamingTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for the ERC20Streaming caveat, configuring a linear\n * streaming allowance of ERC20 tokens.\n *\n * @param terms - The terms for the ERC20Streaming caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 160-byte hex string.\n * @throws Error if any of the parameters are invalid.\n */\nexport function createERC20StreamingTerms(\n  terms: ERC20StreamingTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { tokenAddress, initialAmount, maxAmount, amountPerSecond, startTime } =\n    terms;\n\n  if (!tokenAddress) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  let prefixedTokenAddressHex: string;\n\n  if (typeof tokenAddress === 'string') {\n    if (!isHexString(tokenAddress) || tokenAddress.length !== 42) {\n      throw new Error('Invalid tokenAddress: must be a valid address');\n    }\n    prefixedTokenAddressHex = tokenAddress;\n  } else {\n    if (tokenAddress.length !== 20) {\n      throw new Error('Invalid tokenAddress: must be a valid address');\n    }\n    prefixedTokenAddressHex = bytesToHex(tokenAddress);\n  }\n\n  if (initialAmount < 0n) {\n    throw new Error('Invalid initialAmount: must be greater than zero');\n  }\n\n  if (maxAmount <= 0n) {\n    throw new Error('Invalid maxAmount: must be a positive number');\n  }\n\n  if (maxAmount < initialAmount) {\n    throw new Error('Invalid maxAmount: must be greater than initialAmount');\n  }\n\n  if (amountPerSecond <= 0n) {\n    throw new Error('Invalid amountPerSecond: must be a positive number');\n  }\n\n  if (startTime <= 0) {\n    throw new Error('Invalid startTime: must be a positive number');\n  }\n\n  if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS) {\n    throw new Error(\n      'Invalid startTime: must be less than or equal to 253402300799',\n    );\n  }\n\n  const initialAmountHex = toHexString({ value: initialAmount, size: 32 });\n  const maxAmountHex = toHexString({ value: maxAmount, size: 32 });\n  const amountPerSecondHex = toHexString({ value: amountPerSecond, size: 32 });\n  const startTimeHex = toHexString({ value: startTime, size: 32 });\n\n  const hexValue = `${prefixedTokenAddressHex}${initialAmountHex}${maxAmountHex}${amountPerSecondHex}${startTimeHex}`;\n\n  return prepareResult(hexValue, encodingOptions);\n}\n","import { type BytesLike, isHexString, bytesToHex } from '@metamask/utils';\n\nimport {\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\nimport { toHexString } from '../utils';\n\n/**\n * Terms for configuring a periodic transfer allowance of ERC20 tokens.\n */\nexport type ERC20TokenPeriodTransferTerms = {\n  /** The address of the ERC20 token. */\n  tokenAddress: BytesLike;\n  /** The maximum amount that can be transferred within each period. */\n  periodAmount: bigint;\n  /** The duration of each period in seconds. */\n  periodDuration: number;\n  /** Unix timestamp when the first period begins. */\n  startDate: number;\n};\n\n/**\n * Creates terms for an ERC20TokenPeriodTransfer caveat that validates that ERC20 token transfers\n * do not exceed a specified amount within a given time period. The transferable amount resets at the\n * beginning of each period, and any unused tokens are forfeited once the period ends.\n *\n * @param terms - The terms for the ERC20TokenPeriodTransfer caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 128-byte hex string (32 bytes for each parameter).\n * @throws Error if any of the numeric parameters are invalid.\n */\nexport function createERC20TokenPeriodTransferTerms(\n  terms: ERC20TokenPeriodTransferTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createERC20TokenPeriodTransferTerms(\n  terms: ERC20TokenPeriodTransferTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for an ERC20TokenPeriodTransfer caveat that validates that ERC20 token transfers\n * do not exceed a specified amount within a given time period.\n *\n * @param terms - The terms for the ERC20TokenPeriodTransfer caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 128-byte hex string (32 bytes for each parameter).\n * @throws Error if any of the numeric parameters are invalid.\n */\nexport function createERC20TokenPeriodTransferTerms(\n  terms: ERC20TokenPeriodTransferTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { tokenAddress, periodAmount, periodDuration, startDate } = terms;\n\n  if (!tokenAddress) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  let prefixedTokenAddressHex: string;\n\n  if (typeof tokenAddress === 'string') {\n    if (!isHexString(tokenAddress) || tokenAddress.length !== 42) {\n      throw new Error('Invalid tokenAddress: must be a valid address');\n    }\n    prefixedTokenAddressHex = tokenAddress;\n  } else {\n    if (tokenAddress.length !== 20) {\n      throw new Error('Invalid tokenAddress: must be a valid address');\n    }\n    prefixedTokenAddressHex = bytesToHex(tokenAddress);\n  }\n\n  if (periodAmount <= 0n) {\n    throw new Error('Invalid periodAmount: must be a positive number');\n  }\n\n  if (periodDuration <= 0) {\n    throw new Error('Invalid periodDuration: must be a positive number');\n  }\n\n  if (startDate <= 0) {\n    throw new Error('Invalid startDate: must be a positive number');\n  }\n\n  const periodAmountHex = toHexString({ value: periodAmount, size: 32 });\n  const periodDurationHex = toHexString({ value: periodDuration, size: 32 });\n  const startDateHex = toHexString({ value: startDate, size: 32 });\n\n  const hexValue = `${prefixedTokenAddressHex}${periodAmountHex}${periodDurationHex}${startDateHex}`;\n\n  return prepareResult(hexValue, encodingOptions);\n}\n","import { isHexString } from '@metamask/utils';\nimport type { BytesLike } from '@metamask/utils';\n\nimport {\n  bytesLikeToHex,\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from '../returns';\nimport type { Hex } from '../types';\n\n// char length of 32 byte hex string (including 0x prefix)\nconst MAX_NONCE_STRING_LENGTH = 66;\n\n/**\n * Terms for configuring a Nonce caveat.\n */\nexport type NonceTerms = {\n  /** The nonce as BytesLike (0x-prefixed hex string or Uint8Array) to allow bulk revocation of delegations. */\n  nonce: BytesLike;\n};\n\n/**\n * Creates terms for a Nonce caveat that uses a nonce value for bulk revocation of delegations.\n *\n * @param terms - The terms for the Nonce caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 32-byte hex string.\n * @throws Error if the nonce is invalid.\n */\nexport function createNonceTerms(\n  terms: NonceTerms,\n  encodingOptions?: EncodingOptions<'hex'>,\n): Hex;\nexport function createNonceTerms(\n  terms: NonceTerms,\n  encodingOptions: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Creates terms for a Nonce caveat that uses a nonce value for bulk revocation of delegations.\n *\n * @param terms - The terms for the Nonce caveat.\n * @param encodingOptions - The encoding options for the result.\n * @returns The terms as a 32-byte padded value in the specified encoding format.\n * @throws Error if the nonce is invalid or empty.\n */\nexport function createNonceTerms(\n  terms: NonceTerms,\n  encodingOptions: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const { nonce } = terms;\n\n  // Handle zero-length Uint8Array specifically\n  if (nonce instanceof Uint8Array && nonce.length === 0) {\n    throw new Error('Invalid nonce: Uint8Array must not be empty');\n  }\n\n  // Validate that strings have 0x prefix (as required by BytesLike)\n  if (typeof nonce === 'string' && !nonce.startsWith('0x')) {\n    throw new Error('Invalid nonce: string must have 0x prefix');\n  }\n\n  // Convert to hex string for consistent processing\n  const hexNonce = bytesLikeToHex(nonce);\n\n  // Check for empty hex string (0x) first - more specific error\n  if (hexNonce === '0x') {\n    throw new Error('Invalid nonce: must not be empty');\n  }\n\n  if (!isHexString(hexNonce)) {\n    throw new Error('Invalid nonce: must be a valid BytesLike value');\n  }\n\n  if (hexNonce.length > MAX_NONCE_STRING_LENGTH) {\n    throw new Error('Invalid nonce: must be 32 bytes or less in length');\n  }\n\n  // Remove '0x' prefix for padding, then add it back\n  const nonceWithoutPrefix = hexNonce.slice(2);\n  const paddedNonce = nonceWithoutPrefix.padStart(64, '0'); // 64 hex chars = 32 bytes\n  const hexValue = `0x${paddedNonce}`;\n\n  return prepareResult(hexValue, encodingOptions);\n}\n","import { encode, encodeSingle, decodeSingle } from '@metamask/abi-utils';\nimport { hexToBytes, type BytesLike } from '@metamask/utils';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\n\nimport {\n  bytesLikeToBytes,\n  bytesLikeToHex,\n  defaultOptions,\n  prepareResult,\n  type EncodingOptions,\n  type ResultValue,\n} from './returns';\nimport type { CaveatStruct, DelegationStruct, Hex } from './types';\n\n/**\n * When designated as the delegate address in a delegation, this allows any beneficiary to redeem the delegation.\n */\nexport const ANY_BENEFICIARY = '0x0000000000000000000000000000000000000a11';\n\n/**\n * To be used on a delegation as the root authority.\n */\nexport const ROOT_AUTHORITY =\n  '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';\n\n/**\n * The typehash for a delegation, used when generating a delegation hash.\n *\n * keccak('Delegation(address delegate,address delegator,bytes32 authority,Caveat[] caveats,uint256 salt)Caveat(address enforcer,bytes terms)')\n */\nexport const DELEGATION_TYPEHASH =\n  '0x88c1d2ecf185adf710588203a5f263f0ff61be0d33da39792cde19ba9aa4331e';\n\n/**\n * The typehash for a caveat, used when generating a caveat hash.\n *\n * keccak('Caveat(address enforcer,bytes terms)')\n */\nexport const CAVEAT_TYPEHASH =\n  '0x80ad7e1b04ee6d994a125f4714ca0720908bd80ed16063ec8aee4b88e9253e2d';\n\n/**\n * The ABI types for an array of delegations.\n */\nconst DELEGATION_ARRAY_ABI_TYPES =\n  '(address,address,bytes32,(address,bytes,bytes)[],uint256,bytes)[]' as const;\n\n/**\n * Encodes an array of delegations into a permission context.\n * @param delegations - The delegations to encode.\n * @param options - Encoding options. Defaults to { out: 'hex' }.\n * @returns The encoded delegations as a hex string (default) or Uint8Array.\n */\nexport function encodeDelegations(\n  delegations: DelegationStruct[],\n  options?: EncodingOptions<'hex'>,\n): Hex;\nexport function encodeDelegations(\n  delegations: DelegationStruct[],\n  options: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Encodes an array of delegations into a permission context.\n * @param delegations - The delegations to encode.\n * @param options - Encoding options. Defaults to { out: 'hex' }.\n * @returns The encoded delegations as a hex string (default) or Uint8Array.\n */\nexport function encodeDelegations(\n  delegations: DelegationStruct[],\n  options: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  let result: Uint8Array;\n\n  if (delegations.length === 0) {\n    // short circuit for empty delegations, derived from\n    // `encode(['(address,address,bytes32,(address,bytes,bytes)[],uint256,bytes)[]'],[[]],);`\n    result = new Uint8Array(64);\n    result[31] = 0x20;\n  } else {\n    const encodableStructs = delegations.map((struct) => [\n      struct.delegate,\n      struct.delegator,\n      struct.authority,\n      struct.caveats.map((caveat) => [\n        caveat.enforcer,\n        caveat.terms,\n        caveat.args,\n      ]),\n      struct.salt,\n      struct.signature,\n    ]);\n\n    result = encodeSingle(DELEGATION_ARRAY_ABI_TYPES, encodableStructs);\n  }\n\n  return prepareResult(result, options);\n}\n\n/**\n * Converts a decoded delegation struct to a delegation object using the provided conversion function.\n * @param decodedDelegation - The decoded delegation struct as a tuple.\n * @param convertFn - Function to convert BytesLike values to the desired output type.\n * @returns A delegation object with all bytes-like values converted using the provided function.\n */\nconst delegationFromDecodedDelegation = <TEncoding extends BytesLike>(\n  decodedDelegation: DecodedDelegation,\n  convertFn: (value: BytesLike) => TEncoding,\n): DelegationStruct<TEncoding> => {\n  const [delegate, delegator, authority, caveats, salt, signature] =\n    decodedDelegation;\n\n  return {\n    delegate: convertFn(delegate),\n    delegator: convertFn(delegator),\n    authority: convertFn(authority),\n    caveats: caveats.map(([enforcer, terms, args]) => ({\n      enforcer: convertFn(enforcer),\n      terms: convertFn(terms),\n      args: convertFn(args),\n    })),\n    salt,\n    signature: convertFn(signature),\n  };\n};\n\n/**\n * Represents a decoded delegation as a tuple structure.\n * This type defines the structure of a delegation after it has been decoded from\n * an encoded format.\n */\ntype DecodedDelegation = [\n  BytesLike,\n  BytesLike,\n  BytesLike,\n  [BytesLike, BytesLike, BytesLike][],\n  bigint,\n  BytesLike,\n];\n\n/**\n * Decodes an encoded permission context back into an array of delegations.\n * @param encoded - The encoded delegations as a hex string or Uint8Array.\n * @param options - Encoding options. Defaults to { out: 'hex' }.\n * @returns The decoded delegations array with types resolved based on options.\n */\nexport function decodeDelegations(\n  encoded: BytesLike,\n  options?: EncodingOptions<'hex'>,\n): DelegationStruct<Hex>[];\nexport function decodeDelegations(\n  encoded: BytesLike,\n  options: EncodingOptions<'bytes'>,\n): DelegationStruct<Uint8Array>[];\n/**\n * Decodes an encoded permission context back into an array of delegations.\n * @param encoded - The encoded delegations as a hex string or Uint8Array.\n * @param options - Encoding options. Defaults to { out: 'hex' }.\n * @returns The decoded delegations array with types resolved based on options.\n */\nexport function decodeDelegations(\n  encoded: BytesLike,\n  options: EncodingOptions<ResultValue> = defaultOptions,\n): DelegationStruct<Hex>[] | DelegationStruct<Uint8Array>[] {\n  // it's possible to short circuit for empty delegations, but due to the\n  // complexity of the input type, and the relative infrequency of empty delegations,\n  // it's not worthwhile.\n\n  const decodedStructs = decodeSingle(\n    DELEGATION_ARRAY_ABI_TYPES,\n    encoded,\n    // return types cannot be inferred from complex ABI types, so we must assert the type\n  ) as DecodedDelegation[];\n\n  if (options.out === 'bytes') {\n    return decodedStructs.map((struct) =>\n      delegationFromDecodedDelegation(struct, bytesLikeToBytes),\n    );\n  }\n  return decodedStructs.map((struct) =>\n    delegationFromDecodedDelegation(struct, bytesLikeToHex),\n  );\n}\n\n/**\n * Calculates the hash of a delegation for signing purposes.\n * The hash is computed by encoding the delegation parameters with the delegation typehash\n * and then applying keccak256 hashing.\n *\n * @param delegation - The delegation to hash.\n * @param options - Encoding options. Defaults to { out: 'hex' }.\n * @returns The keccak256 hash of the encoded delegation as a hex string (default) or Uint8Array.\n */\nexport function hashDelegation(\n  delegation: DelegationStruct,\n  options?: EncodingOptions<'hex'>,\n): Hex;\nexport function hashDelegation(\n  delegation: DelegationStruct,\n  options: EncodingOptions<'bytes'>,\n): Uint8Array;\n/**\n * Calculates the hash of a delegation for signing purposes.\n * The hash is computed by encoding the delegation parameters with the delegation typehash\n * and then applying keccak256 hashing.\n *\n * @param delegation - The delegation to hash.\n * @param options - Encoding options. Defaults to { out: 'hex' }.\n * @returns The keccak256 hash of the encoded delegation as a hex string (default) or Uint8Array.\n */\nexport function hashDelegation(\n  delegation: DelegationStruct,\n  options: EncodingOptions<ResultValue> = defaultOptions,\n): Hex | Uint8Array {\n  const encoded = encode(\n    ['bytes32', 'address', 'address', 'bytes32', 'bytes32', 'uint256'],\n    [\n      DELEGATION_TYPEHASH,\n      delegation.delegate,\n      delegation.delegator,\n      delegation.authority,\n      getCaveatsArrayHash(delegation.caveats),\n      delegation.salt,\n    ],\n  );\n  const hash = keccak256(encoded);\n  return prepareResult(hash, options);\n}\n\n/**\n * Calculates the hash of an array of caveats. The caveats are individually abi\n * encoded and hashed, and concatenated. The resulting byte array is then\n * hashed to produce the CaveatsArrayHash.\n *\n * @param caveats - The array of caveats to hash.\n * @returns The keccak256 hash of the encoded caveat array.\n */\nfunction getCaveatsArrayHash(caveats: CaveatStruct[]): Uint8Array {\n  const byteLength = 32 * caveats.length;\n  const encoded = new Uint8Array(byteLength);\n\n  for (let i = 0; i < caveats.length; i++) {\n    const caveat = caveats[i];\n    if (!caveat) {\n      throw new Error(`Caveat was undefined at index ${i}`);\n    }\n    const caveatHash = getCaveatHash(caveat);\n    encoded.set(caveatHash, i * 32);\n  }\n\n  return keccak256(encoded);\n}\n\n/**\n * Calculates the hash of a single caveat.\n * @param caveat - The caveat to hash.\n * @returns The keccak256 hash of the encoded caveat.\n */\nfunction getCaveatHash(caveat: CaveatStruct): Uint8Array {\n  const termsBytes =\n    typeof caveat.terms === 'string' ? hexToBytes(caveat.terms) : caveat.terms;\n\n  const termsHash = keccak256(termsBytes);\n\n  const encoded = encode(\n    ['bytes32', 'address', 'bytes32'],\n    [CAVEAT_TYPEHASH, caveat.enforcer, termsHash],\n  );\n  const hash = keccak256(encoded);\n  return hash;\n}\n"]}