{"version":3,"sources":["../src/toMetaMaskSmartAccount.ts","../src/signer.ts","../src/signatures.ts","../src/actions/caveatEnforcerClient.ts","../src/actions/infuraBundlerClient.ts"],"sourcesContent":["import {\n  EIP7702StatelessDeleGator,\n  HybridDeleGator,\n  MultiSigDeleGator,\n} from '@metamask/delegation-abis';\nimport { type Address, type Hex } from 'viem';\nimport {\n  entryPoint07Abi,\n  toPackedUserOperation,\n  toSmartAccount,\n} from 'viem/account-abstraction';\n\nimport { isValid7702Implementation } from './actions/isValid7702Implementation';\nimport { Implementation } from './constants';\nimport { getCounterfactualAccountData } from './counterfactualAccountData';\nimport {\n  SIGNABLE_DELEGATION_TYPED_DATA,\n  toDelegationStruct,\n} from './delegation';\nimport { entryPointGetNonce as _getNonce } from './DelegationFramework/EntryPoint/read';\nimport { getDeleGatorEnvironment } from './delegatorEnvironment';\nimport { encodeCallsForCaller } from './encodeCalls';\nimport { resolveSigner } from './signer';\nimport type {\n  Call,\n  ToMetaMaskSmartAccountParameters,\n  ToMetaMaskSmartAccountReturnType,\n  SignDelegationParams,\n  SignUserOperationParams,\n  AbiByImplementation,\n} from './types';\nimport { SIGNABLE_USER_OP_TYPED_DATA } from './userOp';\n\nconst ENTRYPOINT_VERSION = '0.7' as const;\n\n/**\n * Creates a MetaMask DeleGator smart account instance.\n *\n * @template TImplementation - The type of implementation, extending Implementation.\n * @param params - The parameters for creating the smart account.\n * @returns A promise that resolves to a MetaMask DeleGator smart account instance.\n * @description\n * This function sets up a MetaMask DeleGator smart account with the specified implementation.\n * It handles both deployed accounts, and counterfactual accounts.\n * A caller may specify a DeleGator environment, otherwise the environment will be inferred from the chain.\n */\nexport async function toMetaMaskSmartAccount<\n  TImplementation extends Implementation,\n>(\n  params: ToMetaMaskSmartAccountParameters<TImplementation>,\n): Promise<ToMetaMaskSmartAccountReturnType<TImplementation>> {\n  const {\n    client,\n    client: { chain },\n    implementation,\n  } = params;\n\n  if (!chain) {\n    throw new Error('Chain not specified');\n  }\n\n  const signer = resolveSigner({\n    implementation,\n    signer: params.signer,\n  });\n\n  const environment = params.environment ?? getDeleGatorEnvironment(chain.id);\n\n  let address: Address, factoryData: Hex | undefined;\n\n  if (params.address) {\n    factoryData = undefined;\n    address = params.address;\n  } else {\n    if (implementation === Implementation.Stateless7702) {\n      throw new Error('Stateless7702 does not support counterfactual accounts');\n    }\n\n    const accountData = await getCounterfactualAccountData({\n      factory: environment.SimpleFactory,\n      implementations: environment.implementations,\n      implementation,\n      deployParams: params.deployParams,\n      deploySalt: params.deploySalt,\n    });\n\n    address = accountData.address;\n    factoryData = accountData.factoryData;\n  }\n\n  const entryPoint = {\n    abi: entryPoint07Abi,\n    address: environment.EntryPoint,\n    version: ENTRYPOINT_VERSION,\n  } as const;\n\n  const { abi, contractName } = {\n    [Implementation.Hybrid]: {\n      contractName: 'HybridDeleGator',\n      abi: HybridDeleGator.abi,\n    },\n    [Implementation.MultiSig]: {\n      contractName: 'MultiSigDeleGator',\n      abi: MultiSigDeleGator.abi,\n    },\n    [Implementation.Stateless7702]: {\n      contractName: 'EIP7702StatelessDeleGator',\n      abi: EIP7702StatelessDeleGator.abi,\n    },\n  }[implementation] as {\n    contractName: string;\n    abi: AbiByImplementation[TImplementation];\n  };\n\n  const getFactoryArgs = async () => {\n    if (factoryData === undefined) {\n      throw new Error(\n        'Deploy params were not provided, so factory args cannot be inferred',\n      );\n    }\n    return {\n      factoryData,\n      factory: environment.SimpleFactory,\n    };\n  };\n\n  const signDelegation = async (delegationParams: SignDelegationParams) => {\n    const { delegation, chainId } = delegationParams;\n\n    const delegationStruct = toDelegationStruct({\n      ...delegation,\n      signature: '0x',\n    });\n\n    const signature = signer.signTypedData({\n      domain: {\n        chainId: chainId ?? chain.id,\n        name: 'DelegationManager',\n        version: '1',\n        verifyingContract: environment.DelegationManager,\n      },\n      types: SIGNABLE_DELEGATION_TYPED_DATA,\n      primaryType: 'Delegation',\n      message: delegationStruct,\n    });\n\n    return signature;\n  };\n\n  const signUserOperation = async (userOpParams: SignUserOperationParams) => {\n    const { chainId } = userOpParams;\n\n    const packedUserOp = toPackedUserOperation({\n      sender: address,\n      ...userOpParams,\n      signature: '0x',\n    });\n\n    const signature = await signer.signTypedData({\n      domain: {\n        chainId: chainId ?? chain.id,\n        name: contractName,\n        version: '1',\n        verifyingContract: address,\n      },\n      types: SIGNABLE_USER_OP_TYPED_DATA,\n      primaryType: 'PackedUserOperation',\n      message: { ...packedUserOp, entryPoint: entryPoint.address },\n    });\n\n    return signature;\n  };\n\n  const getAddress = async () => address;\n\n  const getNonce = async () =>\n    _getNonce({\n      client,\n      entryPoint: environment.EntryPoint,\n      contractAddress: address,\n      key: 0n,\n    });\n\n  const encodeCalls = async (calls: readonly Call[]) =>\n    encodeCallsForCaller(address, calls);\n\n  const smartAccount = await toSmartAccount({\n    abi,\n    client,\n    entryPoint,\n    environment,\n    getAddress,\n    getFactoryArgs,\n    encodeCalls,\n    getNonce,\n    signUserOperation,\n    signDelegation,\n    ...signer,\n  });\n\n  // Override isDeployed only for EIP-7702 implementation to check proper delegation code\n  if (implementation === Implementation.Stateless7702) {\n    return {\n      ...smartAccount,\n      isDeployed: async () =>\n        isValid7702Implementation({\n          client,\n          accountAddress: address,\n          environment,\n        }),\n    };\n  }\n\n  // For other implementations, use the default isDeployed behavior\n  return smartAccount;\n}\n","import { concat } from 'viem';\nimport type {\n  Address,\n  SignableMessage,\n  TypedData,\n  TypedDataDefinition,\n} from 'viem';\nimport type { SignReturnType as WebAuthnSignReturnType } from 'webauthn-p256';\n\nimport { Implementation } from './constants';\nimport { aggregateSignature } from './signatures';\nimport type {\n  AccountSignerConfig,\n  HybridSignerConfig,\n  InternalSigner,\n  MultiSigSignerConfig,\n  SignerConfigByImplementation,\n  Stateless7702SignerConfig,\n  WalletSignerConfig,\n} from './types';\nimport {\n  createDummyWebAuthnSignature,\n  encodeDeleGatorSignature,\n} from './webAuthn';\n\n// A valid ECDSA signature, this must be able to ecrecover an address, otherwise the contracts will revert in isValidSignature\nconst EOA_STUB_SIGNATURE =\n  '0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000011b' as const;\n\nconst resolveSignerFromWalletConfig = (\n  config: WalletSignerConfig,\n): InternalSigner => {\n  return {\n    signMessage: config.walletClient.signMessage,\n    signTypedData: async (typedData) => {\n      // todo: figure out this type so that we don't need the type assertion\n      return config.walletClient.signTypedData(typedData as any);\n    },\n    getStubSignature: async () => EOA_STUB_SIGNATURE,\n  };\n};\n\nconst resolveSignerFromAccountConfig = (config: AccountSignerConfig) => {\n  return {\n    signMessage: config.account.signMessage,\n    signTypedData: config.account.signTypedData,\n    getStubSignature: async () => EOA_STUB_SIGNATURE,\n  };\n};\n\nconst resolveHybridSigner = (config: HybridSignerConfig): InternalSigner => {\n  if ('walletClient' in config) {\n    return resolveSignerFromWalletConfig(config);\n  } else if ('account' in config) {\n    const { signMessage, signTypedData, getStubSignature } =\n      resolveSignerFromAccountConfig(config);\n    if (!signMessage) {\n      throw new Error('Account does not support signMessage');\n    }\n    if (!signTypedData) {\n      throw new Error('Account does not support signTypedData');\n    }\n    return {\n      signMessage,\n      signTypedData,\n      getStubSignature,\n    };\n  }\n  const { keyId, webAuthnAccount } = config;\n\n  if (webAuthnAccount.type !== 'webAuthn') {\n    throw new Error('Account is not a webAuthn account');\n  }\n\n  const encodeSignature = ({ signature, webauthn }: WebAuthnSignReturnType) =>\n    encodeDeleGatorSignature(\n      keyId,\n      signature,\n      webauthn.clientDataJSON,\n      webauthn.authenticatorData,\n    );\n\n  const signMessage = async (args: { message: SignableMessage }) =>\n    webAuthnAccount.signMessage(args).then(encodeSignature);\n  const signTypedData = async <\n    const TTypedData extends TypedData | Record<string, unknown>,\n    TPrimaryType extends keyof TTypedData | 'EIP712Domain' = keyof TTypedData,\n  >(\n    typedDataDefinition: TypedDataDefinition<TTypedData, TPrimaryType>,\n  ) => webAuthnAccount.signTypedData(typedDataDefinition).then(encodeSignature);\n\n  const getStubSignature = async () => createDummyWebAuthnSignature(keyId);\n\n  return {\n    signMessage,\n    signTypedData,\n    getStubSignature,\n  };\n};\n\nconst resolveMultiSigSigner = (\n  config: MultiSigSignerConfig,\n): InternalSigner => {\n  const resolvedSigners = config.map((signer) => {\n    let individualSignMessage: InternalSigner['signMessage'];\n    let individualSignTypedData: InternalSigner['signTypedData'];\n    let address: Address;\n    if ('walletClient' in signer) {\n      const { signMessage, signTypedData } =\n        resolveSignerFromWalletConfig(signer);\n      individualSignMessage = signMessage;\n      individualSignTypedData = signTypedData;\n\n      address = signer.walletClient.account.address;\n    } else {\n      const { signMessage, signTypedData } =\n        resolveSignerFromAccountConfig(signer);\n      if (!signMessage) {\n        throw new Error('Account does not support signMessage');\n      }\n      if (!signTypedData) {\n        throw new Error('Account does not support signTypedData');\n      }\n\n      individualSignMessage = signMessage;\n      individualSignTypedData = signTypedData;\n\n      address = signer.account.address;\n    }\n    return {\n      address,\n      individualSignMessage,\n      individualSignTypedData,\n    };\n  });\n\n  const signMessage = async (args: { message: SignableMessage }) => {\n    const addressAndSignatures = resolvedSigners.map(\n      async ({ individualSignMessage, address }) => ({\n        signature: await individualSignMessage(args),\n        signer: address,\n        type: 'ECDSA' as const,\n      }),\n    );\n\n    const signatures = await Promise.all(addressAndSignatures);\n\n    return aggregateSignature({\n      signatures,\n    });\n  };\n\n  const signTypedData = async <\n    const TTypedData extends TypedData | Record<string, unknown>,\n    TPrimaryType extends keyof TTypedData | 'EIP712Domain' = keyof TTypedData,\n  >(\n    typedDataDefinition: TypedDataDefinition<TTypedData, TPrimaryType>,\n  ) => {\n    const addressAndSignatures = resolvedSigners.map(\n      async ({ individualSignTypedData, address }) => ({\n        signature: await individualSignTypedData(typedDataDefinition),\n        signer: address,\n        type: 'ECDSA' as const,\n      }),\n    );\n\n    const signatures = await Promise.all(addressAndSignatures);\n\n    return aggregateSignature({\n      signatures,\n    });\n  };\n\n  const getStubSignature = async () =>\n    concat(resolvedSigners.map(() => EOA_STUB_SIGNATURE));\n\n  return {\n    signMessage,\n    signTypedData,\n    getStubSignature,\n  };\n};\n\nconst resolveStateless7702Signer = (\n  config: Stateless7702SignerConfig,\n): InternalSigner => {\n  if ('walletClient' in config) {\n    return resolveSignerFromWalletConfig(config);\n  } else if ('account' in config) {\n    const { signMessage, signTypedData, getStubSignature } =\n      resolveSignerFromAccountConfig(config);\n    if (!signMessage) {\n      throw new Error('Account does not support signMessage');\n    }\n    if (!signTypedData) {\n      throw new Error('Account does not support signTypedData');\n    }\n\n    return {\n      signMessage,\n      signTypedData,\n      getStubSignature,\n    };\n  }\n\n  throw new Error('Invalid signer config');\n};\n\nexport const resolveSigner = <TImplementation extends Implementation>(config: {\n  implementation: TImplementation;\n  signer: SignerConfigByImplementation<TImplementation>;\n}): InternalSigner => {\n  const { implementation } = config;\n\n  if (implementation === Implementation.Hybrid) {\n    return resolveHybridSigner(config.signer as HybridSignerConfig);\n  } else if (implementation === Implementation.MultiSig) {\n    return resolveMultiSigSigner(config.signer as MultiSigSignerConfig);\n  } else if (implementation === Implementation.Stateless7702) {\n    return resolveStateless7702Signer(\n      config.signer as Stateless7702SignerConfig,\n    );\n  }\n  throw new Error(`Implementation type '${implementation}' not supported`);\n};\n","import type { Address, Hex } from 'viem';\nimport { concat } from 'viem';\n\nconst signatureTypes = ['ECDSA'] as const;\n\nexport type SignatureType = (typeof signatureTypes)[number];\n\n/**\n * Represents a partial signature that can be aggregated with others.\n */\nexport type PartialSignature = {\n  signer: Address;\n  signature: Hex;\n  type: SignatureType;\n};\n\n/**\n * Aggregates signatures into a single signature as expected by the MultiSig implementation.\n * @param params - The parameters for signature aggregation.\n * @param params.signatures - The array of partial signatures to aggregate.\n * @returns The aggregated signature.\n */\nexport const aggregateSignature = ({\n  signatures,\n}: {\n  signatures: PartialSignature[];\n}): Hex => {\n  if (signatures.length === 0) {\n    return '0x';\n  }\n\n  for (const { type } of signatures) {\n    if (!signatureTypes.includes(type)) {\n      throw new Error(`Invalid signature type: ${type}`);\n    }\n  }\n\n  // Sort signatures by signer address as required by MultiSig implementation\n  const sortedSignatures = [...signatures].sort((a, b) =>\n    a.signer.localeCompare(b.signer),\n  );\n\n  // Concatenate all signatures\n  return concat(sortedSignatures.map(({ signature }) => signature));\n};\n\n/**\n * Type definition for the aggregateSignature function parameters.\n */\nexport type AggregateSignatureParams = {\n  signatures: PartialSignature[];\n};\n","import type { Client, Transport, Chain, Account } from 'viem';\n\nimport type { DeleGatorEnvironment } from '../types';\nimport {\n  caveatEnforcerActions,\n  type CaveatEnforcerParams,\n  type PeriodTransferResult,\n  type StreamingResult,\n} from './getCaveatAvailableAmount';\n\n/**\n * Type for client extended with caveat enforcer actions.\n */\nexport type CaveatEnforcerClient<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n> = Client<TTransport, TChain, TAccount> &\n  ReturnType<ReturnType<typeof caveatEnforcerActions>>;\n\n/**\n * Create a viem client extended with caveat enforcer actions.\n *\n * @param params - The parameters object.\n * @param params.client - The viem client.\n * @param params.environment - The delegator environment.\n * @returns The extended client with caveat enforcer actions.\n */\nexport function createCaveatEnforcerClient<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n>({\n  client,\n  environment,\n}: {\n  client: Client<TTransport, TChain, TAccount>;\n  environment: DeleGatorEnvironment;\n}): CaveatEnforcerClient<TTransport, TChain, TAccount> {\n  return client.extend(caveatEnforcerActions({ environment }));\n}\n\n// Re-export types for convenience\nexport type { CaveatEnforcerParams, PeriodTransferResult, StreamingResult };\n","import type { Transport, Chain, Hex, Client, Account } from 'viem';\nimport {\n  createBundlerClient,\n  type BundlerClient,\n  type BundlerClientConfig,\n  type SmartAccount,\n} from 'viem/account-abstraction';\n\n/**\n * Gas price tiers returned by pimlico_getUserOperationGasPrice\n */\nexport type GasPriceTier = {\n  /** Maximum fee per gas in hex format */\n  maxFeePerGas: Hex;\n  /** Maximum priority fee per gas in hex format */\n  maxPriorityFeePerGas: Hex;\n};\n\n/**\n * Response from pimlico_getUserOperationGasPrice RPC method\n */\nexport type UserOperationGasPriceResponse = {\n  /** Slow gas price tier */\n  slow: GasPriceTier;\n  /** Standard gas price tier */\n  standard: GasPriceTier;\n  /** Fast gas price tier */\n  fast: GasPriceTier;\n};\n\n/**\n * Pimlico bundler schema for type-safe RPC method calls\n */\n/* eslint-disable @typescript-eslint/naming-convention */\ntype PimlicoBundlerSchema = [\n  {\n    Method: 'pimlico_getUserOperationGasPrice';\n    Parameters: [];\n    ReturnType: UserOperationGasPriceResponse;\n  },\n];\n\n/**\n * Infura bundler actions for extending bundler clients.\n *\n * @returns A function that takes a client and returns the client extension with Infura bundler actions.\n */\nconst infuraBundlerActions = () => (client: Client) => ({\n  /**\n   * Get user operation gas prices from Infura bundler.\n   * Calls the pimlico_getUserOperationGasPrice RPC method.\n   *\n   * @returns Promise resolving to gas price tiers (slow, standard, fast).\n   * @example\n   * ```typescript\n   * const gasPrices = await bundlerClient.getUserOperationGasPrice();\n   * console.log(gasPrices.standard.maxFeePerGas);\n   * ```\n   */\n  async getUserOperationGasPrice(): Promise<UserOperationGasPriceResponse> {\n    const pimlicoClient = client as Client<\n      Transport,\n      Chain | undefined,\n      Account | undefined,\n      PimlicoBundlerSchema\n    >;\n\n    return await pimlicoClient.request({\n      method: 'pimlico_getUserOperationGasPrice',\n      params: [],\n    });\n  },\n});\n\n/**\n * Type for bundler client extended with Infura bundler actions.\n */\nexport type InfuraBundlerClient<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends SmartAccount | undefined = SmartAccount | undefined,\n> = BundlerClient<TTransport, TChain, TAccount> & {\n  /**\n   * Get user operation gas prices from Infura bundler.\n   * Calls the pimlico_getUserOperationGasPrice RPC method.\n   *\n   * @returns Promise resolving to gas price tiers (slow, standard, fast).\n   */\n  getUserOperationGasPrice(): Promise<UserOperationGasPriceResponse>;\n};\n\n/**\n * Creates an Infura bundler client extended with Infura bundler actions.\n *\n * This is a wrapper around viem's createBundlerClient that extends it with\n * the getUserOperationGasPrice method for retrieving gas prices from Pimlico's\n * bundler infrastructure via Infura's proxy.\n *\n * @param config - Configuration for the bundler client.\n * @returns Extended bundler client with Infura bundler actions.\n * @example\n * ```typescript\n * import { createPublicClient, http } from 'viem';\n * import { sepolia } from 'viem/chains';\n * import { createInfuraBundlerClient } from '@metamask/delegation-toolkit';\n *\n * const publicClient = createPublicClient({\n *   chain: sepolia,\n *   transport: http('https://sepolia.infura.io/v3/YOUR_API_KEY'),\n * });\n *\n * const bundlerClient = createInfuraBundlerClient({\n *   client: publicClient,\n *   transport: http('https://sepolia.infura.io/v3/YOUR_API_KEY'),\n *   chain: sepolia,\n * });\n *\n * // Use standard bundler methods\n * const userOpHash = await bundlerClient.sendUserOperation({...});\n *\n * // Use Infura specific methods\n * const gasPrices = await bundlerClient.getUserOperationGasPrice();\n * ```\n */\nexport function createInfuraBundlerClient<\n  TTransport extends Transport,\n  TChain extends Chain | undefined = undefined,\n  TAccount extends SmartAccount | undefined = undefined,\n>(\n  config: BundlerClientConfig<TTransport, TChain, TAccount>,\n): InfuraBundlerClient<TTransport, TChain, TAccount> {\n  // Create the base bundler client using viem's function\n  const baseBundlerClient = createBundlerClient(config);\n\n  // Extend the client with Infura bundler actions\n  return baseBundlerClient.extend(\n    infuraBundlerActions(),\n  ) as unknown as InfuraBundlerClient<TTransport, TChain, TAccount>;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;;;ACVP,SAAS,UAAAA,eAAc;;;ACCvB,SAAS,cAAc;AAEvB,IAAM,iBAAiB,CAAC,OAAO;AAmBxB,IAAM,qBAAqB,CAAC;AAAA,EACjC;AACF,MAEW;AACT,MAAI,WAAW,WAAW,GAAG;AAC3B,WAAO;AAAA,EACT;AAEA,aAAW,EAAE,KAAK,KAAK,YAAY;AACjC,QAAI,CAAC,eAAe,SAAS,IAAI,GAAG;AAClC,YAAM,IAAI,MAAM,2BAA2B,IAAI,EAAE;AAAA,IACnD;AAAA,EACF;AAGA,QAAM,mBAAmB,CAAC,GAAG,UAAU,EAAE;AAAA,IAAK,CAAC,GAAG,MAChD,EAAE,OAAO,cAAc,EAAE,MAAM;AAAA,EACjC;AAGA,SAAO,OAAO,iBAAiB,IAAI,CAAC,EAAE,UAAU,MAAM,SAAS,CAAC;AAClE;;;ADlBA,IAAM,qBACJ;AAEF,IAAM,gCAAgC,CACpC,WACmB;AACnB,SAAO;AAAA,IACL,aAAa,OAAO,aAAa;AAAA,IACjC,eAAe,OAAO,cAAc;AAElC,aAAO,OAAO,aAAa,cAAc,SAAgB;AAAA,IAC3D;AAAA,IACA,kBAAkB,YAAY;AAAA,EAChC;AACF;AAEA,IAAM,iCAAiC,CAAC,WAAgC;AACtE,SAAO;AAAA,IACL,aAAa,OAAO,QAAQ;AAAA,IAC5B,eAAe,OAAO,QAAQ;AAAA,IAC9B,kBAAkB,YAAY;AAAA,EAChC;AACF;AAEA,IAAM,sBAAsB,CAAC,WAA+C;AAC1E,MAAI,kBAAkB,QAAQ;AAC5B,WAAO,8BAA8B,MAAM;AAAA,EAC7C,WAAW,aAAa,QAAQ;AAC9B,UAAM,EAAE,aAAAC,cAAa,eAAAC,gBAAe,kBAAAC,kBAAiB,IACnD,+BAA+B,MAAM;AACvC,QAAI,CAACF,cAAa;AAChB,YAAM,IAAI,MAAM,sCAAsC;AAAA,IACxD;AACA,QAAI,CAACC,gBAAe;AAClB,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC1D;AACA,WAAO;AAAA,MACL,aAAAD;AAAA,MACA,eAAAC;AAAA,MACA,kBAAAC;AAAA,IACF;AAAA,EACF;AACA,QAAM,EAAE,OAAO,gBAAgB,IAAI;AAEnC,MAAI,gBAAgB,SAAS,YAAY;AACvC,UAAM,IAAI,MAAM,mCAAmC;AAAA,EACrD;AAEA,QAAM,kBAAkB,CAAC,EAAE,WAAW,SAAS,MAC7C;AAAA,IACE;AAAA,IACA;AAAA,IACA,SAAS;AAAA,IACT,SAAS;AAAA,EACX;AAEF,QAAM,cAAc,OAAO,SACzB,gBAAgB,YAAY,IAAI,EAAE,KAAK,eAAe;AACxD,QAAM,gBAAgB,OAIpB,wBACG,gBAAgB,cAAc,mBAAmB,EAAE,KAAK,eAAe;AAE5E,QAAM,mBAAmB,YAAY,6BAA6B,KAAK;AAEvE,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAM,wBAAwB,CAC5B,WACmB;AACnB,QAAM,kBAAkB,OAAO,IAAI,CAAC,WAAW;AAC7C,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI,kBAAkB,QAAQ;AAC5B,YAAM,EAAE,aAAAF,cAAa,eAAAC,eAAc,IACjC,8BAA8B,MAAM;AACtC,8BAAwBD;AACxB,gCAA0BC;AAE1B,gBAAU,OAAO,aAAa,QAAQ;AAAA,IACxC,OAAO;AACL,YAAM,EAAE,aAAAD,cAAa,eAAAC,eAAc,IACjC,+BAA+B,MAAM;AACvC,UAAI,CAACD,cAAa;AAChB,cAAM,IAAI,MAAM,sCAAsC;AAAA,MACxD;AACA,UAAI,CAACC,gBAAe;AAClB,cAAM,IAAI,MAAM,wCAAwC;AAAA,MAC1D;AAEA,8BAAwBD;AACxB,gCAA0BC;AAE1B,gBAAU,OAAO,QAAQ;AAAA,IAC3B;AACA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,CAAC;AAED,QAAM,cAAc,OAAO,SAAuC;AAChE,UAAM,uBAAuB,gBAAgB;AAAA,MAC3C,OAAO,EAAE,uBAAuB,QAAQ,OAAO;AAAA,QAC7C,WAAW,MAAM,sBAAsB,IAAI;AAAA,QAC3C,QAAQ;AAAA,QACR,MAAM;AAAA,MACR;AAAA,IACF;AAEA,UAAM,aAAa,MAAM,QAAQ,IAAI,oBAAoB;AAEzD,WAAO,mBAAmB;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,QAAM,gBAAgB,OAIpB,wBACG;AACH,UAAM,uBAAuB,gBAAgB;AAAA,MAC3C,OAAO,EAAE,yBAAyB,QAAQ,OAAO;AAAA,QAC/C,WAAW,MAAM,wBAAwB,mBAAmB;AAAA,QAC5D,QAAQ;AAAA,QACR,MAAM;AAAA,MACR;AAAA,IACF;AAEA,UAAM,aAAa,MAAM,QAAQ,IAAI,oBAAoB;AAEzD,WAAO,mBAAmB;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,QAAM,mBAAmB,YACvBE,QAAO,gBAAgB,IAAI,MAAM,kBAAkB,CAAC;AAEtD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAM,6BAA6B,CACjC,WACmB;AACnB,MAAI,kBAAkB,QAAQ;AAC5B,WAAO,8BAA8B,MAAM;AAAA,EAC7C,WAAW,aAAa,QAAQ;AAC9B,UAAM,EAAE,aAAa,eAAe,iBAAiB,IACnD,+BAA+B,MAAM;AACvC,QAAI,CAAC,aAAa;AAChB,YAAM,IAAI,MAAM,sCAAsC;AAAA,IACxD;AACA,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC1D;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,QAAM,IAAI,MAAM,uBAAuB;AACzC;AAEO,IAAM,gBAAgB,CAAyC,WAGhD;AACpB,QAAM,EAAE,eAAe,IAAI;AAE3B,MAAI,0CAA0C;AAC5C,WAAO,oBAAoB,OAAO,MAA4B;AAAA,EAChE,WAAW,8CAA4C;AACrD,WAAO,sBAAsB,OAAO,MAA8B;AAAA,EACpE,WAAW,wDAAiD;AAC1D,WAAO;AAAA,MACL,OAAO;AAAA,IACT;AAAA,EACF;AACA,QAAM,IAAI,MAAM,wBAAwB,cAAc,iBAAiB;AACzE;;;AD/LA,IAAM,qBAAqB;AAa3B,eAAsB,uBAGpB,QAC4D;AAC5D,QAAM;AAAA,IACJ;AAAA,IACA,QAAQ,EAAE,MAAM;AAAA,IAChB;AAAA,EACF,IAAI;AAEJ,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,MAAM,qBAAqB;AAAA,EACvC;AAEA,QAAM,SAAS,cAAc;AAAA,IAC3B;AAAA,IACA,QAAQ,OAAO;AAAA,EACjB,CAAC;AAED,QAAM,cAAc,OAAO,eAAe,wBAAwB,MAAM,EAAE;AAE1E,MAAI,SAAkB;AAEtB,MAAI,OAAO,SAAS;AAClB,kBAAc;AACd,cAAU,OAAO;AAAA,EACnB,OAAO;AACL,QAAI,wDAAiD;AACnD,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AAEA,UAAM,cAAc,MAAM,6BAA6B;AAAA,MACrD,SAAS,YAAY;AAAA,MACrB,iBAAiB,YAAY;AAAA,MAC7B;AAAA,MACA,cAAc,OAAO;AAAA,MACrB,YAAY,OAAO;AAAA,IACrB,CAAC;AAED,cAAU,YAAY;AACtB,kBAAc,YAAY;AAAA,EAC5B;AAEA,QAAM,aAAa;AAAA,IACjB,KAAK;AAAA,IACL,SAAS,YAAY;AAAA,IACrB,SAAS;AAAA,EACX;AAEA,QAAM,EAAE,KAAK,aAAa,IAAI;AAAA,IAC5B,sBAAsB,GAAG;AAAA,MACvB,cAAc;AAAA,MACd,KAAK,gBAAgB;AAAA,IACvB;AAAA,IACA,0BAAwB,GAAG;AAAA,MACzB,cAAc;AAAA,MACd,KAAK,kBAAkB;AAAA,IACzB;AAAA,IACA,oCAA6B,GAAG;AAAA,MAC9B,cAAc;AAAA,MACd,KAAK,0BAA0B;AAAA,IACjC;AAAA,EACF,EAAE,cAAc;AAKhB,QAAM,iBAAiB,YAAY;AACjC,QAAI,gBAAgB,QAAW;AAC7B,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,MACL;AAAA,MACA,SAAS,YAAY;AAAA,IACvB;AAAA,EACF;AAEA,QAAMC,kBAAiB,OAAO,qBAA2C;AACvE,UAAM,EAAE,YAAY,QAAQ,IAAI;AAEhC,UAAM,mBAAmB,mBAAmB;AAAA,MAC1C,GAAG;AAAA,MACH,WAAW;AAAA,IACb,CAAC;AAED,UAAM,YAAY,OAAO,cAAc;AAAA,MACrC,QAAQ;AAAA,QACN,SAAS,WAAW,MAAM;AAAA,QAC1B,MAAM;AAAA,QACN,SAAS;AAAA,QACT,mBAAmB,YAAY;AAAA,MACjC;AAAA,MACA,OAAO;AAAA,MACP,aAAa;AAAA,MACb,SAAS;AAAA,IACX,CAAC;AAED,WAAO;AAAA,EACT;AAEA,QAAMC,qBAAoB,OAAO,iBAA0C;AACzE,UAAM,EAAE,QAAQ,IAAI;AAEpB,UAAM,eAAe,sBAAsB;AAAA,MACzC,QAAQ;AAAA,MACR,GAAG;AAAA,MACH,WAAW;AAAA,IACb,CAAC;AAED,UAAM,YAAY,MAAM,OAAO,cAAc;AAAA,MAC3C,QAAQ;AAAA,QACN,SAAS,WAAW,MAAM;AAAA,QAC1B,MAAM;AAAA,QACN,SAAS;AAAA,QACT,mBAAmB;AAAA,MACrB;AAAA,MACA,OAAO;AAAA,MACP,aAAa;AAAA,MACb,SAAS,EAAE,GAAG,cAAc,YAAY,WAAW,QAAQ;AAAA,IAC7D,CAAC;AAED,WAAO;AAAA,EACT;AAEA,QAAM,aAAa,YAAY;AAE/B,QAAM,WAAW,YACf,KAAU;AAAA,IACR;AAAA,IACA,YAAY,YAAY;AAAA,IACxB,iBAAiB;AAAA,IACjB,KAAK;AAAA,EACP,CAAC;AAEH,QAAM,cAAc,OAAO,UACzB,qBAAqB,SAAS,KAAK;AAErC,QAAM,eAAe,MAAM,eAAe;AAAA,IACxC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,mBAAAA;AAAA,IACA,gBAAAD;AAAA,IACA,GAAG;AAAA,EACL,CAAC;AAGD,MAAI,wDAAiD;AACnD,WAAO;AAAA,MACL,GAAG;AAAA,MACH,YAAY,YACV,0BAA0B;AAAA,QACxB;AAAA,QACA,gBAAgB;AAAA,QAChB;AAAA,MACF,CAAC;AAAA,IACL;AAAA,EACF;AAGA,SAAO;AACT;;;AG3LO,SAAS,2BAId;AAAA,EACA;AAAA,EACA;AACF,GAGuD;AACrD,SAAO,OAAO,OAAO,sBAAsB,EAAE,YAAY,CAAC,CAAC;AAC7D;;;ACvCA;AAAA,EACE;AAAA,OAIK;AAyCP,IAAM,uBAAuB,MAAM,CAAC,YAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYtD,MAAM,2BAAmE;AACvE,UAAM,gBAAgB;AAOtB,WAAO,MAAM,cAAc,QAAQ;AAAA,MACjC,QAAQ;AAAA,MACR,QAAQ,CAAC;AAAA,IACX,CAAC;AAAA,EACH;AACF;AAoDO,SAAS,0BAKd,QACmD;AAEnD,QAAM,oBAAoB,oBAAoB,MAAM;AAGpD,SAAO,kBAAkB;AAAA,IACvB,qBAAqB;AAAA,EACvB;AACF;","names":["concat","signMessage","signTypedData","getStubSignature","concat","signDelegation","signUserOperation"]}