{"version":3,"sources":["../src/DelegationFramework/ERC20PeriodTransferEnforcer/index.ts","../src/DelegationFramework/ERC20PeriodTransferEnforcer/read.ts","../src/DelegationFramework/ERC20PeriodTransferEnforcer/methods/getAvailableAmount.ts","../src/DelegationFramework/ERC20StreamingEnforcer/index.ts","../src/DelegationFramework/ERC20StreamingEnforcer/read.ts","../src/DelegationFramework/ERC20StreamingEnforcer/methods/getAvailableAmount.ts","../src/DelegationFramework/MultiTokenPeriodEnforcer/index.ts","../src/DelegationFramework/MultiTokenPeriodEnforcer/read.ts","../src/DelegationFramework/MultiTokenPeriodEnforcer/methods/getAvailableAmount.ts","../src/DelegationFramework/NativeTokenPeriodTransferEnforcer/index.ts","../src/DelegationFramework/NativeTokenPeriodTransferEnforcer/read.ts","../src/DelegationFramework/NativeTokenPeriodTransferEnforcer/methods/getAvailableAmount.ts","../src/DelegationFramework/NativeTokenStreamingEnforcer/index.ts","../src/DelegationFramework/NativeTokenStreamingEnforcer/read.ts","../src/DelegationFramework/NativeTokenStreamingEnforcer/methods/getAvailableAmount.ts"],"sourcesContent":["import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { ERC20PeriodTransferEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationHash: Hex;\n  delegationManager: Address;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationHash,\n  delegationManager,\n  terms,\n}: ReadGetAvailableAmountParameters) => {\n  const [availableAmount, isNewPeriod, currentPeriod] = await readContract(\n    client,\n    {\n      address: contractAddress,\n      abi: ERC20PeriodTransferEnforcer.abi,\n      functionName: 'getAvailableAmount',\n      args: [delegationHash, delegationManager, terms],\n    },\n  );\n\n  return {\n    availableAmount,\n    isNewPeriod,\n    currentPeriod,\n  };\n};\n","import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { ERC20StreamingEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract, getBlock } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationManager: Address;\n  delegationHash: Hex;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationManager,\n  delegationHash,\n  terms,\n}: ReadGetAvailableAmountParameters) => {\n  // Get current block timestamp from blockchain\n  const currentBlock = await getBlock(client);\n  const currentTimestamp = currentBlock.timestamp;\n\n  // First, get the current state from the contract\n  const allowanceState = await readContract(client, {\n    address: contractAddress,\n    abi: ERC20StreamingEnforcer.abi,\n    functionName: 'streamingAllowances',\n    args: [delegationManager, delegationHash],\n  });\n\n  const [initialAmount, maxAmount, amountPerSecond, startTime, spent] =\n    allowanceState;\n\n  // Check if state exists (startTime != 0)\n  if (startTime !== 0n) {\n    // State exists, calculate available amount using the stored state\n    const availableAmount = getAvailableAmount({\n      initialAmount,\n      maxAmount,\n      amountPerSecond,\n      startTime,\n      spent,\n      currentTimestamp,\n    });\n\n    return {\n      availableAmount,\n    };\n  }\n\n  // State doesn't exist, decode terms and simulate with spent = 0\n  const decodedTerms = await readContract(client, {\n    address: contractAddress,\n    abi: ERC20StreamingEnforcer.abi,\n    functionName: 'getTermsInfo',\n    args: [terms],\n  });\n\n  const [\n    ,\n    decodedInitialAmount,\n    decodedMaxAmount,\n    decodedAmountPerSecond,\n    decodedStartTime,\n  ] = decodedTerms;\n\n  // Simulate using decoded terms with spent = 0\n  const availableAmount = getAvailableAmount({\n    initialAmount: decodedInitialAmount,\n    maxAmount: decodedMaxAmount,\n    amountPerSecond: decodedAmountPerSecond,\n    startTime: decodedStartTime,\n    spent: 0n,\n    currentTimestamp,\n  });\n\n  return {\n    availableAmount,\n  };\n};\n\n/**\n * Replicates the internal _getAvailableAmount logic from the smart contract.\n *\n * @param allowance - The allowance object containing all parameters.\n * @param allowance.initialAmount - The initial amount available.\n * @param allowance.maxAmount - The maximum amount allowed.\n * @param allowance.amountPerSecond - The amount streamed per second.\n * @param allowance.startTime - The start time of the streaming.\n * @param allowance.spent - The amount already spent.\n * @param allowance.currentTimestamp - The current timestamp.\n * @returns The available amount that can be spent.\n */\nfunction getAvailableAmount(allowance: {\n  initialAmount: bigint;\n  maxAmount: bigint;\n  amountPerSecond: bigint;\n  startTime: bigint;\n  spent: bigint;\n  currentTimestamp: bigint;\n}): bigint {\n  // If current time is before start time, nothing is available\n  if (allowance.currentTimestamp < allowance.startTime) {\n    return 0n;\n  }\n\n  // Calculate elapsed time since start\n  const elapsed = allowance.currentTimestamp - allowance.startTime;\n\n  // Calculate total unlocked amount\n  let unlocked = allowance.initialAmount + allowance.amountPerSecond * elapsed;\n\n  // Cap by max amount\n  if (unlocked > allowance.maxAmount) {\n    unlocked = allowance.maxAmount;\n  }\n\n  // If spent >= unlocked, nothing available\n  if (allowance.spent >= unlocked) {\n    return 0n;\n  }\n\n  // Return available amount\n  return unlocked - allowance.spent;\n}\n","import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { MultiTokenPeriodEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationHash: Hex;\n  delegationManager: Address;\n  terms: Hex;\n  args: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationHash,\n  delegationManager,\n  terms,\n  args,\n}: ReadGetAvailableAmountParameters) => {\n  const [availableAmount, isNewPeriod, currentPeriod] = await readContract(\n    client,\n    {\n      address: contractAddress,\n      abi: MultiTokenPeriodEnforcer.abi,\n      functionName: 'getAvailableAmount',\n      args: [delegationHash, delegationManager, terms, args],\n    },\n  );\n\n  return {\n    availableAmount,\n    isNewPeriod,\n    currentPeriod,\n  };\n};\n","import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { NativeTokenPeriodTransferEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationHash: Hex;\n  delegationManager: Address;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationHash,\n  delegationManager,\n  terms,\n}: ReadGetAvailableAmountParameters) => {\n  const [availableAmount, isNewPeriod, currentPeriod] = await readContract(\n    client,\n    {\n      address: contractAddress,\n      abi: NativeTokenPeriodTransferEnforcer.abi,\n      functionName: 'getAvailableAmount',\n      args: [delegationHash, delegationManager, terms],\n    },\n  );\n\n  return {\n    availableAmount,\n    isNewPeriod,\n    currentPeriod,\n  };\n};\n","import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { NativeTokenStreamingEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract, getBlock } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationManager: Address;\n  delegationHash: Hex;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationManager,\n  delegationHash,\n  terms,\n}: ReadGetAvailableAmountParameters) => {\n  // Get current block timestamp from blockchain\n  const currentBlock = await getBlock(client);\n  const currentTimestamp = currentBlock.timestamp;\n\n  // First, get the current state from the contract\n  const allowanceState = await readContract(client, {\n    address: contractAddress,\n    abi: NativeTokenStreamingEnforcer.abi,\n    functionName: 'streamingAllowances',\n    args: [delegationManager, delegationHash],\n  });\n\n  const [initialAmount, maxAmount, amountPerSecond, startTime, spent] =\n    allowanceState;\n\n  // Check if state exists (startTime != 0)\n  if (startTime !== 0n) {\n    // State exists, calculate available amount using the stored state\n    const availableAmount = getAvailableAmount({\n      initialAmount,\n      maxAmount,\n      amountPerSecond,\n      startTime,\n      spent,\n      currentTimestamp,\n    });\n\n    return {\n      availableAmount,\n    };\n  }\n\n  // State doesn't exist, decode terms and simulate with spent = 0\n  const decodedTerms = await readContract(client, {\n    address: contractAddress,\n    abi: NativeTokenStreamingEnforcer.abi,\n    functionName: 'getTermsInfo',\n    args: [terms],\n  });\n\n  const [\n    decodedInitialAmount,\n    decodedMaxAmount,\n    decodedAmountPerSecond,\n    decodedStartTime,\n  ] = decodedTerms;\n\n  // Simulate using decoded terms with spent = 0\n  const availableAmount = getAvailableAmount({\n    initialAmount: decodedInitialAmount,\n    maxAmount: decodedMaxAmount,\n    amountPerSecond: decodedAmountPerSecond,\n    startTime: decodedStartTime,\n    spent: 0n,\n    currentTimestamp,\n  });\n\n  return {\n    availableAmount,\n  };\n};\n\n/**\n * Replicates the internal _getAvailableAmount logic from the smart contract.\n *\n * @param allowance - The allowance object containing all parameters.\n * @param allowance.initialAmount - The initial amount available.\n * @param allowance.maxAmount - The maximum amount allowed.\n * @param allowance.amountPerSecond - The amount streamed per second.\n * @param allowance.startTime - The start time of the streaming.\n * @param allowance.spent - The amount already spent.\n * @param allowance.currentTimestamp - The current timestamp.\n * @returns The available amount that can be spent.\n */\nfunction getAvailableAmount(allowance: {\n  initialAmount: bigint;\n  maxAmount: bigint;\n  amountPerSecond: bigint;\n  startTime: bigint;\n  spent: bigint;\n  currentTimestamp: bigint;\n}): bigint {\n  // If current time is before start time, nothing is available\n  if (allowance.currentTimestamp < allowance.startTime) {\n    return 0n;\n  }\n\n  // Calculate elapsed time since start\n  const elapsed = allowance.currentTimestamp - allowance.startTime;\n\n  // Calculate total unlocked amount\n  let unlocked = allowance.initialAmount + allowance.amountPerSecond * elapsed;\n\n  // Cap by max amount\n  if (unlocked > allowance.maxAmount) {\n    unlocked = allowance.maxAmount;\n  }\n\n  // If spent >= unlocked, nothing available\n  if (allowance.spent >= unlocked) {\n    return 0n;\n  }\n\n  // Return available amount\n  return unlocked - allowance.spent;\n}\n"],"mappings":"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","names":["read_exports","read_exports","read","readContract","read","availableAmount","read_exports","read_exports","read","readContract","read","read_exports","read_exports","read","readContract","read","read_exports","read_exports","read","readContract","getBlock","read","availableAmount","getAvailableAmount"]}