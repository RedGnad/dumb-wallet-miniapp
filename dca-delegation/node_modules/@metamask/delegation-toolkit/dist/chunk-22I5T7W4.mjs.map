{"version":3,"sources":["../src/caveatBuilder/caveatBuilder.ts","../src/caveatBuilder/types.ts","../src/caveatBuilder/allowedCalldataBuilder.ts","../src/caveatBuilder/allowedMethodsBuilder.ts","../src/caveatBuilder/allowedTargetsBuilder.ts","../src/caveatBuilder/argsEqualityCheckBuilder.ts","../src/caveatBuilder/blockNumberBuilder.ts","../src/caveatBuilder/deployedBuilder.ts","../src/caveatBuilder/erc1155BalanceChangeBuilder.ts","../src/caveatBuilder/erc20BalanceChangeBuilder.ts","../src/caveatBuilder/erc20PeriodTransferBuilder.ts","../src/caveatBuilder/erc20StreamingBuilder.ts","../src/caveatBuilder/erc20TransferAmountBuilder.ts","../src/caveatBuilder/erc721BalanceChangeBuilder.ts","../src/caveatBuilder/erc721TransferBuilder.ts","../src/caveatBuilder/exactCalldataBatchBuilder.ts","../src/caveatBuilder/exactCalldataBuilder.ts","../src/caveatBuilder/exactExecutionBatchBuilder.ts","../src/caveatBuilder/exactExecutionBuilder.ts","../src/caveatBuilder/idBuilder.ts","../src/caveatBuilder/limitedCallsBuilder.ts","../src/caveatBuilder/multiTokenPeriodBuilder.ts","../src/caveatBuilder/nativeBalanceChangeBuilder.ts","../src/caveatBuilder/nativeTokenPaymentBuilder.ts","../src/caveatBuilder/nativeTokenPeriodTransferBuilder.ts","../src/caveatBuilder/nativeTokenStreamingBuilder.ts","../src/caveatBuilder/nativeTokenTransferAmountBuilder.ts","../src/caveatBuilder/nonceBuilder.ts","../src/caveatBuilder/ownershipTransferBuilder.ts","../src/caveatBuilder/redeemerBuilder.ts","../src/caveatBuilder/specificActionERC20TransferBatchBuilder.ts","../src/caveatBuilder/timestampBuilder.ts","../src/caveatBuilder/valueLteBuilder.ts","../src/caveatBuilder/coreCaveatBuilder.ts","../src/caveatBuilder/scope/erc20PeriodicScope.ts","../src/caveatBuilder/scope/erc20StreamingScope.ts","../src/caveatBuilder/scope/erc20TransferScope.ts","../src/utils.ts","../src/caveatBuilder/scope/erc721Scope.ts","../src/caveatBuilder/scope/functionCallScope.ts","../src/caveatBuilder/scope/nativeTokenPeriodicScope.ts","../src/caveatBuilder/scope/nativeTokenStreamingScope.ts","../src/caveatBuilder/scope/nativeTokenTransferScope.ts","../src/caveatBuilder/scope/ownershipScope.ts","../src/caveatBuilder/scope/index.ts","../src/caveatBuilder/resolveCaveats.ts","../src/caveats.ts","../src/delegation.ts"],"sourcesContent":["import type { Caveat, DeleGatorEnvironment } from '../types';\n\ntype CaveatWithOptionalArgs = Omit<Caveat, 'args'> & {\n  args?: Caveat['args'];\n};\n\nconst INSECURE_UNRESTRICTED_DELEGATION_ERROR_MESSAGE =\n  'No caveats found. If you definitely want to create an empty caveat collection, set `allowInsecureUnrestrictedDelegation` to `true`.';\n\ntype CaveatBuilderMap = {\n  [key: string]: (\n    environment: DeleGatorEnvironment,\n    ...args: [...any]\n  ) => Caveat;\n};\n\nexport type CaveatBuilderConfig = {\n  allowInsecureUnrestrictedDelegation?: boolean;\n};\n\n/**\n * A builder class for creating and managing caveats.\n * @template TCaveatBuilderMap - The type map of available caveat builder functions.\n */\nexport class CaveatBuilder<\n  TCaveatBuilderMap extends CaveatBuilderMap = Record<string, never>,\n> {\n  #results: Caveat[] = [];\n\n  #hasBeenBuilt = false;\n\n  #environment: DeleGatorEnvironment;\n\n  #config: CaveatBuilderConfig;\n\n  #enforcerBuilders: TCaveatBuilderMap;\n\n  constructor(\n    environment: DeleGatorEnvironment,\n    config: CaveatBuilderConfig = {},\n    enforcerBuilders: TCaveatBuilderMap = {} as TCaveatBuilderMap,\n    builtCaveats: Caveat[] = [],\n  ) {\n    this.#environment = environment;\n    this.#config = config;\n    this.#enforcerBuilders = enforcerBuilders;\n    this.#results = builtCaveats;\n  }\n\n  /**\n   * Extends the CaveatBuilder with a new enforcer function.\n   * @template TEnforcerName - The name of the enforcer.\n   * @template TFunction - The type of the enforcer function.\n   * @param name - The name of the enforcer.\n   * @param fn - The enforcer function.\n   * @returns The extended CaveatBuilder instance.\n   */\n  extend<\n    TEnforcerName extends string,\n    TFunction extends (\n      environment: DeleGatorEnvironment,\n      config: any,\n    ) => Caveat,\n  >(\n    name: TEnforcerName,\n    fn: TFunction,\n  ): CaveatBuilder<TCaveatBuilderMap & Record<TEnforcerName, TFunction>> {\n    return new CaveatBuilder<\n      TCaveatBuilderMap & Record<TEnforcerName, TFunction>\n    >(\n      this.#environment,\n      this.#config,\n      { ...this.#enforcerBuilders, [name]: fn },\n      this.#results,\n    );\n  }\n\n  /**\n   * Adds a caveat directly using a Caveat object.\n   * @param caveat - The caveat to add.\n   * @returns The CaveatBuilder instance for chaining.\n   */\n  addCaveat(caveat: CaveatWithOptionalArgs): CaveatBuilder<TCaveatBuilderMap>;\n\n  /**\n   * Adds a caveat using a named enforcer function.\n   * @param name - The name of the enforcer function to use.\n   * @param config - The configuration to pass to the enforcer function.\n   * @returns The CaveatBuilder instance for chaining.\n   */\n  addCaveat<TEnforcerName extends keyof TCaveatBuilderMap>(\n    name: TEnforcerName,\n    config: Parameters<TCaveatBuilderMap[TEnforcerName]>[1],\n  ): CaveatBuilder<TCaveatBuilderMap>;\n\n  addCaveat<TEnforcerName extends keyof TCaveatBuilderMap>(\n    nameOrCaveat: TEnforcerName | CaveatWithOptionalArgs,\n    config?: Parameters<TCaveatBuilderMap[TEnforcerName]>[1],\n  ): CaveatBuilder<TCaveatBuilderMap> {\n    if (typeof nameOrCaveat === 'object') {\n      const caveat = {\n        args: '0x' as const,\n        ...nameOrCaveat,\n      };\n\n      this.#results = [...this.#results, caveat];\n\n      return this;\n    }\n    const name = nameOrCaveat;\n\n    const func = this.#enforcerBuilders[name];\n    if (typeof func === 'function') {\n      const result = func(this.#environment, config);\n\n      this.#results = [...this.#results, result];\n\n      return this;\n    }\n    throw new Error(`Function \"${String(name)}\" does not exist.`);\n  }\n\n  /**\n   * Returns the caveats that have been built using this CaveatBuilder.\n   * @returns The array of built caveats.\n   * @throws Error if the builder has already been built or if no caveats are found and empty caveats are not allowed.\n   */\n  build(): Caveat[] {\n    if (this.#hasBeenBuilt) {\n      throw new Error('This CaveatBuilder has already been built.');\n    }\n\n    if (\n      this.#results.length === 0 &&\n      !this.#config.allowInsecureUnrestrictedDelegation\n    ) {\n      throw new Error(INSECURE_UNRESTRICTED_DELEGATION_ERROR_MESSAGE);\n    }\n\n    this.#hasBeenBuilt = true;\n\n    return this.#results;\n  }\n}\n","import type { DeleGatorEnvironment } from 'src/types';\n\nexport enum BalanceChangeType {\n  Increase = 0x0,\n  Decrease = 0x1,\n}\n\nexport type UnitOfAuthorityBaseConfig = { environment: DeleGatorEnvironment };\n","import { type Hex, concat, isHex, toHex } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const allowedCalldata = 'allowedCalldata';\n\nexport type AllowedCalldataBuilderConfig = {\n  /**\n   * The index in the calldata byte array (including the 4-byte method selector)\n   * where the expected calldata starts.\n   */\n  startIndex: number;\n  /**\n   * The expected calldata as a hex string that must match at the specified index.\n   */\n  value: Hex;\n};\n\n/**\n * Builds a caveat struct for AllowedCalldataEnforcer that restricts calldata to a specific value at a given index.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing startIndex and value.\n * @returns The Caveat.\n * @throws Error if the value is not a valid hex string, if startIndex is negative, or if startIndex is not a whole number.\n */\nexport const allowedCalldataBuilder = (\n  environment: DeleGatorEnvironment,\n  config: AllowedCalldataBuilderConfig,\n): Caveat => {\n  const { startIndex, value } = config;\n\n  if (!isHex(value)) {\n    throw new Error('Invalid value: must be a valid hex string');\n  }\n\n  if (startIndex < 0) {\n    throw new Error('Invalid startIndex: must be zero or positive');\n  }\n\n  if (!Number.isInteger(startIndex)) {\n    throw new Error('Invalid startIndex: must be a whole number');\n  }\n\n  const startIndexHex = toHex(startIndex, { size: 32 });\n\n  const terms = concat([startIndexHex, value]);\n\n  const {\n    caveatEnforcers: { AllowedCalldataEnforcer },\n  } = environment;\n\n  if (!AllowedCalldataEnforcer) {\n    throw new Error('AllowedCalldataEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: AllowedCalldataEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { isHex, concat, toFunctionSelector } from 'viem';\nimport type { AbiFunction, Hex } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const allowedMethods = 'allowedMethods';\n\nexport type MethodSelector = Hex | string | AbiFunction;\n\n// length of function selector in chars, _including_ 0x prefix\nconst FUNCTION_SELECTOR_STRING_LENGTH = 10;\n\nexport type AllowedMethodsBuilderConfig = {\n  /**\n   * An array of method selectors that the delegate is allowed to call.\n   * Can be 4-byte hex strings, ABI function signatures, or ABIFunction objects.\n   */\n  selectors: MethodSelector[];\n};\n\n/**\n * Builds a caveat struct for the AllowedMethodsEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the allowed function selectors.\n * @returns The Caveat.\n * @throws Error if no selectors are provided or if any selector is invalid.\n */\nexport const allowedMethodsBuilder = (\n  environment: DeleGatorEnvironment,\n  config: AllowedMethodsBuilderConfig,\n): Caveat => {\n  const { selectors } = config;\n\n  if (selectors.length === 0) {\n    throw new Error('Invalid selectors: must provide at least one selector');\n  }\n\n  const parsedSelectors = selectors.map(parseSelector);\n\n  const terms = concat(parsedSelectors);\n\n  const {\n    caveatEnforcers: { AllowedMethodsEnforcer },\n  } = environment;\n\n  if (!AllowedMethodsEnforcer) {\n    throw new Error('AllowedMethodsEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: AllowedMethodsEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n\n/**\n * Parses a method selector into a hex string.\n * @param selector - The method selector to parse.\n * @returns The parsed selector as a hex string.\n */\nfunction parseSelector(selector: MethodSelector) {\n  if (isHex(selector)) {\n    if (selector.length === FUNCTION_SELECTOR_STRING_LENGTH) {\n      return selector;\n    }\n    throw new Error(\n      'Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction',\n    );\n  }\n\n  try {\n    return toFunctionSelector(selector);\n  } catch (rootError: any) {\n    throw new Error(\n      'Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction',\n      { cause: rootError },\n    );\n  }\n}\n","import { concat, isAddress, type Address } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const allowedTargets = 'allowedTargets';\n\nexport type AllowedTargetsBuilderConfig = {\n  /**\n   * An array of addresses that the delegate is allowed to call.\n   * Each address must be a valid hex string.\n   */\n  targets: Address[];\n};\n\n/**\n * Builds a caveat struct for AllowedTargetsEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the targets.\n * @returns The Caveat.\n * @throws Error if no targets are provided or if any of the addresses are invalid.\n */\nexport const allowedTargetsBuilder = (\n  environment: DeleGatorEnvironment,\n  config: AllowedTargetsBuilderConfig,\n): Caveat => {\n  const { targets } = config;\n\n  if (targets.length === 0) {\n    throw new Error(\n      'Invalid targets: must provide at least one target address',\n    );\n  }\n\n  // we check that the address is valid, but doesn't need to be checksummed\n  const invalidAddresses = targets.filter(\n    (target) => !isAddress(target, { strict: false }),\n  );\n\n  if (invalidAddresses.length > 0) {\n    throw new Error('Invalid targets: must be valid addresses');\n  }\n\n  const terms = concat(targets);\n\n  const {\n    caveatEnforcers: { AllowedTargetsEnforcer },\n  } = environment;\n\n  if (!AllowedTargetsEnforcer) {\n    throw new Error('AllowedTargetsEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: AllowedTargetsEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Hex, isHex } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const argsEqualityCheck = 'argsEqualityCheck';\n\nexport type ArgsEqualityCheckBuilderConfig = {\n  /**\n   * The expected args as a hex string that must match exactly when redeeming the delegation.\n   */\n  args: Hex;\n};\n\n/**\n * Builds a caveat struct for the ArgsEqualityCheckEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the builder.\n * @returns The Caveat.\n * @throws Error if the config is invalid.\n */\nexport const argsEqualityCheckBuilder = (\n  environment: DeleGatorEnvironment,\n  config: ArgsEqualityCheckBuilderConfig,\n): Caveat => {\n  const { args } = config;\n  if (!isHex(args)) {\n    throw new Error('Invalid config: args must be a valid hex string');\n  }\n\n  const {\n    caveatEnforcers: { ArgsEqualityCheckEnforcer },\n  } = environment;\n\n  if (!ArgsEqualityCheckEnforcer) {\n    throw new Error('ArgsEqualityCheckEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ArgsEqualityCheckEnforcer,\n    terms: args,\n    args: '0x',\n  };\n};\n","import { concat, toHex } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const blockNumber = 'blockNumber';\n\nexport type BlockNumberBuilderConfig = {\n  /**\n   * The block number after which the delegation is valid.\n   * Set to 0n to disable this threshold.\n   */\n  afterThreshold: bigint;\n  /**\n   * The block number before which the delegation is valid.\n   * Set to 0n to disable this threshold.\n   */\n  beforeThreshold: bigint;\n};\n\n/**\n * Builds a caveat struct for the BlockNumberEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the BlockNumberEnforcer.\n * @returns The Caveat.\n * @throws Error if both thresholds are zero, if blockAfterThreshold is greater than or equal to blockBeforeThreshold, or if BlockNumberEnforcer is not available in the environment.\n */\nexport const blockNumberBuilder = (\n  environment: DeleGatorEnvironment,\n  config: BlockNumberBuilderConfig,\n): Caveat => {\n  const { afterThreshold, beforeThreshold } = config;\n\n  if (afterThreshold === 0n && beforeThreshold === 0n) {\n    throw new Error(\n      'Invalid thresholds: At least one of afterThreshold or beforeThreshold must be specified',\n    );\n  }\n\n  if (beforeThreshold !== 0n && afterThreshold >= beforeThreshold) {\n    throw new Error(\n      'Invalid thresholds: afterThreshold must be less than beforeThreshold if both are specified',\n    );\n  }\n\n  const terms = concat([\n    toHex(afterThreshold, {\n      size: 16,\n    }),\n    toHex(beforeThreshold, {\n      size: 16,\n    }),\n  ]);\n\n  const {\n    caveatEnforcers: { BlockNumberEnforcer },\n  } = environment;\n\n  if (!BlockNumberEnforcer) {\n    throw new Error('BlockNumberEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: BlockNumberEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { concat, isAddress, isHex, pad, type Address, type Hex } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const deployed = 'deployed';\n\nexport type DeployedBuilderConfig = {\n  /**\n   * The contract address as a hex string.\n   */\n  contractAddress: Address;\n  /**\n   * The salt to use with the deployment, as a hex string.\n   */\n  salt: Hex;\n  /**\n   * The bytecode of the contract as a hex string.\n   */\n  bytecode: Hex;\n};\n\n/**\n * Builds a caveat struct for a DeployedEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration for the deployed builder.\n * @returns The Caveat.\n * @throws Error if the contract address, factory address, or bytecode is invalid.\n */\nexport const deployedBuilder = (\n  environment: DeleGatorEnvironment,\n  config: DeployedBuilderConfig,\n): Caveat => {\n  const { contractAddress, salt, bytecode } = config;\n\n  // we check that the addresses are valid, but don't need to be checksummed\n  if (!isAddress(contractAddress, { strict: false })) {\n    throw new Error(\n      `Invalid contractAddress: must be a valid Ethereum address`,\n    );\n  }\n\n  if (!isHex(salt)) {\n    throw new Error('Invalid salt: must be a valid hexadecimal string');\n  }\n\n  if (!isHex(bytecode)) {\n    throw new Error('Invalid bytecode: must be a valid hexadecimal string');\n  }\n\n  const terms = concat([contractAddress, pad(salt, { size: 32 }), bytecode]);\n\n  const {\n    caveatEnforcers: { DeployedEnforcer },\n  } = environment;\n\n  if (!DeployedEnforcer) {\n    throw new Error('DeployedEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: DeployedEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, isAddress, encodePacked } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\nimport { BalanceChangeType } from './types';\n\nexport const erc1155BalanceChange = 'erc1155BalanceChange';\n\nexport type Erc1155BalanceChangeBuilderConfig = {\n  /**\n   * The ERC-1155 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The recipient's address as a hex string.\n   */\n  recipient: Address;\n  /**\n   * The ID of the ERC-1155 token as a bigint.\n   */\n  tokenId: bigint;\n  /**\n   * The amount by which the balance must have changed as a bigint.\n   */\n  balance: bigint;\n  /**\n   * The balance change type for the ERC-1155 token.\n   * Specifies whether the balance should have increased or decreased.\n   * Valid parameters are BalanceChangeType.Increase and BalanceChangeType.Decrease.\n   */\n  changeType: BalanceChangeType;\n};\n\n/**\n * Builds a caveat struct for the ERC1155BalanceChangeEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the ERC1155 balance change.\n * @returns The Caveat.\n * @throws Error if the token address is invalid, the recipient address is invalid, or the amount is not a positive number.\n */\nexport const erc1155BalanceChangeBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc1155BalanceChangeBuilderConfig,\n): Caveat => {\n  const { tokenAddress, recipient, tokenId, balance, changeType } = config;\n\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (!isAddress(recipient, { strict: false })) {\n    throw new Error('Invalid recipient: must be a valid address');\n  }\n\n  if (balance <= 0n) {\n    throw new Error('Invalid balance: must be a positive number');\n  }\n\n  if (tokenId < 0n) {\n    throw new Error('Invalid tokenId: must be a non-negative number');\n  }\n\n  if (\n    changeType !== BalanceChangeType.Increase &&\n    changeType !== BalanceChangeType.Decrease\n  ) {\n    throw new Error('Invalid changeType: must be either Increase or Decrease');\n  }\n\n  const terms = encodePacked(\n    ['uint8', 'address', 'address', 'uint256', 'uint256'],\n    [changeType, tokenAddress, recipient, tokenId, balance],\n  );\n\n  const {\n    caveatEnforcers: { ERC1155BalanceChangeEnforcer },\n  } = environment;\n\n  if (!ERC1155BalanceChangeEnforcer) {\n    throw new Error('ERC1155BalanceChangeEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC1155BalanceChangeEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, isAddress, encodePacked } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\nimport { BalanceChangeType } from './types';\n\nexport const erc20BalanceChange = 'erc20BalanceChange';\n\nexport type Erc20BalanceChangeBuilderConfig = {\n  /**\n   * The ERC-20 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The recipient's address as a hex string.\n   */\n  recipient: Address;\n  /**\n   * The amount by which the balance must have changed as a bigint.\n   */\n  balance: bigint;\n  /**\n   * The balance change type for the ERC-20 token.\n   * Specifies whether the balance should have increased or decreased.\n   * Valid parameters are BalanceChangeType.Increase and BalanceChangeType.Decrease.\n   */\n  changeType: BalanceChangeType;\n};\n\n/**\n * Builds a caveat struct for the ERC20BalanceChangeEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the ERC20 balance change.\n * @returns The Caveat.\n * @throws Error if the token address is invalid, the amount is not a positive number, or the change type is invalid.\n */\nexport const erc20BalanceChangeBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc20BalanceChangeBuilderConfig,\n): Caveat => {\n  const { tokenAddress, recipient, balance, changeType } = config;\n\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (balance <= 0n) {\n    throw new Error('Invalid balance: must be a positive number');\n  }\n\n  if (\n    changeType !== BalanceChangeType.Increase &&\n    changeType !== BalanceChangeType.Decrease\n  ) {\n    throw new Error('Invalid changeType: must be either Increase or Decrease');\n  }\n\n  const terms = encodePacked(\n    ['uint8', 'address', 'address', 'uint256'],\n    [changeType, tokenAddress, recipient, balance],\n  );\n\n  const {\n    caveatEnforcers: { ERC20BalanceChangeEnforcer },\n  } = environment;\n\n  if (!ERC20BalanceChangeEnforcer) {\n    throw new Error('ERC20BalanceChangeEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC20BalanceChangeEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createERC20TokenPeriodTransferTerms } from '@metamask/delegation-core';\nimport type { Address } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const erc20PeriodTransfer = 'erc20PeriodTransfer';\n\nexport type Erc20PeriodTransferBuilderConfig = {\n  /**\n   * The ERC-20 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The maximum amount of tokens that can be transferred per period.\n   */\n  periodAmount: bigint;\n  /**\n   * The duration of each period in seconds.\n   */\n  periodDuration: number;\n  /**\n   * The timestamp when the first period begins in seconds.\n   */\n  startDate: number;\n};\n\n/**\n * Builds a caveat struct for ERC20PeriodTransferEnforcer.\n * This enforcer validates that ERC20 token transfers do not exceed a specified amount\n * within a given time period. The transferable amount resets at the beginning of each period,\n * and any unused tokens are forfeited once the period ends.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration for the ERC20 period transfer builder.\n * @returns The Caveat.\n * @throws Error if the token address is invalid or if any of the numeric parameters are invalid.\n */\nexport const erc20PeriodTransferBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc20PeriodTransferBuilderConfig,\n): Caveat => {\n  const { tokenAddress, periodAmount, periodDuration, startDate } = config;\n\n  const terms = createERC20TokenPeriodTransferTerms({\n    tokenAddress,\n    periodAmount,\n    periodDuration,\n    startDate,\n  });\n\n  const {\n    caveatEnforcers: { ERC20PeriodTransferEnforcer },\n  } = environment;\n\n  if (!ERC20PeriodTransferEnforcer) {\n    throw new Error('ERC20PeriodTransferEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC20PeriodTransferEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createERC20StreamingTerms } from '@metamask/delegation-core';\nimport { type Address } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const erc20Streaming = 'erc20Streaming';\n\nexport type Erc20StreamingBuilderConfig = {\n  /**\n   * The ERC-20 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The initial amount available at start time as a bigint.\n   */\n  initialAmount: bigint;\n  /**\n   * Maximum total amount that can be unlocked as a bigint.\n   */\n  maxAmount: bigint;\n  /**\n   * Rate at which tokens accrue per second as a bigint.\n   */\n  amountPerSecond: bigint;\n  /**\n   * The start timestamp in seconds.\n   */\n  startTime: number;\n};\n\n/**\n * Builds a caveat for ERC20 token streaming with configurable parameters.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration for the ERC20 streaming builder.\n * @returns The Caveat.\n * @throws Error if the token address is invalid.\n * @throws Error if the initial amount is a negative number.\n * @throws Error if the max amount is not greater than 0.\n * @throws Error if the max amount is less than the initial amount.\n * @throws Error if the amount per second is not a positive number.\n * @throws Error if the start time is not a positive number.\n */\nexport const erc20StreamingBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc20StreamingBuilderConfig,\n): Caveat => {\n  const { tokenAddress, initialAmount, maxAmount, amountPerSecond, startTime } =\n    config;\n\n  const terms = createERC20StreamingTerms({\n    tokenAddress,\n    initialAmount,\n    maxAmount,\n    amountPerSecond,\n    startTime,\n  });\n\n  const {\n    caveatEnforcers: { ERC20StreamingEnforcer },\n  } = environment;\n\n  if (!ERC20StreamingEnforcer) {\n    throw new Error('ERC20StreamingEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC20StreamingEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Address } from 'viem';\nimport { concat, isAddress, toHex } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const erc20TransferAmount = 'erc20TransferAmount';\n\nexport type Erc20TransferAmountBuilderConfig = {\n  /**\n   * The ERC-20 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The maximum amount of tokens that can be transferred as a bigint.\n   */\n  maxAmount: bigint;\n};\n\n/**\n * Builds a caveat struct for ERC20TransferAmountEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration for the ERC20 transfer amount builder.\n * @returns The Caveat.\n * @throws Error if the token address is invalid or if the max amount is not a positive number.\n */\nexport const erc20TransferAmountBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc20TransferAmountBuilderConfig,\n): Caveat => {\n  const { tokenAddress, maxAmount } = config;\n\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (maxAmount <= 0n) {\n    throw new Error('Invalid maxAmount: must be a positive number');\n  }\n\n  const terms = concat([tokenAddress, toHex(maxAmount, { size: 32 })]);\n\n  const {\n    caveatEnforcers: { ERC20TransferAmountEnforcer },\n  } = environment;\n\n  if (!ERC20TransferAmountEnforcer) {\n    throw new Error('ERC20TransferAmountEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC20TransferAmountEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, isAddress, encodePacked } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\nimport { BalanceChangeType } from './types';\n\nexport const erc721BalanceChange = 'erc721BalanceChange';\n\nexport type Erc721BalanceChangeBuilderConfig = {\n  /**\n   * The ERC-721 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The recipient's address as a hex string.\n   */\n  recipient: Address;\n  /**\n   * The amount by which the balance must have changed as a bigint.\n   */\n  amount: bigint;\n  /**\n   * The balance change type for the ERC-721 token.\n   * Specifies whether the balance should have increased or decreased.\n   * Valid parameters are BalanceChangeType.Increase and BalanceChangeType.Decrease.\n   */\n  changeType: BalanceChangeType;\n};\n\n/**\n * Builds a caveat struct for the ERC721BalanceChangeEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the ERC721 balance change.\n * @returns The Caveat.\n * @throws Error if the token address is invalid, the recipient address is invalid, or the amount is not a positive number.\n */\nexport const erc721BalanceChangeBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc721BalanceChangeBuilderConfig,\n): Caveat => {\n  const { tokenAddress, recipient, amount, changeType } = config;\n\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (!isAddress(recipient, { strict: false })) {\n    throw new Error('Invalid recipient: must be a valid address');\n  }\n\n  if (amount <= 0n) {\n    throw new Error('Invalid balance: must be a positive number');\n  }\n\n  if (\n    changeType !== BalanceChangeType.Increase &&\n    changeType !== BalanceChangeType.Decrease\n  ) {\n    throw new Error('Invalid changeType: must be either Increase or Decrease');\n  }\n\n  const terms = encodePacked(\n    ['uint8', 'address', 'address', 'uint256'],\n    [changeType, tokenAddress, recipient, amount],\n  );\n\n  const {\n    caveatEnforcers: { ERC721BalanceChangeEnforcer },\n  } = environment;\n\n  if (!ERC721BalanceChangeEnforcer) {\n    throw new Error('ERC721BalanceChangeEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC721BalanceChangeEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, isAddress, toHex, concat } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const erc721Transfer = 'erc721Transfer';\n\nexport type Erc721TransferBuilderConfig = {\n  /**\n   * The ERC-721 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The token ID as a bigint.\n   */\n  tokenId: bigint;\n};\n\n/**\n * Builds a caveat struct for the ERC721TransferEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the ERC721 transfer builder.\n * @returns The Caveat representing the caveat for ERC721 transfer.\n * @throws Error if the permitted contract address is invalid.\n */\nexport const erc721TransferBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc721TransferBuilderConfig,\n): Caveat => {\n  const { tokenAddress, tokenId } = config;\n\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (tokenId < 0n) {\n    throw new Error('Invalid tokenId: must be a non-negative number');\n  }\n\n  const terms = concat([tokenAddress, toHex(tokenId, { size: 32 })]);\n\n  const {\n    caveatEnforcers: { ERC721TransferEnforcer },\n  } = environment;\n\n  if (!ERC721TransferEnforcer) {\n    throw new Error('ERC721TransferEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC721TransferEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { encodeAbiParameters, isAddress } from 'viem';\n\nimport type { ExecutionStruct } from '../executions';\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const exactCalldataBatch = 'exactCalldataBatch';\n\nexport type ExactCalldataBatchBuilderConfig = {\n  /**\n   * An array of executions that must be matched exactly in the batch.\n   * Each execution specifies a target address, value, and calldata.\n   */\n  executions: ExecutionStruct[];\n};\n\n/**\n * Builds a caveat struct for ExactCalldataBatchEnforcer.\n * This enforcer ensures that the provided batch execution calldata matches exactly\n * the expected calldata for each execution.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing executions.\n * @returns The Caveat.\n * @throws Error if any of the executions have invalid parameters.\n */\nexport const exactCalldataBatchBuilder = (\n  environment: DeleGatorEnvironment,\n  config: ExactCalldataBatchBuilderConfig,\n): Caveat => {\n  const { executions } = config;\n\n  if (executions.length === 0) {\n    throw new Error('Invalid executions: array cannot be empty');\n  }\n\n  // Validate each execution\n  for (const execution of executions) {\n    if (!isAddress(execution.target, { strict: false })) {\n      throw new Error('Invalid target: must be a valid address');\n    }\n\n    if (execution.value < 0n) {\n      throw new Error('Invalid value: must be a non-negative number');\n    }\n\n    if (!execution.callData.startsWith('0x')) {\n      throw new Error(\n        'Invalid calldata: must be a hex string starting with 0x',\n      );\n    }\n  }\n\n  // Encode the executions using the approach implemented in ExecutionLib.sol encodeBatch()\n  const terms = encodeAbiParameters(\n    [\n      {\n        type: 'tuple[]',\n        components: [\n          { type: 'address', name: 'target' },\n          { type: 'uint256', name: 'value' },\n          { type: 'bytes', name: 'callData' },\n        ],\n      },\n    ],\n    [executions],\n  );\n\n  const {\n    caveatEnforcers: { ExactCalldataBatchEnforcer },\n  } = environment;\n\n  if (!ExactCalldataBatchEnforcer) {\n    throw new Error('ExactCalldataBatchEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ExactCalldataBatchEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createExactCalldataTerms } from '@metamask/delegation-core';\nimport type { Hex } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const exactCalldata = 'exactCalldata';\n\nexport type ExactCalldataBuilderConfig = {\n  /**\n   * The exact calldata that must be matched as a hex string.\n   */\n  calldata: Hex;\n};\n\n/**\n * Builds a caveat struct for ExactCalldataEnforcer.\n * This enforcer ensures that the provided execution calldata matches exactly\n * the expected calldata.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration for the ExactCalldataBuilder.\n * @returns The Caveat.\n * @throws Error if any of the parameters are invalid.\n */\nexport const exactCalldataBuilder = (\n  environment: DeleGatorEnvironment,\n  config: ExactCalldataBuilderConfig,\n): Caveat => {\n  const { calldata } = config;\n\n  const terms = createExactCalldataTerms({ calldata });\n\n  const {\n    caveatEnforcers: { ExactCalldataEnforcer },\n  } = environment;\n\n  if (!ExactCalldataEnforcer) {\n    throw new Error('ExactCalldataEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ExactCalldataEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { encodeAbiParameters, isAddress } from 'viem';\n\nimport type { ExecutionStruct } from '../executions';\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const exactExecutionBatch = 'exactExecutionBatch';\n\nexport type ExactExecutionBatchBuilderConfig = {\n  /**\n   * An array of executions that must be matched exactly in the batch.\n   * Each execution specifies a target address, value, and calldata.\n   */\n  executions: ExecutionStruct[];\n};\n\n/**\n * Builds a caveat struct for ExactExecutionBatchEnforcer.\n * This enforcer ensures that each execution in the batch matches exactly\n * with the expected execution (target, value, and calldata).\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing executions.\n * @returns The Caveat.\n * @throws Error if any of the execution parameters are invalid.\n */\nexport const exactExecutionBatchBuilder = (\n  environment: DeleGatorEnvironment,\n  config: ExactExecutionBatchBuilderConfig,\n): Caveat => {\n  const { executions } = config;\n\n  if (executions.length === 0) {\n    throw new Error('Invalid executions: array cannot be empty');\n  }\n\n  // Validate each execution\n  for (const execution of executions) {\n    if (!isAddress(execution.target, { strict: false })) {\n      throw new Error('Invalid target: must be a valid address');\n    }\n\n    if (execution.value < 0n) {\n      throw new Error('Invalid value: must be a non-negative number');\n    }\n\n    if (!execution.callData.startsWith('0x')) {\n      throw new Error(\n        'Invalid calldata: must be a hex string starting with 0x',\n      );\n    }\n  }\n\n  // Encode the executions using the approach implemented in ExecutionLib.sol encodeBatch()\n  const terms = encodeAbiParameters(\n    [\n      {\n        type: 'tuple[]',\n        components: [\n          { type: 'address', name: 'target' },\n          { type: 'uint256', name: 'value' },\n          { type: 'bytes', name: 'callData' },\n        ],\n      },\n    ],\n    [executions],\n  );\n\n  const {\n    caveatEnforcers: { ExactExecutionBatchEnforcer },\n  } = environment;\n\n  if (!ExactExecutionBatchEnforcer) {\n    throw new Error('ExactExecutionBatchEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ExactExecutionBatchEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { isAddress, concat, toHex } from 'viem';\n\nimport type { ExecutionStruct } from '../executions';\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const exactExecution = 'exactExecution';\n\nexport type ExactExecutionBuilderConfig = {\n  /**\n   * The execution that must be matched exactly.\n   * Specifies the target address, value, and calldata.\n   */\n  execution: ExecutionStruct;\n};\n\n/**\n * Builds a caveat struct for ExactExecutionEnforcer.\n * This enforcer ensures that the provided execution matches exactly\n * with the expected execution (target, value, and calldata).\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the execution.\n * @returns The Caveat.\n * @throws Error if any of the execution parameters are invalid.\n */\nexport const exactExecutionBuilder = (\n  environment: DeleGatorEnvironment,\n  config: ExactExecutionBuilderConfig,\n): Caveat => {\n  const { execution } = config;\n\n  if (!isAddress(execution.target, { strict: false })) {\n    throw new Error('Invalid target: must be a valid address');\n  }\n\n  if (execution.value < 0n) {\n    throw new Error('Invalid value: must be a non-negative number');\n  }\n\n  if (!execution.callData.startsWith('0x')) {\n    throw new Error('Invalid calldata: must be a hex string starting with 0x');\n  }\n\n  const terms = concat([\n    execution.target,\n    toHex(execution.value, { size: 32 }),\n    execution.callData,\n  ]);\n\n  const {\n    caveatEnforcers: { ExactExecutionEnforcer },\n  } = environment;\n\n  if (!ExactExecutionEnforcer) {\n    throw new Error('ExactExecutionEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ExactExecutionEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { maxUint256, toHex } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport type IdBuilderConfig = {\n  /**\n   * An id for the delegation. Only one delegation may be redeemed with any given id.\n   */\n  id: bigint | number;\n};\n\nexport const id = 'id';\n\n/**\n * Builds a caveat struct for the IdEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the id to use in the caveat.\n * @returns The Caveat.\n * @throws Error if the provided id is not a number, not an integer, or is not 32 bytes or fewer in length.\n */\nexport const idBuilder = (\n  environment: DeleGatorEnvironment,\n  config: IdBuilderConfig,\n): Caveat => {\n  const { id: idValue } = config;\n\n  let idBigInt: bigint;\n\n  if (typeof idValue === 'number') {\n    if (!Number.isInteger(idValue)) {\n      throw new Error('Invalid id: must be an integer');\n    }\n\n    idBigInt = BigInt(idValue);\n  } else if (typeof idValue === 'bigint') {\n    idBigInt = idValue;\n  } else {\n    throw new Error('Invalid id: must be a bigint or number');\n  }\n\n  if (idBigInt < 0n) {\n    throw new Error('Invalid id: must be a non-negative number');\n  }\n\n  if (idBigInt > maxUint256) {\n    throw new Error('Invalid id: must be less than 2^256');\n  }\n\n  const terms = toHex(idBigInt, { size: 32 });\n\n  const {\n    caveatEnforcers: { IdEnforcer },\n  } = environment;\n\n  if (!IdEnforcer) {\n    throw new Error('IdEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: IdEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Hex, toHex, pad } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const limitedCalls = 'limitedCalls';\n\nexport type LimitedCallsBuilderConfig = {\n  /**\n   * The maximum number of times this delegation may be redeemed.\n   */\n  limit: number;\n};\n\n/**\n * Builds a caveat struct for the LimitedCallsEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the limit.\n * @returns The Caveat.\n * @throws Error if the limit is not a positive integer.\n */\nexport const limitedCallsBuilder = (\n  environment: DeleGatorEnvironment,\n  config: LimitedCallsBuilderConfig,\n): Caveat => {\n  const { limit } = config;\n\n  if (!Number.isInteger(limit)) {\n    throw new Error('Invalid limit: must be an integer');\n  }\n\n  if (limit <= 0) {\n    throw new Error('Invalid limit: must be a positive integer');\n  }\n\n  const terms: Hex = pad(toHex(limit), { size: 32 });\n\n  const {\n    caveatEnforcers: { LimitedCallsEnforcer },\n  } = environment;\n\n  if (!LimitedCallsEnforcer) {\n    throw new Error('LimitedCallsEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: LimitedCallsEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Hex } from 'viem';\nimport { concat, isAddress, pad, toHex } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport type TokenPeriodConfig = {\n  /**\n   * The token contract address as a hex string.\n   */\n  token: Hex;\n  /**\n   * The maximum amount of tokens that can be transferred per period.\n   */\n  periodAmount: bigint;\n  /**\n   * The duration of each period in seconds.\n   */\n  periodDuration: number;\n  /**\n   * The timestamp when the first period begins in seconds.\n   */\n  startDate: number;\n};\n\nexport type MultiTokenPeriodBuilderConfig = TokenPeriodConfig[];\n\nexport const multiTokenPeriod = 'multiTokenPeriod';\n\n/**\n * Creates a caveat for the MultiTokenPeriodEnforcer.\n * This enforcer allows setting periodic transfer limits for multiple tokens.\n * Each token can have its own period amount, duration, and start date.\n *\n * @param environment - The DeleGator environment.\n * @param configs - The configurations for the MultiTokenPeriodBuilder.\n * @returns The caveat object for the MultiTokenPeriodEnforcer.\n */\nexport const multiTokenPeriodBuilder = (\n  environment: DeleGatorEnvironment,\n  configs: MultiTokenPeriodBuilderConfig,\n): Caveat => {\n  if (!configs || configs.length === 0) {\n    throw new Error('MultiTokenPeriodBuilder: configs array cannot be empty');\n  }\n\n  configs.forEach((config) => {\n    if (!isAddress(config.token)) {\n      throw new Error(`Invalid token address: ${String(config.token)}`);\n    }\n\n    if (config.periodAmount <= 0) {\n      throw new Error('Invalid period amount: must be greater than 0');\n    }\n\n    if (config.periodDuration <= 0) {\n      throw new Error('Invalid period duration: must be greater than 0');\n    }\n  });\n\n  // Each config requires 116 bytes:\n  // - 20 bytes for token address\n  // - 32 bytes for periodAmount\n  // - 32 bytes for periodDuration\n  // - 32 bytes for startDate\n  const termsArray = configs.reduce<Hex[]>(\n    (acc, { token, periodAmount, periodDuration, startDate }) => [\n      ...acc,\n      pad(token, { size: 20 }),\n      toHex(periodAmount, { size: 32 }),\n      toHex(periodDuration, { size: 32 }),\n      toHex(startDate, { size: 32 }),\n    ],\n    [],\n  );\n\n  const terms = concat(termsArray);\n\n  const {\n    caveatEnforcers: { MultiTokenPeriodEnforcer },\n  } = environment;\n\n  if (!MultiTokenPeriodEnforcer) {\n    throw new Error('MultiTokenPeriodEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: MultiTokenPeriodEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, isAddress, encodePacked } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\nimport { BalanceChangeType } from './types';\n\nexport const nativeBalanceChange = 'nativeBalanceChange';\n\nexport type NativeBalanceChangeBuilderConfig = {\n  /**\n   * The recipient's address as a hex string.\n   */\n  recipient: Address;\n  /**\n   * The amount by which the balance must have changed as a bigint.\n   */\n  balance: bigint;\n  /**\n   * The balance change type for the native currency.\n   * Specifies whether the balance should have increased or decreased.\n   * Valid parameters are BalanceChangeType.Increase and BalanceChangeType.Decrease.\n   */\n  changeType: BalanceChangeType;\n};\n\n/**\n * Builds a caveat struct for the NativeBalanceChangeEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the NativeBalanceChangeEnforcer.\n * @returns The Caveat.\n * @throws Error if the recipient address is invalid or the amount is not a positive number.\n */\nexport const nativeBalanceChangeBuilder = (\n  environment: DeleGatorEnvironment,\n  config: NativeBalanceChangeBuilderConfig,\n): Caveat => {\n  const { recipient, balance, changeType } = config;\n\n  if (!isAddress(recipient)) {\n    throw new Error('Invalid recipient: must be a valid Address');\n  }\n\n  if (balance <= 0n) {\n    throw new Error('Invalid balance: must be a positive number');\n  }\n\n  if (\n    changeType !== BalanceChangeType.Increase &&\n    changeType !== BalanceChangeType.Decrease\n  ) {\n    throw new Error('Invalid changeType: must be either Increase or Decrease');\n  }\n\n  const terms = encodePacked(\n    ['uint8', 'address', 'uint256'],\n    [changeType, recipient, balance],\n  );\n\n  const {\n    caveatEnforcers: { NativeBalanceChangeEnforcer },\n  } = environment;\n\n  if (!NativeBalanceChangeEnforcer) {\n    throw new Error('NativeBalanceChangeEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: NativeBalanceChangeEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, encodePacked, isAddress } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const nativeTokenPayment = 'nativeTokenPayment';\n\nexport type NativeTokenPaymentBuilderConfig = {\n  /**\n   * The recipient's address as a hex string.\n   */\n  recipient: Address;\n  /**\n   * The amount that must be paid as a bigint.\n   */\n  amount: bigint;\n};\n\n/**\n * Builds a caveat struct for the NativeTokenPaymentEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the NativeTokenPaymentEnforcer.\n * @returns The Caveat.\n * @throws Error if the amount is invalid or the recipient address is invalid.\n */\nexport const nativeTokenPaymentBuilder = (\n  environment: DeleGatorEnvironment,\n  config: NativeTokenPaymentBuilderConfig,\n): Caveat => {\n  const { recipient, amount } = config;\n\n  if (amount <= 0n) {\n    throw new Error('Invalid amount: must be positive');\n  }\n\n  if (!isAddress(recipient)) {\n    throw new Error('Invalid recipient: must be a valid address');\n  }\n\n  const terms = encodePacked(['address', 'uint256'], [recipient, amount]);\n\n  const {\n    caveatEnforcers: { NativeTokenPaymentEnforcer },\n  } = environment;\n\n  if (!NativeTokenPaymentEnforcer) {\n    throw new Error('NativeTokenPaymentEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: NativeTokenPaymentEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createNativeTokenPeriodTransferTerms } from '@metamask/delegation-core';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const nativeTokenPeriodTransfer = 'nativeTokenPeriodTransfer';\n\nexport type NativeTokenPeriodTransferBuilderConfig = {\n  /**\n   * The maximum amount of tokens that can be transferred per period.\n   */\n  periodAmount: bigint;\n  /**\n   * The duration of each period in seconds.\n   */\n  periodDuration: number;\n  /**\n   * The timestamp when the first period begins in seconds.\n   */\n  startDate: number;\n};\n\n/**\n * Builds a caveat struct for NativeTokenPeriodTransferEnforcer.\n * This enforcer validates that native token (ETH) transfers do not exceed a specified amount\n * within a given time period. The transferable amount resets at the beginning of each period,\n * and any unused ETH is forfeited once the period ends.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing periodAmount, periodDuration, and startDate.\n * @returns The Caveat.\n * @throws Error if any of the parameters are invalid.\n */\nexport const nativeTokenPeriodTransferBuilder = (\n  environment: DeleGatorEnvironment,\n  config: NativeTokenPeriodTransferBuilderConfig,\n): Caveat => {\n  const { periodAmount, periodDuration, startDate } = config;\n\n  const terms = createNativeTokenPeriodTransferTerms({\n    periodAmount,\n    periodDuration,\n    startDate,\n  });\n\n  const {\n    caveatEnforcers: { NativeTokenPeriodTransferEnforcer },\n  } = environment;\n\n  if (!NativeTokenPeriodTransferEnforcer) {\n    throw new Error(\n      'NativeTokenPeriodTransferEnforcer not found in environment',\n    );\n  }\n\n  return {\n    enforcer: NativeTokenPeriodTransferEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createNativeTokenStreamingTerms } from '@metamask/delegation-core';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const nativeTokenStreaming = 'nativeTokenStreaming';\n\nexport type NativeTokenStreamingBuilderConfig = {\n  /**\n   * The initial amount available at start time as a bigint.\n   */\n  initialAmount: bigint;\n  /**\n   * Maximum total amount that can be unlocked as a bigint.\n   */\n  maxAmount: bigint;\n  /**\n   * Rate at which tokens accrue per second as a bigint.\n   */\n  amountPerSecond: bigint;\n  /**\n   * Start timestamp as a number in seconds.\n   */\n  startTime: number;\n};\n\n/**\n * Builds a caveat struct for the NativeTokenStreamingEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the NativeTokenStreamingEnforcer.\n * @returns The Caveat.\n * @throws Error if any of the parameters are invalid.\n */\nexport const nativeTokenStreamingBuilder = (\n  environment: DeleGatorEnvironment,\n  config: NativeTokenStreamingBuilderConfig,\n): Caveat => {\n  const { initialAmount, maxAmount, amountPerSecond, startTime } = config;\n\n  const terms = createNativeTokenStreamingTerms({\n    initialAmount,\n    maxAmount,\n    amountPerSecond,\n    startTime,\n  });\n\n  const {\n    caveatEnforcers: { NativeTokenStreamingEnforcer },\n  } = environment;\n\n  if (!NativeTokenStreamingEnforcer) {\n    throw new Error('NativeTokenStreamingEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: NativeTokenStreamingEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { encodePacked } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const nativeTokenTransferAmount = 'nativeTokenTransferAmount';\n\nexport type NativeTokenTransferAmountBuilderConfig = {\n  /**\n   * The maximum amount of native tokens that can be transferred.\n   */\n  maxAmount: bigint;\n};\n\n/**\n * Builds a caveat struct for the NativeTokenTransferAmountEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the maxAmount.\n * @returns The Caveat.\n * @throws Error if the maxAmount is negative.\n */\nexport const nativeTokenTransferAmountBuilder = (\n  environment: DeleGatorEnvironment,\n  config: NativeTokenTransferAmountBuilderConfig,\n): Caveat => {\n  const { maxAmount } = config;\n\n  if (maxAmount < 0n) {\n    throw new Error('Invalid maxAmount: must be zero or positive');\n  }\n\n  const terms = encodePacked(['uint256'], [maxAmount]);\n\n  const {\n    caveatEnforcers: { NativeTokenTransferAmountEnforcer },\n  } = environment;\n\n  if (!NativeTokenTransferAmountEnforcer) {\n    throw new Error(\n      'NativeTokenTransferAmountEnforcer not found in environment',\n    );\n  }\n\n  return {\n    enforcer: NativeTokenTransferAmountEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createNonceTerms } from '@metamask/delegation-core';\nimport { type Hex } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const nonce = 'nonce';\n\nexport type NonceBuilderConfig = {\n  /**\n   * A nonce as a hex string to allow bulk revocation of delegations.\n   */\n  nonce: Hex;\n};\n\n/**\n * Builds a caveat struct for the NonceEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the nonce value.\n * @returns The Caveat.\n * @throws Error if the nonce is invalid.\n */\nexport const nonceBuilder = (\n  environment: DeleGatorEnvironment,\n  config: NonceBuilderConfig,\n): Caveat => {\n  const { nonce: nonceValue } = config;\n\n  const terms = createNonceTerms({ nonce: nonceValue });\n\n  const {\n    caveatEnforcers: { NonceEnforcer },\n  } = environment;\n\n  if (!NonceEnforcer) {\n    throw new Error('NonceEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: NonceEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, isAddress } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const ownershipTransfer = 'ownershipTransfer';\n\nexport type OwnershipTransferBuilderConfig = {\n  /**\n   * The target contract address as a hex string for which ownership transfers are allowed.\n   */\n  contractAddress: Address;\n};\n\n/**\n * Builds a caveat struct for the OwnershipTransferEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the ownership transfer builder.\n * @returns The Caveat representing the caveat for ownership transfer.\n * @throws Error if the target contract address is invalid.\n */\nexport const ownershipTransferBuilder = (\n  environment: DeleGatorEnvironment,\n  config: OwnershipTransferBuilderConfig,\n): Caveat => {\n  const { contractAddress } = config;\n\n  if (!isAddress(contractAddress, { strict: false })) {\n    throw new Error('Invalid contractAddress: must be a valid address');\n  }\n\n  const terms = contractAddress;\n\n  const {\n    caveatEnforcers: { OwnershipTransferEnforcer },\n  } = environment;\n\n  if (!OwnershipTransferEnforcer) {\n    throw new Error('OwnershipTransferEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: OwnershipTransferEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, concat, isAddress } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const redeemer = 'redeemer';\n\nexport type RedeemerBuilderConfig = {\n  /**\n   * An array of addresses that are allowed to redeem the delegation.\n   * Each address must be a valid hex string.\n   */\n  redeemers: Address[];\n};\n\n/**\n * Builds a caveat struct for the RedeemerEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing redeemers.\n * @returns The Caveat.\n * @throws Error if the redeemer address is invalid or the array is empty.\n */\nexport const redeemerBuilder = (\n  environment: DeleGatorEnvironment,\n  config: RedeemerBuilderConfig,\n): Caveat => {\n  const { redeemers } = config;\n\n  if (redeemers.length === 0) {\n    throw new Error(\n      'Invalid redeemers: must specify at least one redeemer address',\n    );\n  }\n\n  for (const redeemerAddress of redeemers) {\n    if (!isAddress(redeemerAddress)) {\n      throw new Error('Invalid redeemers: must be a valid address');\n    }\n  }\n\n  const terms = concat(redeemers);\n\n  const {\n    caveatEnforcers: { RedeemerEnforcer },\n  } = environment;\n\n  if (!RedeemerEnforcer) {\n    throw new Error('RedeemerEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: RedeemerEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { concat, isAddress, toHex, type Address, type Hex } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const specificActionERC20TransferBatch =\n  'specificActionERC20TransferBatch';\n\nexport type SpecificActionErc20TransferBatchBuilderConfig = {\n  /**\n   * The address of the ERC-20 token contract.\n   */\n  tokenAddress: Address;\n  /**\n   * The address that will receive the tokens.\n   */\n  recipient: Address;\n  /**\n   * The amount of tokens to transfer.\n   */\n  amount: bigint;\n  /**\n   * The target address for the first transaction.\n   */\n  target: Address;\n  /**\n   * The calldata for the first transaction.\n   */\n  calldata: Hex;\n};\n\n/**\n * Builds a caveat struct for SpecificActionERC20TransferBatchEnforcer.\n * Enforces a batch of exactly 2 transactions: a specific action followed by an ERC20 transfer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration for the specific action ERC20 transfer batch builder.\n * @returns The Caveat.\n * @throws Error if any of the addresses are invalid or if the amount is not a positive number.\n */\nexport const specificActionERC20TransferBatchBuilder = (\n  environment: DeleGatorEnvironment,\n  config: SpecificActionErc20TransferBatchBuilderConfig,\n): Caveat => {\n  const { tokenAddress, recipient, amount, target, calldata } = config;\n\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (!isAddress(recipient, { strict: false })) {\n    throw new Error('Invalid recipient: must be a valid address');\n  }\n\n  if (!isAddress(target, { strict: false })) {\n    throw new Error('Invalid target: must be a valid address');\n  }\n\n  if (amount <= 0n) {\n    throw new Error('Invalid amount: must be a positive number');\n  }\n\n  const terms = concat([\n    tokenAddress,\n    recipient,\n    toHex(amount, { size: 32 }),\n    target,\n    calldata,\n  ]);\n\n  const {\n    caveatEnforcers: { SpecificActionERC20TransferBatchEnforcer },\n  } = environment;\n\n  if (!SpecificActionERC20TransferBatchEnforcer) {\n    throw new Error(\n      'SpecificActionERC20TransferBatchEnforcer not found in environment',\n    );\n  }\n\n  return {\n    enforcer: SpecificActionERC20TransferBatchEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createTimestampTerms } from '@metamask/delegation-core';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const timestamp = 'timestamp';\n\nexport type TimestampBuilderConfig = {\n  /**\n   * The timestamp after which the delegation is valid in seconds.\n   * Set to 0 to disable this threshold.\n   */\n  afterThreshold: number;\n  /**\n   * The timestamp before which the delegation is valid.\n   * Set to 0 to disable this threshold.\n   */\n  beforeThreshold: number;\n};\n\n/**\n * Builds a caveat struct for the TimestampEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the TimestampEnforcer.\n * @returns The Caveat.\n * @throws Error if any of the parameters are invalid.\n */\nexport const timestampBuilder = (\n  environment: DeleGatorEnvironment,\n  config: TimestampBuilderConfig,\n): Caveat => {\n  const { afterThreshold, beforeThreshold } = config;\n\n  const terms = createTimestampTerms({\n    timestampAfterThreshold: afterThreshold,\n    timestampBeforeThreshold: beforeThreshold,\n  });\n\n  const {\n    caveatEnforcers: { TimestampEnforcer },\n  } = environment;\n\n  if (!TimestampEnforcer) {\n    throw new Error('TimestampEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: TimestampEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createValueLteTerms } from '@metamask/delegation-core';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const valueLte = 'valueLte';\n\nexport type ValueLteBuilderConfig = {\n  /**\n   * The maximum value that may be specified when redeeming this delegation.\n   */\n  maxValue: bigint;\n};\n\n/**\n * Builds a caveat struct for ValueLteEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the maximum value allowed for the transaction.\n * @returns The Caveat.\n * @throws Error if any of the parameters are invalid.\n */\nexport const valueLteBuilder = (\n  environment: DeleGatorEnvironment,\n  config: ValueLteBuilderConfig,\n): Caveat => {\n  const { maxValue } = config;\n\n  const terms = createValueLteTerms({ maxValue });\n\n  const {\n    caveatEnforcers: { ValueLteEnforcer },\n  } = environment;\n\n  if (!ValueLteEnforcer) {\n    throw new Error('ValueLteEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ValueLteEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment } from '../types';\nimport {\n  allowedCalldata,\n  allowedCalldataBuilder,\n} from './allowedCalldataBuilder';\nimport { allowedMethods, allowedMethodsBuilder } from './allowedMethodsBuilder';\nimport { allowedTargets, allowedTargetsBuilder } from './allowedTargetsBuilder';\nimport {\n  argsEqualityCheck,\n  argsEqualityCheckBuilder,\n} from './argsEqualityCheckBuilder';\nimport { blockNumber, blockNumberBuilder } from './blockNumberBuilder';\nimport type { CaveatBuilderConfig } from './caveatBuilder';\nimport { CaveatBuilder } from './caveatBuilder';\nimport { deployed, deployedBuilder } from './deployedBuilder';\nimport {\n  erc1155BalanceChange,\n  erc1155BalanceChangeBuilder,\n} from './erc1155BalanceChangeBuilder';\nimport {\n  erc20BalanceChange,\n  erc20BalanceChangeBuilder,\n} from './erc20BalanceChangeBuilder';\nimport {\n  erc20PeriodTransfer,\n  erc20PeriodTransferBuilder,\n} from './erc20PeriodTransferBuilder';\nimport { erc20Streaming, erc20StreamingBuilder } from './erc20StreamingBuilder';\nimport {\n  erc20TransferAmount,\n  erc20TransferAmountBuilder,\n} from './erc20TransferAmountBuilder';\nimport {\n  erc721BalanceChange,\n  erc721BalanceChangeBuilder,\n} from './erc721BalanceChangeBuilder';\nimport { erc721Transfer, erc721TransferBuilder } from './erc721TransferBuilder';\nimport {\n  exactCalldataBatch,\n  exactCalldataBatchBuilder,\n} from './exactCalldataBatchBuilder';\nimport { exactCalldata, exactCalldataBuilder } from './exactCalldataBuilder';\nimport {\n  exactExecutionBatch,\n  exactExecutionBatchBuilder,\n} from './exactExecutionBatchBuilder';\nimport { exactExecution, exactExecutionBuilder } from './exactExecutionBuilder';\nimport { id, idBuilder } from './idBuilder';\nimport { limitedCalls, limitedCallsBuilder } from './limitedCallsBuilder';\nimport {\n  multiTokenPeriod,\n  multiTokenPeriodBuilder,\n} from './multiTokenPeriodBuilder';\nimport {\n  nativeBalanceChange,\n  nativeBalanceChangeBuilder,\n} from './nativeBalanceChangeBuilder';\nimport {\n  nativeTokenPayment,\n  nativeTokenPaymentBuilder,\n} from './nativeTokenPaymentBuilder';\nimport {\n  nativeTokenPeriodTransfer,\n  nativeTokenPeriodTransferBuilder,\n} from './nativeTokenPeriodTransferBuilder';\nimport {\n  nativeTokenStreaming,\n  nativeTokenStreamingBuilder,\n} from './nativeTokenStreamingBuilder';\nimport {\n  nativeTokenTransferAmount,\n  nativeTokenTransferAmountBuilder,\n} from './nativeTokenTransferAmountBuilder';\nimport { nonce, nonceBuilder } from './nonceBuilder';\nimport {\n  ownershipTransfer,\n  ownershipTransferBuilder,\n} from './ownershipTransferBuilder';\nimport { redeemer, redeemerBuilder } from './redeemerBuilder';\nimport {\n  specificActionERC20TransferBatch,\n  specificActionERC20TransferBatchBuilder,\n} from './specificActionERC20TransferBatchBuilder';\nimport { timestamp, timestampBuilder } from './timestampBuilder';\nimport { valueLte, valueLteBuilder } from './valueLteBuilder';\n\n// While we could derive CoreCaveatMap from the createCaveatBuilder function,\n// doing so would significantly complicate type resolution. By explicitly\n// declaring the return type of createCaveatBuilder, we ensure the caveat\n// map remains synchronized with the actual implementation.\ntype CoreCaveatMap = {\n  allowedMethods: typeof allowedMethodsBuilder;\n  allowedTargets: typeof allowedTargetsBuilder;\n  deployed: typeof deployedBuilder;\n  allowedCalldata: typeof allowedCalldataBuilder;\n  erc20BalanceChange: typeof erc20BalanceChangeBuilder;\n  erc721BalanceChange: typeof erc721BalanceChangeBuilder;\n  erc1155BalanceChange: typeof erc1155BalanceChangeBuilder;\n  valueLte: typeof valueLteBuilder;\n  limitedCalls: typeof limitedCallsBuilder;\n  id: typeof idBuilder;\n  nonce: typeof nonceBuilder;\n  timestamp: typeof timestampBuilder;\n  blockNumber: typeof blockNumberBuilder;\n  erc20TransferAmount: typeof erc20TransferAmountBuilder;\n  erc20Streaming: typeof erc20StreamingBuilder;\n  nativeTokenStreaming: typeof nativeTokenStreamingBuilder;\n  erc721Transfer: typeof erc721TransferBuilder;\n  nativeTokenTransferAmount: typeof nativeTokenTransferAmountBuilder;\n  nativeBalanceChange: typeof nativeBalanceChangeBuilder;\n  redeemer: typeof redeemerBuilder;\n  nativeTokenPayment: typeof nativeTokenPaymentBuilder;\n  argsEqualityCheck: typeof argsEqualityCheckBuilder;\n  specificActionERC20TransferBatch: typeof specificActionERC20TransferBatchBuilder;\n  erc20PeriodTransfer: typeof erc20PeriodTransferBuilder;\n  nativeTokenPeriodTransfer: typeof nativeTokenPeriodTransferBuilder;\n  exactCalldataBatch: typeof exactCalldataBatchBuilder;\n  exactCalldata: typeof exactCalldataBuilder;\n  exactExecution: typeof exactExecutionBuilder;\n  exactExecutionBatch: typeof exactExecutionBatchBuilder;\n  multiTokenPeriod: typeof multiTokenPeriodBuilder;\n  ownershipTransfer: typeof ownershipTransferBuilder;\n};\n\n/**\n * A caveat builder type that includes all core caveat types pre-configured.\n * This type represents a fully configured caveat builder with all the standard\n * caveat builders available for use.\n */\nexport type CoreCaveatBuilder = CaveatBuilder<CoreCaveatMap>;\n\ntype ExtractCaveatMapType<TCaveatBuilder extends CaveatBuilder<any>> =\n  TCaveatBuilder extends CaveatBuilder<infer TCaveatMap> ? TCaveatMap : never;\ntype ExtractedCoreMap = ExtractCaveatMapType<CoreCaveatBuilder>;\n\nexport type CaveatConfigurations = {\n  [TType in keyof ExtractedCoreMap]: {\n    type: TType;\n  } & Parameters<ExtractedCoreMap[TType]>[1];\n}[keyof ExtractedCoreMap];\n\nexport type CaveatConfiguration<\n  TCaveatBuilder extends CaveatBuilder<any>,\n  CaveatMap = ExtractCaveatMapType<TCaveatBuilder>,\n> =\n  CaveatMap extends Record<string, (...args: any[]) => any>\n    ? {\n        [TType in keyof CaveatMap]: {\n          type: TType;\n        } & Parameters<CaveatMap[TType]>[1];\n      }[keyof CaveatMap]\n    : never;\n\nexport type CoreCaveatConfiguration = CaveatConfiguration<CoreCaveatBuilder>;\n\n/**\n * Creates a caveat builder with all core caveat types pre-configured.\n *\n * @param environment - The DeleGator environment configuration.\n * @param config - Optional configuration for the caveat builder.\n * @returns A fully configured CoreCaveatBuilder instance with all core caveat types.\n */\nexport const createCaveatBuilder = (\n  environment: DeleGatorEnvironment,\n  config?: CaveatBuilderConfig,\n): CoreCaveatBuilder => {\n  const caveatBuilder = new CaveatBuilder(environment, config)\n    .extend(allowedMethods, allowedMethodsBuilder)\n    .extend(allowedTargets, allowedTargetsBuilder)\n    .extend(deployed, deployedBuilder)\n    .extend(allowedCalldata, allowedCalldataBuilder)\n    .extend(erc20BalanceChange, erc20BalanceChangeBuilder)\n    .extend(erc721BalanceChange, erc721BalanceChangeBuilder)\n    .extend(erc1155BalanceChange, erc1155BalanceChangeBuilder)\n    .extend(valueLte, valueLteBuilder)\n    .extend(limitedCalls, limitedCallsBuilder)\n    .extend(id, idBuilder)\n    .extend(nonce, nonceBuilder)\n    .extend(timestamp, timestampBuilder)\n    .extend(blockNumber, blockNumberBuilder)\n    .extend(erc20TransferAmount, erc20TransferAmountBuilder)\n    .extend(erc20Streaming, erc20StreamingBuilder)\n    .extend(nativeTokenStreaming, nativeTokenStreamingBuilder)\n    .extend(erc721Transfer, erc721TransferBuilder)\n    .extend(nativeTokenTransferAmount, nativeTokenTransferAmountBuilder)\n    .extend(nativeBalanceChange, nativeBalanceChangeBuilder)\n    .extend(redeemer, redeemerBuilder)\n    .extend(nativeTokenPayment, nativeTokenPaymentBuilder)\n    .extend(argsEqualityCheck, argsEqualityCheckBuilder)\n    .extend(\n      specificActionERC20TransferBatch,\n      specificActionERC20TransferBatchBuilder,\n    )\n    .extend(erc20PeriodTransfer, erc20PeriodTransferBuilder)\n    .extend(nativeTokenPeriodTransfer, nativeTokenPeriodTransferBuilder)\n    .extend(exactCalldataBatch, exactCalldataBatchBuilder)\n    .extend(exactCalldata, exactCalldataBuilder)\n    .extend(exactExecution, exactExecutionBuilder)\n    .extend(exactExecutionBatch, exactExecutionBatchBuilder)\n    .extend(multiTokenPeriod, multiTokenPeriodBuilder)\n    .extend(ownershipTransfer, ownershipTransferBuilder);\n\n  return caveatBuilder;\n};\n","import type { DeleGatorEnvironment } from '../../types';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type {\n  erc20PeriodTransfer,\n  Erc20PeriodTransferBuilderConfig,\n} from '../erc20PeriodTransferBuilder';\n\nexport type Erc20PeriodicScopeConfig = {\n  type: typeof erc20PeriodTransfer;\n} & Erc20PeriodTransferBuilderConfig;\n\n/**\n * Creates a caveat builder configured for ERC20 token periodic transfers with recurring limits.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing ERC20 periodic transfer parameters.\n * @returns A configured caveat builder with ERC20 period transfer and value limit caveats.\n * @throws Error if any of the ERC20 periodic transfer parameters are invalid.\n * @throws Error if the environment is not properly configured.\n */\nexport function createErc20PeriodicCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: Erc20PeriodicScopeConfig,\n): CoreCaveatBuilder {\n  return createCaveatBuilder(environment)\n    .addCaveat('valueLte', {\n      maxValue: 0n,\n    })\n    .addCaveat('erc20PeriodTransfer', {\n      tokenAddress: config.tokenAddress,\n      periodAmount: config.periodAmount,\n      periodDuration: config.periodDuration,\n      startDate: config.startDate,\n    });\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type {\n  erc20Streaming,\n  Erc20StreamingBuilderConfig,\n} from '../erc20StreamingBuilder';\n\nexport type Erc20StreamingScopeConfig = {\n  type: typeof erc20Streaming;\n} & Erc20StreamingBuilderConfig;\n\n/**\n * Creates a caveat builder configured for ERC20 token streaming with time-based limits.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing ERC20 streaming parameters.\n * @returns A configured caveat builder with ERC20 streaming and value limit caveats.\n * @throws Error if any of the ERC20 streaming parameters are invalid.\n * @throws Error if the environment is not properly configured.\n */\nexport function createErc20StreamingCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: Erc20StreamingScopeConfig,\n): CoreCaveatBuilder {\n  return createCaveatBuilder(environment)\n    .addCaveat('valueLte', {\n      maxValue: 0n,\n    })\n    .addCaveat('erc20Streaming', {\n      tokenAddress: config.tokenAddress,\n      initialAmount: config.initialAmount,\n      maxAmount: config.maxAmount,\n      amountPerSecond: config.amountPerSecond,\n      startTime: config.startTime,\n    });\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type {\n  erc20TransferAmount,\n  Erc20TransferAmountBuilderConfig,\n} from '../erc20TransferAmountBuilder';\n\nexport type Erc20TransferScopeConfig = {\n  type: typeof erc20TransferAmount;\n} & Erc20TransferAmountBuilderConfig;\n\n/**\n * Creates a caveat builder configured for ERC20 token transfers with amount limits.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing ERC20 transfer parameters.\n * @returns A configured caveat builder with ERC20 transfer amount and value limit caveats.\n * @throws Error if any of the ERC20 transfer parameters are invalid.\n * @throws Error if the environment is not properly configured.\n */\nexport function createErc20TransferCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: Erc20TransferScopeConfig,\n): CoreCaveatBuilder {\n  return createCaveatBuilder(environment)\n    .addCaveat('valueLte', {\n      maxValue: 0n,\n    })\n    .addCaveat('erc20TransferAmount', {\n      tokenAddress: config.tokenAddress,\n      maxAmount: config.maxAmount,\n    });\n}\n","import { type Hex, isHex, toHex } from 'viem';\n\n/**\n * Checks if two hexadecimal strings are equal, ignoring case sensitivity.\n * @param a - The first hexadecimal string.\n * @param b - The second hexadecimal string.\n * @returns True if the hexadecimal strings are equal, false otherwise.\n */\nexport function isEqualHex(a: Hex, b: Hex): boolean {\n  return isHex(a) && a.toLowerCase() === b.toLowerCase();\n}\n\n/**\n * Recursively converts all members of an object to hexadecimal format.\n * Handles various data types including functions, null, strings, booleans,\n * bigints, arrays, and objects.\n *\n * @param obj - The object to convert to hexadecimal format.\n * @returns The object with all values converted to hexadecimal format.\n */\nexport function deepHexlify(obj: any): any {\n  if (typeof obj === 'function') {\n    return undefined;\n  }\n\n  if (\n    obj === null ||\n    obj === undefined ||\n    typeof obj === 'string' ||\n    typeof obj === 'boolean'\n  ) {\n    return obj;\n  }\n\n  if (typeof obj === 'bigint') {\n    return toHex(obj);\n  }\n\n  if (obj._isBigNumber !== null || typeof obj !== 'object') {\n    return toHex(obj).replace(/^0x0/u, '0x');\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((member) => deepHexlify(member));\n  }\n\n  return Object.keys(obj).reduce(\n    (set, key) =>\n      Object.assign(Object.assign({}, set), {\n        [key]: deepHexlify(obj[key]),\n      }),\n    {},\n  );\n}\n\n/**\n * Utility function to check if an object has all specified properties defined and not undefined.\n *\n * @template TObject - The type of the object to check.\n * @template TKey - The keys of the properties to check for.\n * @param object - The object to check for the required properties.\n * @param properties - An array of property names to verify on the object.\n * @returns True if all specified properties exist on the object and are not undefined, otherwise false.\n */\nexport const hasProperties = <\n  TObject extends Record<string, any>,\n  TKey extends keyof TObject,\n>(\n  object: TObject,\n  properties: readonly TKey[],\n): object is TObject & Record<TKey, NonNullable<TObject[TKey]>> => {\n  return properties.every(\n    (prop) => prop in object && object[prop] !== undefined,\n  );\n};\n","import type { DeleGatorEnvironment } from '../../types';\nimport { hasProperties } from '../../utils';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type {\n  erc721Transfer,\n  Erc721TransferBuilderConfig,\n} from '../erc721TransferBuilder';\n\nexport type Erc721ScopeBaseConfig = {\n  type: typeof erc721Transfer;\n};\n\nexport type Erc721ScopeConfig = Erc721ScopeBaseConfig &\n  Erc721TransferBuilderConfig;\n\nconst isErc721TransferConfig = (\n  config: Erc721ScopeBaseConfig,\n): config is Erc721TransferBuilderConfig & Erc721ScopeBaseConfig => {\n  return hasProperties(\n    config as Erc721TransferBuilderConfig & Erc721ScopeBaseConfig,\n    ['tokenAddress', 'tokenId'],\n  );\n};\n\n/**\n * Creates a caveat builder configured for ERC721 unit of authority.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing permitted contract and token ID.\n * @returns A configured caveat builder with the specified caveats.\n * @throws Error if any of the required parameters are invalid.\n */\nexport function createErc721CaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: Erc721ScopeConfig,\n): CoreCaveatBuilder {\n  if (!isErc721TransferConfig(config)) {\n    throw new Error('Invalid ERC721 configuration');\n  }\n\n  const caveatBuilder = createCaveatBuilder(environment).addCaveat(\n    'erc721Transfer',\n    config,\n  );\n\n  return caveatBuilder;\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport { hasProperties } from '../../utils';\nimport type { AllowedCalldataBuilderConfig } from '../allowedCalldataBuilder';\nimport type { AllowedMethodsBuilderConfig } from '../allowedMethodsBuilder';\nimport type { AllowedTargetsBuilderConfig } from '../allowedTargetsBuilder';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type { ExactCalldataBuilderConfig } from '../exactCalldataBuilder';\n\ntype FunctionCallScopeBaseConfig = {\n  type: 'functionCall';\n};\n\nexport type FunctionCallScopeConfig = FunctionCallScopeBaseConfig &\n  AllowedTargetsBuilderConfig &\n  AllowedMethodsBuilderConfig & {\n    allowedCalldata?: AllowedCalldataBuilderConfig[];\n    exactCalldata?: ExactCalldataBuilderConfig;\n  };\n\nconst isFunctionCallConfig = (\n  config: FunctionCallScopeConfig,\n): config is FunctionCallScopeConfig => {\n  return hasProperties(config, ['targets', 'selectors']);\n};\n\n/**\n * Creates a caveat builder configured for function call unit of authority.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing allowed targets, methods, and optionally calldata.\n * @returns A configured caveat builder with the specified caveats.\n * @throws Error if any of the required parameters are invalid.\n * @throws Error if both allowedCalldata and exactCalldata are provided simultaneously.\n */\nexport function createFunctionCallCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: FunctionCallScopeConfig,\n): CoreCaveatBuilder {\n  const { targets, selectors, allowedCalldata, exactCalldata } = config;\n\n  if (!isFunctionCallConfig(config)) {\n    throw new Error('Invalid Function Call configuration');\n  }\n\n  if (allowedCalldata && allowedCalldata.length > 0 && exactCalldata) {\n    throw new Error(\n      'Cannot specify both allowedCalldata and exactCalldata. Please use only one calldata restriction type.',\n    );\n  }\n\n  const caveatBuilder = createCaveatBuilder(environment)\n    .addCaveat('allowedTargets', { targets })\n    .addCaveat('allowedMethods', { selectors });\n\n  if (allowedCalldata && allowedCalldata.length > 0) {\n    allowedCalldata.forEach((calldataConfig) => {\n      caveatBuilder.addCaveat('allowedCalldata', calldataConfig);\n    });\n  } else if (exactCalldata) {\n    caveatBuilder.addCaveat('exactCalldata', exactCalldata);\n  }\n\n  return caveatBuilder;\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport type { AllowedCalldataBuilderConfig } from '../allowedCalldataBuilder';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type { ExactCalldataBuilderConfig } from '../exactCalldataBuilder';\nimport type {\n  nativeTokenPeriodTransfer,\n  NativeTokenPeriodTransferBuilderConfig,\n} from '../nativeTokenPeriodTransferBuilder';\n\nexport type NativeTokenPeriodicScopeConfig = {\n  type: typeof nativeTokenPeriodTransfer;\n  allowedCalldata?: AllowedCalldataBuilderConfig[];\n  exactCalldata?: ExactCalldataBuilderConfig;\n} & NativeTokenPeriodTransferBuilderConfig;\n\n/**\n * Creates a caveat builder configured for native token periodic transfers with recurring limits.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing native token periodic transfer parameters.\n * @returns A configured caveat builder with native token period transfer and exact calldata caveats.\n * @throws Error if any of the native token periodic transfer parameters are invalid.\n * @throws Error if both allowedCalldata and exactCalldata are provided simultaneously.\n * @throws Error if the environment is not properly configured.\n */\nexport function createNativeTokenPeriodicCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: NativeTokenPeriodicScopeConfig,\n): CoreCaveatBuilder {\n  const {\n    periodAmount,\n    periodDuration,\n    startDate,\n    allowedCalldata,\n    exactCalldata,\n  } = config;\n\n  if (allowedCalldata && allowedCalldata.length > 0 && exactCalldata) {\n    throw new Error(\n      'Cannot specify both allowedCalldata and exactCalldata. Please use only one calldata restriction type.',\n    );\n  }\n\n  const caveatBuilder = createCaveatBuilder(environment);\n\n  // Add calldata restrictions\n  if (allowedCalldata && allowedCalldata.length > 0) {\n    allowedCalldata.forEach((calldataConfig) => {\n      caveatBuilder.addCaveat('allowedCalldata', calldataConfig);\n    });\n  } else if (exactCalldata) {\n    caveatBuilder.addCaveat('exactCalldata', exactCalldata);\n  } else {\n    // Default behavior: only allow empty calldata\n    caveatBuilder.addCaveat('exactCalldata', {\n      calldata: '0x',\n    });\n  }\n\n  // Add native token period transfer restriction\n  caveatBuilder.addCaveat('nativeTokenPeriodTransfer', {\n    periodAmount,\n    periodDuration,\n    startDate,\n  });\n\n  return caveatBuilder;\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport type { AllowedCalldataBuilderConfig } from '../allowedCalldataBuilder';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type { ExactCalldataBuilderConfig } from '../exactCalldataBuilder';\nimport type {\n  nativeTokenStreaming,\n  NativeTokenStreamingBuilderConfig,\n} from '../nativeTokenStreamingBuilder';\n\nexport type NativeTokenStreamingScopeConfig = {\n  type: typeof nativeTokenStreaming;\n  allowedCalldata?: AllowedCalldataBuilderConfig[];\n  exactCalldata?: ExactCalldataBuilderConfig;\n} & NativeTokenStreamingBuilderConfig;\n\n/**\n * Creates a caveat builder configured for native token streaming with time-based limits.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing native token streaming parameters.\n * @returns A configured caveat builder with native token streaming and exact calldata caveats.\n * @throws Error if any of the native token streaming parameters are invalid.\n * @throws Error if both allowedCalldata and exactCalldata are provided simultaneously.\n * @throws Error if the environment is not properly configured.\n */\nexport function createNativeTokenStreamingCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: NativeTokenStreamingScopeConfig,\n): CoreCaveatBuilder {\n  const {\n    initialAmount,\n    maxAmount,\n    amountPerSecond,\n    startTime,\n    allowedCalldata,\n    exactCalldata,\n  } = config;\n\n  if (allowedCalldata && allowedCalldata.length > 0 && exactCalldata) {\n    throw new Error(\n      'Cannot specify both allowedCalldata and exactCalldata. Please use only one calldata restriction type.',\n    );\n  }\n\n  const caveatBuilder = createCaveatBuilder(environment);\n\n  // Add calldata restrictions\n  if (allowedCalldata && allowedCalldata.length > 0) {\n    allowedCalldata.forEach((calldataConfig) => {\n      caveatBuilder.addCaveat('allowedCalldata', calldataConfig);\n    });\n  } else if (exactCalldata) {\n    caveatBuilder.addCaveat('exactCalldata', exactCalldata);\n  } else {\n    // Default behavior: only allow empty calldata\n    caveatBuilder.addCaveat('exactCalldata', {\n      calldata: '0x',\n    });\n  }\n\n  // Add native token streaming restriction\n  caveatBuilder.addCaveat('nativeTokenStreaming', {\n    initialAmount,\n    maxAmount,\n    amountPerSecond,\n    startTime,\n  });\n\n  return caveatBuilder;\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport type { AllowedCalldataBuilderConfig } from '../allowedCalldataBuilder';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type { ExactCalldataBuilderConfig } from '../exactCalldataBuilder';\nimport type {\n  nativeTokenTransferAmount,\n  NativeTokenTransferAmountBuilderConfig,\n} from '../nativeTokenTransferAmountBuilder';\n\nexport type NativeTokenTransferScopeConfig = {\n  type: typeof nativeTokenTransferAmount;\n  allowedCalldata?: AllowedCalldataBuilderConfig[];\n  exactCalldata?: ExactCalldataBuilderConfig;\n} & NativeTokenTransferAmountBuilderConfig;\n\n/**\n * Creates a caveat builder configured for native token transfers with amount limits.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing native token transfer parameters.\n * @returns A configured caveat builder with native token transfer amount and exact calldata caveats.\n * @throws Error if any of the native token transfer parameters are invalid.\n * @throws Error if both allowedCalldata and exactCalldata are provided simultaneously.\n * @throws Error if the environment is not properly configured.\n */\nexport function createNativeTokenTransferCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: NativeTokenTransferScopeConfig,\n): CoreCaveatBuilder {\n  const { maxAmount, allowedCalldata, exactCalldata } = config;\n\n  if (allowedCalldata && allowedCalldata.length > 0 && exactCalldata) {\n    throw new Error(\n      'Cannot specify both allowedCalldata and exactCalldata. Please use only one calldata restriction type.',\n    );\n  }\n\n  const caveatBuilder = createCaveatBuilder(environment);\n\n  // Add calldata restrictions\n  if (allowedCalldata && allowedCalldata.length > 0) {\n    allowedCalldata.forEach((calldataConfig) => {\n      caveatBuilder.addCaveat('allowedCalldata', calldataConfig);\n    });\n  } else if (exactCalldata) {\n    caveatBuilder.addCaveat('exactCalldata', exactCalldata);\n  } else {\n    // Default behavior: only allow empty calldata\n    caveatBuilder.addCaveat('exactCalldata', {\n      calldata: '0x',\n    });\n  }\n\n  // Add native token transfer amount restriction\n  caveatBuilder.addCaveat('nativeTokenTransferAmount', {\n    maxAmount,\n  });\n\n  return caveatBuilder;\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport { hasProperties } from '../../utils';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type {\n  ownershipTransfer,\n  OwnershipTransferBuilderConfig,\n} from '../ownershipTransferBuilder';\n\ntype OwnershipScopeBaseConfig = {\n  type: typeof ownershipTransfer;\n};\n\nexport type OwnershipScopeConfig = OwnershipScopeBaseConfig &\n  OwnershipTransferBuilderConfig;\n\nconst isOwnershipTransferConfig = (\n  config: OwnershipScopeConfig,\n): config is OwnershipTransferBuilderConfig & OwnershipScopeBaseConfig => {\n  return hasProperties(\n    config as OwnershipTransferBuilderConfig & OwnershipScopeBaseConfig,\n    ['contractAddress'],\n  );\n};\n\n/**\n * Creates a caveat builder configured for ownership transfer unit of authority.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing the target contract.\n * @returns A configured caveat builder with the specified caveats.\n * @throws Error if any of the required parameters are invalid.\n */\nexport function createOwnershipCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: OwnershipScopeConfig,\n): CoreCaveatBuilder {\n  if (!isOwnershipTransferConfig(config)) {\n    throw new Error('Invalid ownership transfer configuration');\n  }\n\n  const caveatBuilder = createCaveatBuilder(environment).addCaveat(\n    'ownershipTransfer',\n    config,\n  );\n\n  return caveatBuilder;\n}\n","import {\n  type Erc20PeriodicScopeConfig,\n  createErc20PeriodicCaveatBuilder,\n} from './erc20PeriodicScope';\nimport {\n  type Erc20StreamingScopeConfig,\n  createErc20StreamingCaveatBuilder,\n} from './erc20StreamingScope';\nimport {\n  type Erc20TransferScopeConfig,\n  createErc20TransferCaveatBuilder,\n} from './erc20TransferScope';\nimport {\n  type Erc721ScopeConfig,\n  createErc721CaveatBuilder,\n} from './erc721Scope';\nimport {\n  createFunctionCallCaveatBuilder,\n  type FunctionCallScopeConfig,\n} from './functionCallScope';\nimport {\n  type NativeTokenPeriodicScopeConfig,\n  createNativeTokenPeriodicCaveatBuilder,\n} from './nativeTokenPeriodicScope';\nimport {\n  type NativeTokenStreamingScopeConfig,\n  createNativeTokenStreamingCaveatBuilder,\n} from './nativeTokenStreamingScope';\nimport {\n  type NativeTokenTransferScopeConfig,\n  createNativeTokenTransferCaveatBuilder,\n} from './nativeTokenTransferScope';\nimport {\n  createOwnershipCaveatBuilder,\n  type OwnershipScopeConfig,\n} from './ownershipScope';\nimport type { DeleGatorEnvironment } from '../../types';\n// Import caveat builder name constants\nimport { erc20PeriodTransfer } from '../erc20PeriodTransferBuilder';\nimport { erc20Streaming } from '../erc20StreamingBuilder';\nimport { erc20TransferAmount } from '../erc20TransferAmountBuilder';\nimport { erc721Transfer } from '../erc721TransferBuilder';\nimport { nativeTokenPeriodTransfer } from '../nativeTokenPeriodTransferBuilder';\nimport { nativeTokenStreaming } from '../nativeTokenStreamingBuilder';\nimport { nativeTokenTransferAmount } from '../nativeTokenTransferAmountBuilder';\nimport { ownershipTransfer } from '../ownershipTransferBuilder';\n\nexport type ScopeConfig =\n  | Erc20TransferScopeConfig\n  | Erc20StreamingScopeConfig\n  | Erc20PeriodicScopeConfig\n  | NativeTokenTransferScopeConfig\n  | NativeTokenStreamingScopeConfig\n  | NativeTokenPeriodicScopeConfig\n  | Erc721ScopeConfig\n  | OwnershipScopeConfig\n  | FunctionCallScopeConfig;\n\nexport const createCaveatBuilderFromScope = (\n  environment: DeleGatorEnvironment,\n  scopeConfig: ScopeConfig,\n) => {\n  switch (scopeConfig.type) {\n    case erc20TransferAmount:\n      return createErc20TransferCaveatBuilder(environment, scopeConfig);\n    case erc20Streaming:\n      return createErc20StreamingCaveatBuilder(environment, scopeConfig);\n    case erc20PeriodTransfer:\n      return createErc20PeriodicCaveatBuilder(environment, scopeConfig);\n    case nativeTokenTransferAmount:\n      return createNativeTokenTransferCaveatBuilder(environment, scopeConfig);\n    case nativeTokenStreaming:\n      return createNativeTokenStreamingCaveatBuilder(environment, scopeConfig);\n    case nativeTokenPeriodTransfer:\n      return createNativeTokenPeriodicCaveatBuilder(environment, scopeConfig);\n    case erc721Transfer:\n      return createErc721CaveatBuilder(environment, scopeConfig);\n    case ownershipTransfer:\n      return createOwnershipCaveatBuilder(environment, scopeConfig);\n    case 'functionCall':\n      return createFunctionCallCaveatBuilder(environment, scopeConfig);\n    default:\n      // eslint-disable-next-line no-case-declarations\n      const exhaustivenessCheck: never = scopeConfig;\n      throw new Error(\n        `Invalid scope type: ${(exhaustivenessCheck as { type: string }).type}`,\n      );\n  }\n};\n","import type { CaveatBuilder } from './caveatBuilder';\nimport type { CoreCaveatConfiguration } from './coreCaveatBuilder';\nimport { createCaveatBuilderFromScope, type ScopeConfig } from './scope';\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport type Caveats = CaveatBuilder | (Caveat | CoreCaveatConfiguration)[];\n\n/**\n * Resolves the array of Caveat from a Caveats argument.\n * @param config - The configuration for the caveat builder.\n * @param config.environment - The environment to be used for the caveat builder.\n * @param config.scope - The scope to be used for the caveat builder.\n * @param config.caveats - The caveats to be resolved, which can be either a CaveatBuilder or an array of Caveat or CaveatConfiguration. Optional - if not provided, only scope caveats will be used.\n * @returns The resolved array of caveats.\n */\nexport const resolveCaveats = ({\n  environment,\n  scope,\n  caveats,\n}: {\n  environment: DeleGatorEnvironment;\n  scope: ScopeConfig;\n  caveats?: Caveats;\n}) => {\n  const scopeCaveatBuilder = createCaveatBuilderFromScope(environment, scope);\n\n  if (caveats) {\n    if ('build' in caveats && typeof caveats.build === 'function') {\n      (caveats as CaveatBuilder).build().forEach((caveat) => {\n        scopeCaveatBuilder.addCaveat(caveat);\n      });\n    } else if (Array.isArray(caveats)) {\n      caveats.forEach((caveat) => {\n        try {\n          if ('type' in caveat) {\n            const { type, ...config } = caveat;\n            scopeCaveatBuilder.addCaveat(type, config);\n          } else {\n            scopeCaveatBuilder.addCaveat(caveat);\n          }\n        } catch (error) {\n          throw new Error(`Invalid caveat: ${(error as Error).message}`);\n        }\n      });\n    }\n  }\n\n  return scopeCaveatBuilder.build();\n};\n","import {\n  type Hex,\n  encodePacked,\n  encodeAbiParameters,\n  parseAbiParameters,\n  keccak256,\n  toHex,\n} from 'viem';\n\nimport type { Caveat } from './types';\n\nexport const CAVEAT_ABI_TYPE_COMPONENTS = [\n  { type: 'address', name: 'enforcer' },\n  { type: 'bytes', name: 'terms' },\n  { type: 'bytes', name: 'args' },\n];\n\nexport const CAVEAT_TYPEHASH: Hex = keccak256(\n  toHex('Caveat(address enforcer,bytes terms)'),\n);\n\n/**\n * Calculates the hash of a single Caveat.\n * @param input - The Caveat data.\n * @returns The keccak256 hash of the encoded Caveat packet.\n */\nexport const getCaveatPacketHash = (input: Caveat): Hex => {\n  const encoded = encodeAbiParameters(\n    parseAbiParameters('bytes32, address, bytes32'),\n    [CAVEAT_TYPEHASH, input.enforcer, keccak256(input.terms)],\n  );\n  return keccak256(encoded);\n};\n\n/**\n * Calculates the hash of an array of Caveats.\n * @param input - The array of Caveats.\n * @returns The keccak256 hash of the encoded Caveat array packet.\n */\nexport const getCaveatArrayPacketHash = (input: Caveat[]): Hex => {\n  let encoded: Hex = '0x';\n\n  for (const caveat of input) {\n    const caveatPacketHash = getCaveatPacketHash(caveat);\n    encoded = encodePacked(['bytes', 'bytes32'], [encoded, caveatPacketHash]);\n  }\n  return keccak256(encoded);\n};\n\n/**\n * Creates a caveat.\n * @param enforcer - The contract that guarantees the caveat is upheld.\n * @param terms - The data that the enforcer will use to verify the caveat (unique per enforcer).\n * @param args - Additional arguments for the caveat (optional).\n * @returns A Caveat.\n */\nexport const createCaveat = (\n  enforcer: Hex,\n  terms: Hex,\n  args: Hex = '0x',\n): Caveat => ({\n  enforcer,\n  terms,\n  args,\n});\n","import {\n  encodeDelegations as encodeDelegationsCore,\n  decodeDelegations as decodeDelegationsCore,\n  hashDelegation,\n  ANY_BENEFICIARY,\n  DELEGATION_TYPEHASH,\n  CAVEAT_TYPEHASH,\n  ROOT_AUTHORITY,\n} from '@metamask/delegation-core';\nimport { hashMessage, toBytes, toHex, getAddress } from 'viem';\nimport type { TypedData, AbiParameter, Address, Hex } from 'viem';\nimport { signTypedData } from 'viem/accounts';\n\nimport { type Caveats, resolveCaveats } from './caveatBuilder';\nimport type { ScopeConfig } from './caveatBuilder/scope';\nimport { CAVEAT_ABI_TYPE_COMPONENTS } from './caveats';\nimport type { Delegation, DeleGatorEnvironment } from './types';\n\nexport {\n  ANY_BENEFICIARY,\n  DELEGATION_TYPEHASH,\n  CAVEAT_TYPEHASH,\n  ROOT_AUTHORITY,\n};\n\n/**\n * The ABI type components of a Delegation.\n */\nexport const DELEGATION_ABI_TYPE_COMPONENTS = [\n  { type: 'address', name: 'delegate' },\n  { type: 'address', name: 'delegator' },\n  { type: 'bytes32', name: 'authority' },\n  { type: 'tuple[]', name: 'caveats', components: CAVEAT_ABI_TYPE_COMPONENTS },\n  { type: 'uint256', name: 'salt' },\n  { type: 'bytes', name: 'signature' },\n];\n\n/**\n * Converts a delegation to a delegation struct.\n * @param delegation - The delegation to convert.\n * @returns The delegation struct.\n */\nexport const toDelegationStruct = (\n  delegation: Delegation,\n): DelegationStruct => {\n  const caveats = delegation.caveats.map((caveat) => ({\n    enforcer: getAddress(caveat.enforcer),\n    terms: caveat.terms,\n    args: caveat.args,\n  }));\n\n  const salt = delegation.salt === '0x' ? 0n : BigInt(delegation.salt);\n\n  return {\n    delegate: getAddress(delegation.delegate),\n    delegator: getAddress(delegation.delegator),\n    authority:\n      delegation.authority === undefined\n        ? ROOT_AUTHORITY\n        : delegation.authority,\n    caveats,\n    salt,\n    signature: delegation.signature,\n  };\n};\n\n/**\n * Converts a DelegationStruct to a Delegation.\n * The Delegation type is used for off-chain operations and has a hex string salt.\n * @param delegationStruct - The delegation struct to convert\n * @returns The converted delegation with a hex string salt\n */\n\nexport const toDelegation = (\n  delegationStruct: DelegationStruct,\n): Delegation => {\n  return {\n    ...delegationStruct,\n    salt: toHex(delegationStruct.salt),\n  };\n};\n\n/**\n * Represents a DelegationStruct as defined in the Delegation Framework.\n * This is distinguished from the Delegation type by requiring the salt to be a bigint\n * instead of a Hex string, which is useful for on-chain operations and EIP-712 signing.\n */\nexport type DelegationStruct = Omit<Delegation, 'salt'> & {\n  salt: bigint;\n};\n\n/**\n * ABI Encodes an array of delegations.\n * @param delegations - The delegations to encode.\n * @returns The encoded delegations.\n */\nexport const encodeDelegations = (delegations: Delegation[]): Hex => {\n  const delegationStructs = delegations.map(toDelegationStruct);\n\n  return encodeDelegationsCore(delegationStructs);\n};\n\n/**\n * Abi encodes permission contexts.\n * @param delegations - The delegation chains to encode.\n * @returns The encoded permission contexts.\n */\nexport const encodePermissionContexts = (delegations: Delegation[][]) => {\n  const encodedDelegations = delegations.map((delegationChain) =>\n    encodeDelegations(delegationChain),\n  );\n\n  return encodedDelegations;\n};\n\n/**\n * Decodes an array of delegations from its ABI-encoded representation.\n * @param encoded - The hex-encoded delegation array to decode.\n * @returns An array of decoded delegations.\n */\nexport const decodeDelegations = (encoded: Hex): Delegation[] => {\n  // decodeDelegationsCore returns DelegationStruct, so we need to map it back to Delegation\n  return decodeDelegationsCore(encoded).map(toDelegation);\n};\n\n/**\n * Decodes an array of encoded permission contexts into an array of delegation chains.\n * @param encoded - The hex-encoded permission context to decode.\n * @returns An array of decoded delegations.\n */\nexport const decodePermissionContexts = (encoded: Hex[]): Delegation[][] => {\n  const delegationChains = encoded.map(decodeDelegations);\n\n  return delegationChains;\n};\n\n/**\n * TypedData to be used when signing a Delegation. Delegation value for `signature` and Caveat values for `args` are omitted as they cannot be known at signing time.\n */\nexport const SIGNABLE_DELEGATION_TYPED_DATA: TypedData = {\n  Caveat: [\n    { name: 'enforcer', type: 'address' },\n    { name: 'terms', type: 'bytes' },\n  ],\n  Delegation: [\n    { name: 'delegate', type: 'address' },\n    { name: 'delegator', type: 'address' },\n    { name: 'authority', type: 'bytes32' },\n    { name: 'caveats', type: 'Caveat[]' },\n    { name: 'salt', type: 'uint256' },\n  ],\n} as const;\n\n/**\n * The ABI type for a full delegation.\n */\nexport const DELEGATION_ARRAY_ABI_TYPE: AbiParameter = {\n  type: 'tuple[]',\n  components: DELEGATION_ABI_TYPE_COMPONENTS,\n} as const;\n\n/**\n * Prepares a delegation hash for passkey signing.\n * @param delegationHash - The delegation hash to prepare.\n * @returns The prepared hash for passkey signing.\n */\nexport const prepDelegationHashForPasskeySign = (delegationHash: Hex) => {\n  return hashMessage({\n    raw: toBytes(delegationHash),\n  });\n};\n\n/**\n * Gets a delegation hash offchain.\n * @param input - The delegation to get the hash for.\n * @returns The hash of the delegation parameters.\n */\nexport const getDelegationHashOffchain = (input: Delegation): Hex => {\n  const delegationStruct = toDelegationStruct(input);\n\n  return hashDelegation(delegationStruct);\n};\n\ntype BaseCreateDelegationOptions = {\n  environment: DeleGatorEnvironment;\n  scope: ScopeConfig;\n  from: Hex;\n  caveats?: Caveats;\n  parentDelegation?: Delegation | Hex;\n  salt?: Hex;\n};\n\n/**\n * Options for creating a specific delegation\n */\nexport type CreateDelegationOptions = BaseCreateDelegationOptions & {\n  to: Hex;\n};\n\n/**\n * Options for creating an open delegation\n */\nexport type CreateOpenDelegationOptions = BaseCreateDelegationOptions;\n\n/**\n * Resolves the authority for a delegation based on the parent delegation.\n * @param parentDelegation - The parent delegation or its hash.\n * @returns The resolved authority hash.\n */\nexport const resolveAuthority = (parentDelegation?: Delegation | Hex): Hex => {\n  if (!parentDelegation) {\n    return ROOT_AUTHORITY;\n  }\n\n  if (typeof parentDelegation === 'string') {\n    return parentDelegation;\n  }\n\n  return getDelegationHashOffchain(parentDelegation);\n};\n\n/**\n * Creates a delegation with specific delegate.\n * @param options - The options for creating the delegation.\n * @returns The created delegation data structure.\n */\nexport const createDelegation = (\n  options: CreateDelegationOptions,\n): Delegation => {\n  return {\n    delegate: options.to,\n    delegator: options.from,\n    authority: resolveAuthority(options.parentDelegation),\n    caveats: resolveCaveats(options),\n    salt: options.salt ?? '0x',\n    signature: '0x',\n  };\n};\n\n/**\n * Creates an open delegation that can be redeemed by any delegate.\n * @param options - The options for creating the open delegation.\n * @returns The created delegation data structure.\n */\nexport const createOpenDelegation = (\n  options: CreateOpenDelegationOptions,\n): Delegation => {\n  return {\n    delegate: ANY_BENEFICIARY,\n    delegator: options.from,\n    authority: resolveAuthority(options.parentDelegation),\n    caveats: resolveCaveats(options),\n    salt: options.salt ?? '0x',\n    signature: '0x',\n  };\n};\n\n/**\n * Prepares typed data for delegation signing (internal helper function).\n * @param params - The parameters for preparing the typed data.\n * @param params.delegation - The delegation to prepare for signing.\n * @param params.delegationManager - The address of the delegation manager contract.\n * @param params.chainId - The chain ID for the signature.\n * @param params.name - The name of the contract.\n * @param params.version - The version of the contract.\n * @param params.allowInsecureUnrestrictedDelegation - Whether to allow insecure unrestricted delegation.\n * @returns The typed data parameters ready for signing.\n * @internal\n */\nexport const prepareSignDelegationTypedData = ({\n  delegation,\n  delegationManager,\n  chainId,\n  name = 'DelegationManager',\n  version = '1',\n  allowInsecureUnrestrictedDelegation = false,\n}: {\n  delegation: Omit<Delegation, 'signature'>;\n  delegationManager: Address;\n  chainId: number;\n  name?: string;\n  version?: string;\n  allowInsecureUnrestrictedDelegation?: boolean;\n}) => {\n  const delegationStruct = toDelegationStruct({\n    ...delegation,\n    signature: '0x',\n  });\n\n  if (\n    delegationStruct.caveats.length === 0 &&\n    !allowInsecureUnrestrictedDelegation\n  ) {\n    throw new Error(\n      'No caveats found. If you definitely want to sign a delegation without caveats, set `allowInsecureUnrestrictedDelegation` to `true`.',\n    );\n  }\n\n  return {\n    domain: {\n      chainId,\n      name,\n      version,\n      verifyingContract: delegationManager,\n    },\n    types: SIGNABLE_DELEGATION_TYPED_DATA,\n    primaryType: 'Delegation' as const,\n    message: delegationStruct,\n  };\n};\n\n/**\n * Signs a delegation using a private key.\n * @param params - The parameters for signing the delegation.\n * @param params.privateKey - The private key to use for signing.\n * @param params.delegation - The delegation to sign.\n * @param params.delegationManager - The address of the delegation manager contract.\n * @param params.chainId - The chain ID for the signature.\n * @param params.name - The name of the contract.\n * @param params.version - The version of the contract.\n * @param params.allowInsecureUnrestrictedDelegation - Whether to allow insecure unrestricted delegation.\n * @returns The signed delegation.\n */\nexport const signDelegation = async ({\n  privateKey,\n  delegation,\n  delegationManager,\n  chainId,\n  name = 'DelegationManager',\n  version = '1',\n  allowInsecureUnrestrictedDelegation = false,\n}: {\n  privateKey: Hex;\n  delegation: Omit<Delegation, 'signature'>;\n  delegationManager: Address;\n  chainId: number;\n  name?: string;\n  version?: string;\n  allowInsecureUnrestrictedDelegation?: boolean;\n}) => {\n  const typedData = prepareSignDelegationTypedData({\n    delegation,\n    delegationManager,\n    chainId,\n    name,\n    version,\n    allowInsecureUnrestrictedDelegation,\n  });\n\n  return signTypedData({\n    privateKey,\n    ...typedData,\n  });\n};\n"],"mappings":"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","names":["BalanceChangeType","isHex","concat","concat","isHex","concat","toHex","concat","isAddress","isHex","isAddress","isAddress","isAddress","encodePacked","isAddress","encodePacked","concat","isAddress","toHex","isAddress","encodePacked","isAddress","encodePacked","isAddress","toHex","concat","isAddress","encodeAbiParameters","isAddress","isAddress","concat","toHex","toHex","toHex","pad","concat","isAddress","pad","toHex","isAddress","encodePacked","isAddress","encodePacked","encodePacked","isAddress","encodePacked","isAddress","concat","isAddress","concat","isAddress","toHex","isHex","toHex","allowedCalldata","exactCalldata","allowedCalldata","exactCalldata","allowedCalldata","exactCalldata","allowedCalldata","exactCalldata","encodePacked","encodeAbiParameters","toHex","CAVEAT_TYPEHASH","toHex","toHex"]}