{"version":3,"sources":["/home/runner/work/delegation-toolkit/delegation-toolkit/packages/delegation-toolkit/dist/index.cjs","../src/toMetaMaskSmartAccount.ts","../src/signer.ts","../src/signatures.ts","../src/actions/caveatEnforcerClient.ts","../src/actions/infuraBundlerClient.ts"],"names":["signTypedData","signMessage","getStubSignature","signUserOperation","signDelegation"],"mappings":"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","file":"/home/runner/work/delegation-toolkit/delegation-toolkit/packages/delegation-toolkit/dist/index.cjs","sourcesContent":[null,"import {\n  EIP7702StatelessDeleGator,\n  HybridDeleGator,\n  MultiSigDeleGator,\n} from '@metamask/delegation-abis';\nimport { type Address, type Hex } from 'viem';\nimport {\n  entryPoint07Abi,\n  toPackedUserOperation,\n  toSmartAccount,\n} from 'viem/account-abstraction';\n\nimport { isValid7702Implementation } from './actions/isValid7702Implementation';\nimport { Implementation } from './constants';\nimport { getCounterfactualAccountData } from './counterfactualAccountData';\nimport {\n  SIGNABLE_DELEGATION_TYPED_DATA,\n  toDelegationStruct,\n} from './delegation';\nimport { entryPointGetNonce as _getNonce } from './DelegationFramework/EntryPoint/read';\nimport { getDeleGatorEnvironment } from './delegatorEnvironment';\nimport { encodeCallsForCaller } from './encodeCalls';\nimport { resolveSigner } from './signer';\nimport type {\n  Call,\n  ToMetaMaskSmartAccountParameters,\n  ToMetaMaskSmartAccountReturnType,\n  SignDelegationParams,\n  SignUserOperationParams,\n  AbiByImplementation,\n} from './types';\nimport { SIGNABLE_USER_OP_TYPED_DATA } from './userOp';\n\nconst ENTRYPOINT_VERSION = '0.7' as const;\n\n/**\n * Creates a MetaMask DeleGator smart account instance.\n *\n * @template TImplementation - The type of implementation, extending Implementation.\n * @param params - The parameters for creating the smart account.\n * @returns A promise that resolves to a MetaMask DeleGator smart account instance.\n * @description\n * This function sets up a MetaMask DeleGator smart account with the specified implementation.\n * It handles both deployed accounts, and counterfactual accounts.\n * A caller may specify a DeleGator environment, otherwise the environment will be inferred from the chain.\n */\nexport async function toMetaMaskSmartAccount<\n  TImplementation extends Implementation,\n>(\n  params: ToMetaMaskSmartAccountParameters<TImplementation>,\n): Promise<ToMetaMaskSmartAccountReturnType<TImplementation>> {\n  const {\n    client,\n    client: { chain },\n    implementation,\n  } = params;\n\n  if (!chain) {\n    throw new Error('Chain not specified');\n  }\n\n  const signer = resolveSigner({\n    implementation,\n    signer: params.signer,\n  });\n\n  const environment = params.environment ?? getDeleGatorEnvironment(chain.id);\n\n  let address: Address, factoryData: Hex | undefined;\n\n  if (params.address) {\n    factoryData = undefined;\n    address = params.address;\n  } else {\n    if (implementation === Implementation.Stateless7702) {\n      throw new Error('Stateless7702 does not support counterfactual accounts');\n    }\n\n    const accountData = await getCounterfactualAccountData({\n      factory: environment.SimpleFactory,\n      implementations: environment.implementations,\n      implementation,\n      deployParams: params.deployParams,\n      deploySalt: params.deploySalt,\n    });\n\n    address = accountData.address;\n    factoryData = accountData.factoryData;\n  }\n\n  const entryPoint = {\n    abi: entryPoint07Abi,\n    address: environment.EntryPoint,\n    version: ENTRYPOINT_VERSION,\n  } as const;\n\n  const { abi, contractName } = {\n    [Implementation.Hybrid]: {\n      contractName: 'HybridDeleGator',\n      abi: HybridDeleGator.abi,\n    },\n    [Implementation.MultiSig]: {\n      contractName: 'MultiSigDeleGator',\n      abi: MultiSigDeleGator.abi,\n    },\n    [Implementation.Stateless7702]: {\n      contractName: 'EIP7702StatelessDeleGator',\n      abi: EIP7702StatelessDeleGator.abi,\n    },\n  }[implementation] as {\n    contractName: string;\n    abi: AbiByImplementation[TImplementation];\n  };\n\n  const getFactoryArgs = async () => {\n    if (factoryData === undefined) {\n      throw new Error(\n        'Deploy params were not provided, so factory args cannot be inferred',\n      );\n    }\n    return {\n      factoryData,\n      factory: environment.SimpleFactory,\n    };\n  };\n\n  const signDelegation = async (delegationParams: SignDelegationParams) => {\n    const { delegation, chainId } = delegationParams;\n\n    const delegationStruct = toDelegationStruct({\n      ...delegation,\n      signature: '0x',\n    });\n\n    const signature = signer.signTypedData({\n      domain: {\n        chainId: chainId ?? chain.id,\n        name: 'DelegationManager',\n        version: '1',\n        verifyingContract: environment.DelegationManager,\n      },\n      types: SIGNABLE_DELEGATION_TYPED_DATA,\n      primaryType: 'Delegation',\n      message: delegationStruct,\n    });\n\n    return signature;\n  };\n\n  const signUserOperation = async (userOpParams: SignUserOperationParams) => {\n    const { chainId } = userOpParams;\n\n    const packedUserOp = toPackedUserOperation({\n      sender: address,\n      ...userOpParams,\n      signature: '0x',\n    });\n\n    const signature = await signer.signTypedData({\n      domain: {\n        chainId: chainId ?? chain.id,\n        name: contractName,\n        version: '1',\n        verifyingContract: address,\n      },\n      types: SIGNABLE_USER_OP_TYPED_DATA,\n      primaryType: 'PackedUserOperation',\n      message: { ...packedUserOp, entryPoint: entryPoint.address },\n    });\n\n    return signature;\n  };\n\n  const getAddress = async () => address;\n\n  const getNonce = async () =>\n    _getNonce({\n      client,\n      entryPoint: environment.EntryPoint,\n      contractAddress: address,\n      key: 0n,\n    });\n\n  const encodeCalls = async (calls: readonly Call[]) =>\n    encodeCallsForCaller(address, calls);\n\n  const smartAccount = await toSmartAccount({\n    abi,\n    client,\n    entryPoint,\n    environment,\n    getAddress,\n    getFactoryArgs,\n    encodeCalls,\n    getNonce,\n    signUserOperation,\n    signDelegation,\n    ...signer,\n  });\n\n  // Override isDeployed only for EIP-7702 implementation to check proper delegation code\n  if (implementation === Implementation.Stateless7702) {\n    return {\n      ...smartAccount,\n      isDeployed: async () =>\n        isValid7702Implementation({\n          client,\n          accountAddress: address,\n          environment,\n        }),\n    };\n  }\n\n  // For other implementations, use the default isDeployed behavior\n  return smartAccount;\n}\n","import { concat } from 'viem';\nimport type {\n  Address,\n  SignableMessage,\n  TypedData,\n  TypedDataDefinition,\n} from 'viem';\nimport type { SignReturnType as WebAuthnSignReturnType } from 'webauthn-p256';\n\nimport { Implementation } from './constants';\nimport { aggregateSignature } from './signatures';\nimport type {\n  AccountSignerConfig,\n  HybridSignerConfig,\n  InternalSigner,\n  MultiSigSignerConfig,\n  SignerConfigByImplementation,\n  Stateless7702SignerConfig,\n  WalletSignerConfig,\n} from './types';\nimport {\n  createDummyWebAuthnSignature,\n  encodeDeleGatorSignature,\n} from './webAuthn';\n\n// A valid ECDSA signature, this must be able to ecrecover an address, otherwise the contracts will revert in isValidSignature\nconst EOA_STUB_SIGNATURE =\n  '0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000011b' as const;\n\nconst resolveSignerFromWalletConfig = (\n  config: WalletSignerConfig,\n): InternalSigner => {\n  return {\n    signMessage: config.walletClient.signMessage,\n    signTypedData: async (typedData) => {\n      // todo: figure out this type so that we don't need the type assertion\n      return config.walletClient.signTypedData(typedData as any);\n    },\n    getStubSignature: async () => EOA_STUB_SIGNATURE,\n  };\n};\n\nconst resolveSignerFromAccountConfig = (config: AccountSignerConfig) => {\n  return {\n    signMessage: config.account.signMessage,\n    signTypedData: config.account.signTypedData,\n    getStubSignature: async () => EOA_STUB_SIGNATURE,\n  };\n};\n\nconst resolveHybridSigner = (config: HybridSignerConfig): InternalSigner => {\n  if ('walletClient' in config) {\n    return resolveSignerFromWalletConfig(config);\n  } else if ('account' in config) {\n    const { signMessage, signTypedData, getStubSignature } =\n      resolveSignerFromAccountConfig(config);\n    if (!signMessage) {\n      throw new Error('Account does not support signMessage');\n    }\n    if (!signTypedData) {\n      throw new Error('Account does not support signTypedData');\n    }\n    return {\n      signMessage,\n      signTypedData,\n      getStubSignature,\n    };\n  }\n  const { keyId, webAuthnAccount } = config;\n\n  if (webAuthnAccount.type !== 'webAuthn') {\n    throw new Error('Account is not a webAuthn account');\n  }\n\n  const encodeSignature = ({ signature, webauthn }: WebAuthnSignReturnType) =>\n    encodeDeleGatorSignature(\n      keyId,\n      signature,\n      webauthn.clientDataJSON,\n      webauthn.authenticatorData,\n    );\n\n  const signMessage = async (args: { message: SignableMessage }) =>\n    webAuthnAccount.signMessage(args).then(encodeSignature);\n  const signTypedData = async <\n    const TTypedData extends TypedData | Record<string, unknown>,\n    TPrimaryType extends keyof TTypedData | 'EIP712Domain' = keyof TTypedData,\n  >(\n    typedDataDefinition: TypedDataDefinition<TTypedData, TPrimaryType>,\n  ) => webAuthnAccount.signTypedData(typedDataDefinition).then(encodeSignature);\n\n  const getStubSignature = async () => createDummyWebAuthnSignature(keyId);\n\n  return {\n    signMessage,\n    signTypedData,\n    getStubSignature,\n  };\n};\n\nconst resolveMultiSigSigner = (\n  config: MultiSigSignerConfig,\n): InternalSigner => {\n  const resolvedSigners = config.map((signer) => {\n    let individualSignMessage: InternalSigner['signMessage'];\n    let individualSignTypedData: InternalSigner['signTypedData'];\n    let address: Address;\n    if ('walletClient' in signer) {\n      const { signMessage, signTypedData } =\n        resolveSignerFromWalletConfig(signer);\n      individualSignMessage = signMessage;\n      individualSignTypedData = signTypedData;\n\n      address = signer.walletClient.account.address;\n    } else {\n      const { signMessage, signTypedData } =\n        resolveSignerFromAccountConfig(signer);\n      if (!signMessage) {\n        throw new Error('Account does not support signMessage');\n      }\n      if (!signTypedData) {\n        throw new Error('Account does not support signTypedData');\n      }\n\n      individualSignMessage = signMessage;\n      individualSignTypedData = signTypedData;\n\n      address = signer.account.address;\n    }\n    return {\n      address,\n      individualSignMessage,\n      individualSignTypedData,\n    };\n  });\n\n  const signMessage = async (args: { message: SignableMessage }) => {\n    const addressAndSignatures = resolvedSigners.map(\n      async ({ individualSignMessage, address }) => ({\n        signature: await individualSignMessage(args),\n        signer: address,\n        type: 'ECDSA' as const,\n      }),\n    );\n\n    const signatures = await Promise.all(addressAndSignatures);\n\n    return aggregateSignature({\n      signatures,\n    });\n  };\n\n  const signTypedData = async <\n    const TTypedData extends TypedData | Record<string, unknown>,\n    TPrimaryType extends keyof TTypedData | 'EIP712Domain' = keyof TTypedData,\n  >(\n    typedDataDefinition: TypedDataDefinition<TTypedData, TPrimaryType>,\n  ) => {\n    const addressAndSignatures = resolvedSigners.map(\n      async ({ individualSignTypedData, address }) => ({\n        signature: await individualSignTypedData(typedDataDefinition),\n        signer: address,\n        type: 'ECDSA' as const,\n      }),\n    );\n\n    const signatures = await Promise.all(addressAndSignatures);\n\n    return aggregateSignature({\n      signatures,\n    });\n  };\n\n  const getStubSignature = async () =>\n    concat(resolvedSigners.map(() => EOA_STUB_SIGNATURE));\n\n  return {\n    signMessage,\n    signTypedData,\n    getStubSignature,\n  };\n};\n\nconst resolveStateless7702Signer = (\n  config: Stateless7702SignerConfig,\n): InternalSigner => {\n  if ('walletClient' in config) {\n    return resolveSignerFromWalletConfig(config);\n  } else if ('account' in config) {\n    const { signMessage, signTypedData, getStubSignature } =\n      resolveSignerFromAccountConfig(config);\n    if (!signMessage) {\n      throw new Error('Account does not support signMessage');\n    }\n    if (!signTypedData) {\n      throw new Error('Account does not support signTypedData');\n    }\n\n    return {\n      signMessage,\n      signTypedData,\n      getStubSignature,\n    };\n  }\n\n  throw new Error('Invalid signer config');\n};\n\nexport const resolveSigner = <TImplementation extends Implementation>(config: {\n  implementation: TImplementation;\n  signer: SignerConfigByImplementation<TImplementation>;\n}): InternalSigner => {\n  const { implementation } = config;\n\n  if (implementation === Implementation.Hybrid) {\n    return resolveHybridSigner(config.signer as HybridSignerConfig);\n  } else if (implementation === Implementation.MultiSig) {\n    return resolveMultiSigSigner(config.signer as MultiSigSignerConfig);\n  } else if (implementation === Implementation.Stateless7702) {\n    return resolveStateless7702Signer(\n      config.signer as Stateless7702SignerConfig,\n    );\n  }\n  throw new Error(`Implementation type '${implementation}' not supported`);\n};\n","import type { Address, Hex } from 'viem';\nimport { concat } from 'viem';\n\nconst signatureTypes = ['ECDSA'] as const;\n\nexport type SignatureType = (typeof signatureTypes)[number];\n\n/**\n * Represents a partial signature that can be aggregated with others.\n */\nexport type PartialSignature = {\n  signer: Address;\n  signature: Hex;\n  type: SignatureType;\n};\n\n/**\n * Aggregates signatures into a single signature as expected by the MultiSig implementation.\n * @param params - The parameters for signature aggregation.\n * @param params.signatures - The array of partial signatures to aggregate.\n * @returns The aggregated signature.\n */\nexport const aggregateSignature = ({\n  signatures,\n}: {\n  signatures: PartialSignature[];\n}): Hex => {\n  if (signatures.length === 0) {\n    return '0x';\n  }\n\n  for (const { type } of signatures) {\n    if (!signatureTypes.includes(type)) {\n      throw new Error(`Invalid signature type: ${type}`);\n    }\n  }\n\n  // Sort signatures by signer address as required by MultiSig implementation\n  const sortedSignatures = [...signatures].sort((a, b) =>\n    a.signer.localeCompare(b.signer),\n  );\n\n  // Concatenate all signatures\n  return concat(sortedSignatures.map(({ signature }) => signature));\n};\n\n/**\n * Type definition for the aggregateSignature function parameters.\n */\nexport type AggregateSignatureParams = {\n  signatures: PartialSignature[];\n};\n","import type { Client, Transport, Chain, Account } from 'viem';\n\nimport type { DeleGatorEnvironment } from '../types';\nimport {\n  caveatEnforcerActions,\n  type CaveatEnforcerParams,\n  type PeriodTransferResult,\n  type StreamingResult,\n} from './getCaveatAvailableAmount';\n\n/**\n * Type for client extended with caveat enforcer actions.\n */\nexport type CaveatEnforcerClient<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n> = Client<TTransport, TChain, TAccount> &\n  ReturnType<ReturnType<typeof caveatEnforcerActions>>;\n\n/**\n * Create a viem client extended with caveat enforcer actions.\n *\n * @param params - The parameters object.\n * @param params.client - The viem client.\n * @param params.environment - The delegator environment.\n * @returns The extended client with caveat enforcer actions.\n */\nexport function createCaveatEnforcerClient<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n>({\n  client,\n  environment,\n}: {\n  client: Client<TTransport, TChain, TAccount>;\n  environment: DeleGatorEnvironment;\n}): CaveatEnforcerClient<TTransport, TChain, TAccount> {\n  return client.extend(caveatEnforcerActions({ environment }));\n}\n\n// Re-export types for convenience\nexport type { CaveatEnforcerParams, PeriodTransferResult, StreamingResult };\n","import type { Transport, Chain, Hex, Client, Account } from 'viem';\nimport {\n  createBundlerClient,\n  type BundlerClient,\n  type BundlerClientConfig,\n  type SmartAccount,\n} from 'viem/account-abstraction';\n\n/**\n * Gas price tiers returned by pimlico_getUserOperationGasPrice\n */\nexport type GasPriceTier = {\n  /** Maximum fee per gas in hex format */\n  maxFeePerGas: Hex;\n  /** Maximum priority fee per gas in hex format */\n  maxPriorityFeePerGas: Hex;\n};\n\n/**\n * Response from pimlico_getUserOperationGasPrice RPC method\n */\nexport type UserOperationGasPriceResponse = {\n  /** Slow gas price tier */\n  slow: GasPriceTier;\n  /** Standard gas price tier */\n  standard: GasPriceTier;\n  /** Fast gas price tier */\n  fast: GasPriceTier;\n};\n\n/**\n * Pimlico bundler schema for type-safe RPC method calls\n */\n/* eslint-disable @typescript-eslint/naming-convention */\ntype PimlicoBundlerSchema = [\n  {\n    Method: 'pimlico_getUserOperationGasPrice';\n    Parameters: [];\n    ReturnType: UserOperationGasPriceResponse;\n  },\n];\n\n/**\n * Infura bundler actions for extending bundler clients.\n *\n * @returns A function that takes a client and returns the client extension with Infura bundler actions.\n */\nconst infuraBundlerActions = () => (client: Client) => ({\n  /**\n   * Get user operation gas prices from Infura bundler.\n   * Calls the pimlico_getUserOperationGasPrice RPC method.\n   *\n   * @returns Promise resolving to gas price tiers (slow, standard, fast).\n   * @example\n   * ```typescript\n   * const gasPrices = await bundlerClient.getUserOperationGasPrice();\n   * console.log(gasPrices.standard.maxFeePerGas);\n   * ```\n   */\n  async getUserOperationGasPrice(): Promise<UserOperationGasPriceResponse> {\n    const pimlicoClient = client as Client<\n      Transport,\n      Chain | undefined,\n      Account | undefined,\n      PimlicoBundlerSchema\n    >;\n\n    return await pimlicoClient.request({\n      method: 'pimlico_getUserOperationGasPrice',\n      params: [],\n    });\n  },\n});\n\n/**\n * Type for bundler client extended with Infura bundler actions.\n */\nexport type InfuraBundlerClient<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends SmartAccount | undefined = SmartAccount | undefined,\n> = BundlerClient<TTransport, TChain, TAccount> & {\n  /**\n   * Get user operation gas prices from Infura bundler.\n   * Calls the pimlico_getUserOperationGasPrice RPC method.\n   *\n   * @returns Promise resolving to gas price tiers (slow, standard, fast).\n   */\n  getUserOperationGasPrice(): Promise<UserOperationGasPriceResponse>;\n};\n\n/**\n * Creates an Infura bundler client extended with Infura bundler actions.\n *\n * This is a wrapper around viem's createBundlerClient that extends it with\n * the getUserOperationGasPrice method for retrieving gas prices from Pimlico's\n * bundler infrastructure via Infura's proxy.\n *\n * @param config - Configuration for the bundler client.\n * @returns Extended bundler client with Infura bundler actions.\n * @example\n * ```typescript\n * import { createPublicClient, http } from 'viem';\n * import { sepolia } from 'viem/chains';\n * import { createInfuraBundlerClient } from '@metamask/delegation-toolkit';\n *\n * const publicClient = createPublicClient({\n *   chain: sepolia,\n *   transport: http('https://sepolia.infura.io/v3/YOUR_API_KEY'),\n * });\n *\n * const bundlerClient = createInfuraBundlerClient({\n *   client: publicClient,\n *   transport: http('https://sepolia.infura.io/v3/YOUR_API_KEY'),\n *   chain: sepolia,\n * });\n *\n * // Use standard bundler methods\n * const userOpHash = await bundlerClient.sendUserOperation({...});\n *\n * // Use Infura specific methods\n * const gasPrices = await bundlerClient.getUserOperationGasPrice();\n * ```\n */\nexport function createInfuraBundlerClient<\n  TTransport extends Transport,\n  TChain extends Chain | undefined = undefined,\n  TAccount extends SmartAccount | undefined = undefined,\n>(\n  config: BundlerClientConfig<TTransport, TChain, TAccount>,\n): InfuraBundlerClient<TTransport, TChain, TAccount> {\n  // Create the base bundler client using viem's function\n  const baseBundlerClient = createBundlerClient(config);\n\n  // Extend the client with Infura bundler actions\n  return baseBundlerClient.extend(\n    infuraBundlerActions(),\n  ) as unknown as InfuraBundlerClient<TTransport, TChain, TAccount>;\n}\n"]}