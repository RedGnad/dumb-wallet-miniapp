{"version":3,"sources":["/home/runner/work/delegation-toolkit/delegation-toolkit/packages/delegation-toolkit/dist/chunk-JN5LSN7D.cjs","../src/DelegationFramework/ERC20PeriodTransferEnforcer/index.ts","../src/DelegationFramework/ERC20PeriodTransferEnforcer/read.ts","../src/DelegationFramework/ERC20PeriodTransferEnforcer/methods/getAvailableAmount.ts","../src/DelegationFramework/ERC20StreamingEnforcer/index.ts","../src/DelegationFramework/ERC20StreamingEnforcer/read.ts","../src/DelegationFramework/ERC20StreamingEnforcer/methods/getAvailableAmount.ts","../src/DelegationFramework/MultiTokenPeriodEnforcer/index.ts","../src/DelegationFramework/MultiTokenPeriodEnforcer/read.ts","../src/DelegationFramework/MultiTokenPeriodEnforcer/methods/getAvailableAmount.ts","../src/DelegationFramework/NativeTokenPeriodTransferEnforcer/index.ts","../src/DelegationFramework/NativeTokenPeriodTransferEnforcer/read.ts","../src/DelegationFramework/NativeTokenPeriodTransferEnforcer/methods/getAvailableAmount.ts","../src/DelegationFramework/NativeTokenStreamingEnforcer/index.ts","../src/DelegationFramework/NativeTokenStreamingEnforcer/read.ts","../src/DelegationFramework/NativeTokenStreamingEnforcer/methods/getAvailableAmount.ts"],"names":["read_exports","read","readContract","availableAmount","getBlock","getAvailableAmount"],"mappings":"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","file":"/home/runner/work/delegation-toolkit/delegation-toolkit/packages/delegation-toolkit/dist/chunk-JN5LSN7D.cjs","sourcesContent":[null,"import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { ERC20PeriodTransferEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationHash: Hex;\n  delegationManager: Address;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationHash,\n  delegationManager,\n  terms,\n}: ReadGetAvailableAmountParameters) => {\n  const [availableAmount, isNewPeriod, currentPeriod] = await readContract(\n    client,\n    {\n      address: contractAddress,\n      abi: ERC20PeriodTransferEnforcer.abi,\n      functionName: 'getAvailableAmount',\n      args: [delegationHash, delegationManager, terms],\n    },\n  );\n\n  return {\n    availableAmount,\n    isNewPeriod,\n    currentPeriod,\n  };\n};\n","import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { ERC20StreamingEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract, getBlock } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationManager: Address;\n  delegationHash: Hex;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationManager,\n  delegationHash,\n  terms,\n}: ReadGetAvailableAmountParameters) => {\n  // Get current block timestamp from blockchain\n  const currentBlock = await getBlock(client);\n  const currentTimestamp = currentBlock.timestamp;\n\n  // First, get the current state from the contract\n  const allowanceState = await readContract(client, {\n    address: contractAddress,\n    abi: ERC20StreamingEnforcer.abi,\n    functionName: 'streamingAllowances',\n    args: [delegationManager, delegationHash],\n  });\n\n  const [initialAmount, maxAmount, amountPerSecond, startTime, spent] =\n    allowanceState;\n\n  // Check if state exists (startTime != 0)\n  if (startTime !== 0n) {\n    // State exists, calculate available amount using the stored state\n    const availableAmount = getAvailableAmount({\n      initialAmount,\n      maxAmount,\n      amountPerSecond,\n      startTime,\n      spent,\n      currentTimestamp,\n    });\n\n    return {\n      availableAmount,\n    };\n  }\n\n  // State doesn't exist, decode terms and simulate with spent = 0\n  const decodedTerms = await readContract(client, {\n    address: contractAddress,\n    abi: ERC20StreamingEnforcer.abi,\n    functionName: 'getTermsInfo',\n    args: [terms],\n  });\n\n  const [\n    ,\n    decodedInitialAmount,\n    decodedMaxAmount,\n    decodedAmountPerSecond,\n    decodedStartTime,\n  ] = decodedTerms;\n\n  // Simulate using decoded terms with spent = 0\n  const availableAmount = getAvailableAmount({\n    initialAmount: decodedInitialAmount,\n    maxAmount: decodedMaxAmount,\n    amountPerSecond: decodedAmountPerSecond,\n    startTime: decodedStartTime,\n    spent: 0n,\n    currentTimestamp,\n  });\n\n  return {\n    availableAmount,\n  };\n};\n\n/**\n * Replicates the internal _getAvailableAmount logic from the smart contract.\n *\n * @param allowance - The allowance object containing all parameters.\n * @param allowance.initialAmount - The initial amount available.\n * @param allowance.maxAmount - The maximum amount allowed.\n * @param allowance.amountPerSecond - The amount streamed per second.\n * @param allowance.startTime - The start time of the streaming.\n * @param allowance.spent - The amount already spent.\n * @param allowance.currentTimestamp - The current timestamp.\n * @returns The available amount that can be spent.\n */\nfunction getAvailableAmount(allowance: {\n  initialAmount: bigint;\n  maxAmount: bigint;\n  amountPerSecond: bigint;\n  startTime: bigint;\n  spent: bigint;\n  currentTimestamp: bigint;\n}): bigint {\n  // If current time is before start time, nothing is available\n  if (allowance.currentTimestamp < allowance.startTime) {\n    return 0n;\n  }\n\n  // Calculate elapsed time since start\n  const elapsed = allowance.currentTimestamp - allowance.startTime;\n\n  // Calculate total unlocked amount\n  let unlocked = allowance.initialAmount + allowance.amountPerSecond * elapsed;\n\n  // Cap by max amount\n  if (unlocked > allowance.maxAmount) {\n    unlocked = allowance.maxAmount;\n  }\n\n  // If spent >= unlocked, nothing available\n  if (allowance.spent >= unlocked) {\n    return 0n;\n  }\n\n  // Return available amount\n  return unlocked - allowance.spent;\n}\n","import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { MultiTokenPeriodEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationHash: Hex;\n  delegationManager: Address;\n  terms: Hex;\n  args: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationHash,\n  delegationManager,\n  terms,\n  args,\n}: ReadGetAvailableAmountParameters) => {\n  const [availableAmount, isNewPeriod, currentPeriod] = await readContract(\n    client,\n    {\n      address: contractAddress,\n      abi: MultiTokenPeriodEnforcer.abi,\n      functionName: 'getAvailableAmount',\n      args: [delegationHash, delegationManager, terms, args],\n    },\n  );\n\n  return {\n    availableAmount,\n    isNewPeriod,\n    currentPeriod,\n  };\n};\n","import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { NativeTokenPeriodTransferEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationHash: Hex;\n  delegationManager: Address;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationHash,\n  delegationManager,\n  terms,\n}: ReadGetAvailableAmountParameters) => {\n  const [availableAmount, isNewPeriod, currentPeriod] = await readContract(\n    client,\n    {\n      address: contractAddress,\n      abi: NativeTokenPeriodTransferEnforcer.abi,\n      functionName: 'getAvailableAmount',\n      args: [delegationHash, delegationManager, terms],\n    },\n  );\n\n  return {\n    availableAmount,\n    isNewPeriod,\n    currentPeriod,\n  };\n};\n","import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { NativeTokenStreamingEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract, getBlock } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationManager: Address;\n  delegationHash: Hex;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationManager,\n  delegationHash,\n  terms,\n}: ReadGetAvailableAmountParameters) => {\n  // Get current block timestamp from blockchain\n  const currentBlock = await getBlock(client);\n  const currentTimestamp = currentBlock.timestamp;\n\n  // First, get the current state from the contract\n  const allowanceState = await readContract(client, {\n    address: contractAddress,\n    abi: NativeTokenStreamingEnforcer.abi,\n    functionName: 'streamingAllowances',\n    args: [delegationManager, delegationHash],\n  });\n\n  const [initialAmount, maxAmount, amountPerSecond, startTime, spent] =\n    allowanceState;\n\n  // Check if state exists (startTime != 0)\n  if (startTime !== 0n) {\n    // State exists, calculate available amount using the stored state\n    const availableAmount = getAvailableAmount({\n      initialAmount,\n      maxAmount,\n      amountPerSecond,\n      startTime,\n      spent,\n      currentTimestamp,\n    });\n\n    return {\n      availableAmount,\n    };\n  }\n\n  // State doesn't exist, decode terms and simulate with spent = 0\n  const decodedTerms = await readContract(client, {\n    address: contractAddress,\n    abi: NativeTokenStreamingEnforcer.abi,\n    functionName: 'getTermsInfo',\n    args: [terms],\n  });\n\n  const [\n    decodedInitialAmount,\n    decodedMaxAmount,\n    decodedAmountPerSecond,\n    decodedStartTime,\n  ] = decodedTerms;\n\n  // Simulate using decoded terms with spent = 0\n  const availableAmount = getAvailableAmount({\n    initialAmount: decodedInitialAmount,\n    maxAmount: decodedMaxAmount,\n    amountPerSecond: decodedAmountPerSecond,\n    startTime: decodedStartTime,\n    spent: 0n,\n    currentTimestamp,\n  });\n\n  return {\n    availableAmount,\n  };\n};\n\n/**\n * Replicates the internal _getAvailableAmount logic from the smart contract.\n *\n * @param allowance - The allowance object containing all parameters.\n * @param allowance.initialAmount - The initial amount available.\n * @param allowance.maxAmount - The maximum amount allowed.\n * @param allowance.amountPerSecond - The amount streamed per second.\n * @param allowance.startTime - The start time of the streaming.\n * @param allowance.spent - The amount already spent.\n * @param allowance.currentTimestamp - The current timestamp.\n * @returns The available amount that can be spent.\n */\nfunction getAvailableAmount(allowance: {\n  initialAmount: bigint;\n  maxAmount: bigint;\n  amountPerSecond: bigint;\n  startTime: bigint;\n  spent: bigint;\n  currentTimestamp: bigint;\n}): bigint {\n  // If current time is before start time, nothing is available\n  if (allowance.currentTimestamp < allowance.startTime) {\n    return 0n;\n  }\n\n  // Calculate elapsed time since start\n  const elapsed = allowance.currentTimestamp - allowance.startTime;\n\n  // Calculate total unlocked amount\n  let unlocked = allowance.initialAmount + allowance.amountPerSecond * elapsed;\n\n  // Cap by max amount\n  if (unlocked > allowance.maxAmount) {\n    unlocked = allowance.maxAmount;\n  }\n\n  // If spent >= unlocked, nothing available\n  if (allowance.spent >= unlocked) {\n    return 0n;\n  }\n\n  // Return available amount\n  return unlocked - allowance.spent;\n}\n"]}